<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Performance]]></title>
  <subtitle><![CDATA[True mastery of any skill takes a lifetime]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://androidperformance.com/"/>
  <updated>2016-01-04T12:59:35.000Z</updated>
  <id>http://androidperformance.com/</id>
  
  <author>
    <name><![CDATA[Gracker]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Android 中如何计算 App 的启动时间？]]></title>
    <link href="http://androidperformance.com/2015/12/31/How-to-calculation-android-app-lunch-time.html"/>
    <id>http://androidperformance.com/2015/12/31/How-to-calculation-android-app-lunch-time.html</id>
    <published>2015-12-31T05:52:30.000Z</published>
    <updated>2016-01-04T12:59:35.000Z</updated>
    <content type="html"><![CDATA[<p>之前有人在知乎提问：<a href="https://www.zhihu.com/question/35487841/answer/63011462" target="_blank" rel="external">“怎么计算apk的启动时间？”</a> :</p>
<blockquote>
<p>利用python或者直接用adb命令怎么计算apk的启动时间呢？就是计算从点击图标到apk完全启动所花费的时间。比如，对游戏来说就是点击游戏图标到进入到登录界面的这段时间。<br>已知的两种方法貌似可以获取，但是感觉结果不准确：一种是，adb shell am start -w packagename/activity,这个可以得到两个值，ThisTime和TotalTime，不知道两个有什么区别，而且与实际启动时间不匹配，两者相加都可能比实际启动时间小（测试游戏的时候差别更大）；另外一种是通过adb logcat的方式，感觉获取的结果也与实际有差别。</p>
</blockquote>
<p>我和另外一个同事<a href="https://www.zhihu.com/people/guo-qi-fa" target="_blank" rel="external">郭启发</a> 针对两个方面进行了回答，不过毕竟知乎上看的人会比较少，所以我在征得他的同意之后，将这两个答案整理了一下，记录到博客中，一来算是一个小的总结，之后自己看得时候比较方便，二来给需要的同学一个更加方便的途径。</p>
<a id="more"></a>
<h1 id="1_应用启动场景">1 应用启动场景</h1><p>事实上 Android 中一个 App 的启动时间可以准确计算的.但是要分场景.也就是说要分开游戏和应用. 大家都知道,在Android中,游戏开发和应用开发是两码事.所以我们需要分开来说.</p>
<h2 id="1-1_应用启动">1.1 应用启动</h2><p>我们平时在写应用的时候,一般会指定一个 mainActivity ,用户在桌面上点击这个 Activity 的时候,系统会直接起这个 Activity. 我们知道 Activity 在启动的时候会走 onCreate/onStart/onResume .这几个回调函数.</p>
<p>许多书里讲过,当执行完 onResume 函数之后,应用就显示出来了…其实这是一种不准确的说法,因为从系统层面来看,一个 Activity 走完 onCreate/onStart/onResume 这几个生命周期之后,只是完成了应用自身的一些配置,比如 window 的一些属性的设置/ View 树的建立(只是建立,并没有显示,也就是说只是调用了 inflate 而已) . 后面 ViewRootImpl 还会调用两次performTraversals ,初始化 Egl 以及 measure/layout/draw. 等.<br>所以我们定义一个 Android 应用的启动时间, 肯定不能在 Activity 的回调函数上下手.而是以用户在手机屏幕上看到你在 onCreate 的 setContentView 中设置的 layout 完全显示为准,也就是我们常说的应用第一帧.</p>
<p>上面扯得有点远,不感兴趣的话可以不看,下面直接说方法.<br>题主说的 adb shell am start -w packagename/activity,是可以完全应用的启动时间的.不过也要分场景.</p>
<h2 id="1-2_应用第一次启动">1.2 应用第一次启动</h2><p>也就是我们常说的冷启动,这时候你的应用程序的进程是没有创建的. 这也是大部分应用的使用场景.用户在桌面上点击你应用的 icon 之后,首先要创建进程,然后才启动 MainActivity.<br>这时候adb shell am start -w packagename/MainActivity 返回的结果,就是标准的应用程序的启动时间（注意 Android 5.0 之前的手机是没有 WaitTime 这个值的）:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10140; adb shell am start -W com.media.painter/com.media.painter.PainterMainActivity&#10;Starting: Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.media.painter/.PainterMainActivity &#125;&#10;Status: ok&#10;Activity: com.media.painter/.PainterMainActivity&#10;ThisTime: 355&#10;TotalTime: 355&#10;WaitTime: 365&#10;Complete</span><br></pre></td></tr></table></figure>
<p>总共返回了三个结果,我们以 WaitTime 为准. </p>
<p>关于ThisTime/TotalTime/WaitTime的区别,下面是其解释：</p>
<p>“adb shell am start -W ”的实现在 frameworks\base\cmds\am\src\com\android\commands\am\Am.java 文件中。其实就是跨Binder调用ActivityManagerService.startActivityAndWait() 接口（后面将ActivityManagerService简称为AMS），这个接口返回的结果包含上面打印的ThisTime、TotalTime时间.</p>
<p><img src="/images/applunch3/1.png" alt="ThisTime/TotalTime"></p>
<ul>
<li>startTime记录的刚准备调用startActivityAndWait()的时间点</li>
<li>endTime记录的是startActivityAndWait()函数调用返回的时间点</li>
<li>WaitTime = startActivityAndWait()调用耗时。    </li>
</ul>
<p>ThisTime、TotalTime 的计算在 frameworks\base\services\core\java\com\android\server\am\ActivityRecord.java 文件的 reportLaunchTimeLocked() 函数中。</p>
<p><img src="/images/applunch3/2.png" alt="curTime/displayStartTime/mLaunchStartTime"></p>
<p>我们来解释下代码里curTime、displayStartTime、mLaunchStartTime三个时间变量.</p>
<ul>
<li>curTime表示该函数调用的时间点.</li>
<li>displayStartTime表示一连串启动Activity中的最后一个Activity的启动时间点.</li>
<li>mLaunchStartTime表示一连串启动Activity中第一个Activity的启动时间点. </li>
</ul>
<p>正常情况下点击桌面图标只启动一个有界面的 Activity，此时 displayStartTime 与mLaunchStartTime 便指向同一时间点，此时 ThisTime=TotalTime。另一种情况是点击桌面图标应用会先启动一个无界面的 Activity 做逻辑处理，接着又启动一个有界面的Activity，在这种启动一连串 Activity 的情况下（知乎的启动就是属于这种情况），displayStartTime 便指向最后一个 Activity 的开始启动时间点，mLaunchStartTime 指向第一个无界面Activity的开始启动时间点，此时 ThisTime！=TotalTime。这两种情况如下图：</p>
<p><img src="/images/applunch3/3.png" alt="curTime/displayStartTime/mLaunchStartTime"></p>
<p>在上面的图中，我用①②③分别标注了三个时间段，在这三个时间段内分别干了什么事呢？           </p>
<ul>
<li>在第①个时间段内，AMS 创建 ActivityRecord 记录块和选择合理的 Task、将当前Resume 的 Activity 进行 pause</li>
<li>在第②个时间段内，启动进程、调用无界面 Activity 的 onCreate() 等、 pause/finish 无界面的 Activity</li>
<li>在第③个时间段内，调用有界面 Activity 的 onCreate、onResume</li>
</ul>
<p>看到这里应该清楚 ThisTime、TotalTime、WaitTime 三个时间的关系了吧：</p>
<ul>
<li>WaitTime 就是总的耗时，包括前一个应用 Activity pause 的时间和新应用启动的时间；</li>
<li>ThisTime 表示一连串启动 Activity 的最后一个 Activity 的启动耗时；</li>
<li>TotalTime 表示新应用启动的耗时，包括新进程的启动和 Activity 的启动，但不包括前</li>
</ul>
<p>一个应用 Activity pause 的耗时。也就是说，开发者一般只要关心 TotalTime 即可，这个时间才是自己应用真正启动的耗时。    </p>
<p>Event log中 TAG=am_activity_launch_time 中的两个值分表表示 ThisTime、TotalTime，跟通过 “adb shell am start -W ” 得到的值是一致的。    </p>
<p>最后再说下系统根据什么来判断应用启动结束。我们知道应用启动包括进程启动、走 Activity生命周期 onCreate/onResume 等。在第一次 onResume 时添加窗口到WMS中，然后measure/layout/draw，窗口绘制完成后通知 WMS，WMS 在合适的时机控制界面开始显示(夹杂了界面切换动画逻辑)。记住是窗口界面显示出来后，WMS 才调用reportLaunchTimeLocked() 通知 AMS Activity 启动完成。    </p>
<p><strong><em>最后总结一下，如果只关心某个应用自身启动耗时，参考TotalTime；如果关心系统启动应用耗时，参考WaitTime；如果关心应用有界面Activity启动耗时，参考ThisTime。</em></strong></p>
<h2 id="1-2_应用非第一次启动">1.2 应用非第一次启动</h2><p>如果是你按Back键，并没有将应用进程杀掉的话，那么执行上述命令就会快一些，因为不用创建进程了，只需要启动一个Activity即可。这也就是我们说的应用热启动。</p>
<h1 id="2_游戏启动场景">2 游戏启动场景</h1><p>游戏启动的话，就不适用用命令行的方法来启动了，因为从用户点击桌面图标到登录界面，既有系统的部分也有游戏自己的部分。</p>
<h2 id="2-1_系统部分">2.1 系统部分</h2><p>游戏也有一个 Activity，所以启动的时候还是会去启动这个 Activity，所以系统启动部分也就是用户点击桌面桌面响应到这个Activity启动。</p>
<h2 id="2-2_游戏部分">2.2 游戏部分</h2><p>一般游戏的主 Activity 启动后，还会做一些比较耗时的事情，这时候你看到的界面是不能操作的，比如：加载游戏数据、联网更新数据、读取和更新配置文件、游戏引擎初始化等操作。从游戏开发的角度来看，到了真正用户能操作的界面才算是一个游戏真正加载完成的时间。<br>那么这个时间，就得使用 Log 来记录了，因为加载游戏数据、联网更新数据、读取和更新配置文件、游戏引擎初始化这些操作，都是游戏自己的逻辑，与系统无关，所以得由游戏自己定义加载完成的点。</p>
<p>对于游戏的启动时间，我们更倾向于计算从<strong>点击桌面图标</strong>到<strong>用户可以与游戏进行交互</strong>这个时间段作为一个游戏的启动时间。</p>
<h1 id="3_总结">3 总结</h1><p>计算机最让人着迷的一点就是其准确性，1+1 永远等于 2，启动耗时多久就是多久，每一次可能不一样，但每一次的时间都是这一次的准确时间。</p>
<p>不过每个公司由于对应用的定位不同，所以对应用启动的要求也不一样。比如有的做 ROM 的公司，其内置应用的启动时间一定是要非常快的，这样给用户的第一感觉就是快、流畅；互联网公司的 App 则不是很关心启动速度，大部分互联网公司的应用都有一个启动页，用来展示广告或者功能介绍之类的，然后才会进入到主界面。需求不一样，这么做也无可厚非，不过从消费者的角度来看，越早见到主界面当然越好。</p>
<p>所以在做一个 Android App 的时候，一定要记得将应用的启动时间作为一个性能指标，毕竟：</p>
<blockquote>
<p>天下武功，唯快不破！</p>
</blockquote>
<h1 id="4_关于作者">4 关于作者</h1><p>文章里提到的我的同事郭启发，其</p>
<ul>
<li>知乎: <a href="https://www.zhihu.com/people/guo-qi-fa" target="_blank" rel="external">郭启发，Android framework</a> </li>
<li>微博: <a href="http://weibo.com/u/2324939963?topnav=1&amp;wvr=6&amp;topsug=1" target="_blank" rel="external">guoqifa_meizu</a></li>
</ul>
<p>他对 Android Framework 研究很深，感兴趣的可以和他聊聊。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前有人在知乎提问：<a href="https://www.zhihu.com/question/35487841/answer/63011462">“怎么计算apk的启动时间？”</a> :</p>
<blockquote>
<p>利用python或者直接用adb命令怎么计算apk的启动时间呢？就是计算从点击图标到apk完全启动所花费的时间。比如，对游戏来说就是点击游戏图标到进入到登录界面的这段时间。<br>已知的两种方法貌似可以获取，但是感觉结果不准确：一种是，adb shell am start -w packagename/activity,这个可以得到两个值，ThisTime和TotalTime，不知道两个有什么区别，而且与实际启动时间不匹配，两者相加都可能比实际启动时间小（测试游戏的时候差别更大）；另外一种是通过adb logcat的方式，感觉获取的结果也与实际有差别。</p>
</blockquote>
<p>我和另外一个同事<a href="https://www.zhihu.com/people/guo-qi-fa">郭启发</a> 针对两个方面进行了回答，不过毕竟知乎上看的人会比较少，所以我在征得他的同意之后，将这两个答案整理了一下，记录到博客中，一来算是一个小的总结，之后自己看得时候比较方便，二来给需要的同学一个更加方便的途径。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/tags/Android/"/>
    
      <category term="启动优化" scheme="http://androidperformance.com/tags/%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
      <category term="性能优化" scheme="http://androidperformance.com/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android应用启动优化:一种DelayLoad的实现和原理(下篇)]]></title>
    <link href="http://androidperformance.com/2015/12/29/Android%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96-%E4%B8%80%E7%A7%8DDelayLoad%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%8E%9F%E7%90%86-%E4%B8%8B%E7%AF%87.html"/>
    <id>http://androidperformance.com/2015/12/29/Android应用启动优化-一种DelayLoad的实现和原理-下篇.html</id>
    <published>2015-12-29T08:34:06.000Z</published>
    <updated>2015-12-31T02:19:58.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.androidperformance.com/2015/11/18/Android-app-lunch-optimize-delay-load.html" target="_blank" rel="external">上一篇文章</a>我们使用第三种方法来实现延迟加载。不过上一篇写的比较简单，只是讲解了如何去实现，这一篇就来讲一下为何要这么做，以及这么做后面的原理。<br>其中会涉及到一些 Android 中的比较重要的类，以及 Activity 生命周期中比较重要的几个函数。<br>其实这个其中的原理比较简单，不过要弄清楚其实现的过程，还是一件蛮好玩的事情，其中会用到一些工具，自己加调试代码等，一步一步下来，自己对 Activity 的启动的理解又深了一层，希望大家读完之后也会对大家有一定的帮助。</p>
<a id="more"></a>
<p>上一篇中我们最终使用的 DelayLoad 的核心方法是在 Activity 的 onCreate 函数中加入下面的方法 ：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getWindow().getDecorView().post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        myHandler.post(mLoadingRunnable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>我们一一来看涉及到的类和方法</p>
<h2 id="1-_Activity-getWindow_及_PhoneWindow_的初始化时机">1. Activity.getWindow 及 PhoneWindow 的初始化时机</h2><p>Activity 的 getWindow 方法获取到的是一个 PhoneWindow 对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Window <span class="title">getWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mWindow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 这个 mWindow 就是一个 PhoneWindow 对象，其初始化的时机为这个 Activity attach 的时候：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span><br><span class="line">          Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span><br><span class="line">          Application application, Intent intent, ActivityInfo info,</span><br><span class="line">          CharSequence title, Activity parent, String id,</span><br><span class="line">          NonConfigurationInstances lastNonConfigurationInstances,</span><br><span class="line">          Configuration config, String referrer, IVoiceInteractor voiceInteractor)</span> </span>&#123;</span><br><span class="line">      attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">      mFragments.attachActivity(<span class="keyword">this</span>, mContainer, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">      mWindow = PolicyManager.makeNewWindow(<span class="keyword">this</span>);</span><br><span class="line">      mWindow.setCallback(<span class="keyword">this</span>);</span><br><span class="line">      mWindow.setOnWindowDismissedCallback(<span class="keyword">this</span>);</span><br><span class="line">      mWindow.getLayoutInflater().setPrivateFactory(<span class="keyword">this</span>);</span><br><span class="line">      ........</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PolicyManager.makeNewWindow(this) 最终会调用 Policy 的 makeNewWindow 方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Window <span class="title">makeNewWindow</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> PhoneWindow(context);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意 Activity 的 attach 方法很早就会调用的，是要早于 Activity 的 onCreate 方法的。 </p>
<h3 id="总结：">总结：</h3><ul>
<li>PhoneWindow 与 Activity 是一对一的关系，通过上面的初始化过程你应该更加清楚这个概念</li>
<li>Android 中对 PhoneWindow 的注释是 ：Android-specific Window ，可见其重要性</li>
<li>PhoneWindow 中有很多大家比较熟悉的方法，比如 setContentView / addContentView 等 ； 也有几个重要的内部类，比如：DecorView ;</li>
</ul>
<h2 id="2-_PhoneWindow-getDecorView_及_DecorView_的初始化时机">2. PhoneWindow.getDecorView 及 DecorView 的初始化时机</h2><p>上面我们说到 DecorView是 PhoneWindow 的一个内部类，其定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DecorView</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span> <span class="keyword">implements</span> <span class="title">RootViewSurfaceTaker</span></span></span><br></pre></td></tr></table></figure></p>
<p>那么 DecorView 是什么时候初始化的呢？DecorView 是在 Activity 的父类的 onCreate 方法中被初始化的，比如我例子中的 MainActivity 是继承自 android.support.v7.app.AppCompatActivity ，当我们调用 MainActivity 的 super.onCreate(savedInstanceState); 的时候，就会调用下面的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    getDelegate().installViewFactory();</span><br><span class="line">    getDelegate().onCreate(savedInstanceState);</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于我们导入的是 support.v7 包里面的AppCompatActivity， getDelegate() 得到的就是AppCompatDelegateImplV7 ，其 onCreate 方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">    mWindowDecor = (ViewGroup) mWindow.getDecorView();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就是这里的 mWindow.getDecorView() ，对 DecorView 进行了实例化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title">getDecorView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mDecor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一次调用 getDecorView 的时候，会进入 installDecor 方法，这个方法对 DecorView 进行了一系列的初始化 ，其中比较重要的几个方法有：generateDecor / generateLayout 等，generateLayout 会从当前的 Activity 的 Theme 提取相关的属性，设置给 Window，同时还会初始化一个 startingView，添加到 DecorView上，也就是我们所说的 startingWindow。</p>
<h3 id="总结">总结</h3><ul>
<li>Decor 有装饰的意思，DecorView 官方注释为 “This is the top-level view of the window, containing the window decor” , 我们可以理解为 DecorView 是我们当前 Activity 的最下面的布局。所以我们打开 DDMS 查看 Tree Overview 的时候，可以发现最根部的那个 View 就是 DecorView：<br>  <img src="/images/applunch2/1.png" alt="DelayLoad"></li>
<li>应用从桌面启动的时候，在主 Activity 还没有显示的时候，如果主题没有设置窗口的背景，那么我们就会看到白色（这个和手机的Rom也有关系），如果应用启动很慢，那么用户得看好一会白色。如果要避免这个，则可以在 Application 或者 Activity 的 Theme 中设置 WindowBackground , 这样就可以避免白色（当然现在各种大厂都是SplashActivity+广告我也是可以理解的）</li>
</ul>
<h2 id="3-_Post">3. Post</h2><p>当我们调用 DecorView 的 Post 的时候，其实最终会调用 View 的 Post ，因为 DecorView 最终是继承 View 的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (attachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> attachInfo.mHandler.post(action);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Assume that post will succeed later</span></span><br><span class="line">    ViewRootImpl.getRunQueue().post(action);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意这里的 mAttachInfo ，我们调用 post 是在 Activity 的 onCreate 中调用的，那么此时 mAttachInfo 是否为空呢？答案是 mAttachInfo 此时为空。</p>
<p>这里有一个点就是 Activity 的各个回调函数都是干嘛的？是不是平时自己写应用的时候，貌似在 onCreate 里面搞定一切就OK了， onResume ？ onStart？没怎么涉及到嘛，其实不然。<br>onCreate 顾名思义就是 Create ，我们在前面看到，Activity 的 onCreate 函数做了很多初始化的操作，包括 PhoneWindow/DecorView/StartingView/setContentView等，但是 onCreate 只是初始化了这些对象.<br>真正要设置为显示则在 Resume 的时候，不过这些对开发者是透明了，具体可以看 ActivityThread 的 handleResumeActivity 函数，handleResumeActivity 中除了调用 Activity 的 onResume 回调之外，还初始化了几个比较重要的类：ViewRootImpl / ThreadedRenderer。</p>
<p>ActivityThread.handleResumeActivity:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">    r.window = r.activity.getWindow();</span><br><span class="line">    View decor = r.window.getDecorView();</span><br><span class="line">    decor.setVisibility(View.INVISIBLE);</span><br><span class="line">    ViewManager wm = a.getWindowManager();</span><br><span class="line">    WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">    a.mDecor = decor;</span><br><span class="line">    l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">    l.softInputMode |= forwardBit;</span><br><span class="line">    <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">        a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">        wm.addView(decor, l);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>主要是 wm.addView(decor, l); 这句，将 decorView 与 WindowManagerImpl联系起来，这句最终会调用到 WindowManagerGlobal 的 addView 函数，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span><br><span class="line">        Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = <span class="keyword">null</span>;</span><br><span class="line">    ......</span><br><span class="line">        root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">        mViews.add(view);</span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        mParams.add(wparams);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do this last because it fires off messages to start doing things</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        root.setView(view, wparams, panelParentView);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道 ViewRootImpl 是 View 系统的一个核心类，其定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewRootImpl</span> <span class="keyword">implements</span> <span class="title">ViewParent</span>,</span><br><span class="line">        <span class="title">View</span>.<span class="title">AttachInfo</span>.<span class="title">Callbacks</span>, <span class="title">HardwareRenderer</span>.<span class="title">HardwareDrawCallbacks</span></span></span><br></pre></td></tr></table></figure></p>
<p>ViewRootImpl 初始化的时候会对 AttachInfo 进行初始化，这就是为什么之前的在 onCreate 的时候 attachInfo 为空。ViewRootImpl 里面有很多我们比较熟悉也非常重要的方法，比如 performTraversals / performLayout / performMeasure / performDraw / draw 等。<br>我们继续 addView 中的root.setView(view, wparams, panelParentView); 传入的 view 为 decorView，root 为 ViewRootImpl ，这个函数中将 ViewRootImpl 的mView 变量 设置为传入的view，也就是 decorView。<br>这样来看，ViewRootImpl 与 DecorView 的关系我们也清楚了。</p>
<p>扯了一圈，我们再回到大标题的 Post 函数上，前面有说这个 Post 走的是 View 的Post 函数，由于 在 onCreate 的时候 attachInfo 为空，所以会走下面的分支：ViewRootImpl.getRunQueue().post(action);<br>注意这里的 getRunQueue 得到的并不是 Looper 里面的那个 MessageQueue，而是由 ViewRootImpl 维持的一个 RunQueue 对象，其核心为一个 ArrayList ：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;HandlerAction&gt; mActions = <span class="keyword">new</span> ArrayList&lt;HandlerAction&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">post</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">            postDelayed(action, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">postDelayed</span><span class="params">(Runnable action, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">            HandlerAction handlerAction = <span class="keyword">new</span> HandlerAction();</span><br><span class="line">            handlerAction.action = action;</span><br><span class="line">            handlerAction.delay = delayMillis;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (mActions) &#123;</span><br><span class="line">                mActions.add(handlerAction);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">executeActions</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mActions) &#123;</span><br><span class="line">                <span class="keyword">final</span> ArrayList&lt;HandlerAction&gt; actions = mActions;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> count = actions.size();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                    <span class="keyword">final</span> HandlerAction handlerAction = actions.get(i);</span><br><span class="line">                    handler.postDelayed(handlerAction.action, handlerAction.delay);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                actions.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们执行了 Post 之后 ，其实只是把 Runnable 封装成一个 HandlerAction 对象存入到 ArrayList 中，当执行到 executeActions 方法的时候，将存在这里的 HandlerAction 再通过 executeActions 方法传入的 Handler 对象重新进行 Post。<br>那么 executeActions 方法是什么时候执行的呢？传入的 Handler 又是哪个 Handler 呢？</p>
<h2 id="4-_PerformTraversals">4. PerformTraversals</h2><p>我们之前讲过，ViewRootImpl 的 performTraversals 方法是一个很核心的方法，每一帧绘制都会走一遍，调用各种 measure / layout / draw 等 ，最终将要显示的数据交给 hwui 去进行绘制。<br>我们上一节讲到的 executeActions ，就是在 performTraversals 中执行的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Execute enqueued actions on every traversal in case a detached view enqueued an action</span></span><br><span class="line">getRunQueue().executeActions(mAttachInfo.mHandler);</span><br></pre></td></tr></table></figure></p>
<p>可以看到这里传入的 Handler 是 mAttachInfo.mHandler ，上一节讲到 mAttachInfo 是在 ViewRootImpl 初始化的时候一起初始化的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mAttachInfo = <span class="keyword">new</span> View.AttachInfo(mWindowSession, mWindow, display, <span class="keyword">this</span>, mHandler, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></p>
<p>这里的 mHandler 是一个 ViewRootHandler 对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewRootHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">final</span> ViewRootHandler mHandler = <span class="keyword">new</span> ViewRootHandler();</span><br></pre></td></tr></table></figure></p>
<p>我们注意到 ViewRootHandler 在创建的时候并没有传入一个 Looper 对象，这意味着此 ViewRootHandler 的 Looper 就是 mainLooper。</p>
<p><strong><em>这下我们就清楚了，我们在 onCreate 中 Post 的 runnable 对象，最终还是在第一个 performTraversals 方法执行的时候，加入到了 MainLooper 的 MessageQueue 里面了。</em></strong></p>
<p>绕了一圈终于我们终于把文章最前面的那句话解释清楚了，当然中间还有很多的废话，不过我估计能耐着性子看到这里的人会很少，所以如果你看到了这里，可以在底下的评论里面将 index ++ ；这里 index = 0 ；就是看看几个人是真正认真看了这篇文章的。</p>
<h2 id="5-_UpdateText">5. UpdateText</h2><p>接着 performTraversals 我们继续说，话说在<a href="http://www.androidperformance.com/2015/11/18/Android-app-lunch-optimize-delay-load.html" target="_blank" rel="external">第一篇文章</a> 我们有讲到，Activity 在启动时，会在第二次执行 performTraversals 才会去真正的绘制，原因在于第一次执行 performTraversals 的时候，会走到 Egl 初始化的逻辑，然后会重新执行一次 performTraversals 。<br>所以前一篇文章的评论区有人问为何在 run 方法里面还要 post 一次，如果在 run 方法里面直接执行 updateText 方法 ，那么 updateText 就会在第一个 performTraversals 之后就执行，而不是在第一帧绘制完成后才去执行，所以我们又 Post 了一次 。所以大概的处理步骤如下：</p>
<blockquote>
<p>第一步：Activity.onCreate –&gt; Activity.onStart –&gt; Activity.onResume</p>
<p>第二步：ViewRootImpl.performTraversals –&gt;Runnable</p>
<p>第三步：Runnable –&gt; ViewRootImpl.performTraversals</p>
<p>第四步：ViewRootImpl.performTraversals –&gt; UpdateText</p>
<p>第五步：UpdateText</p>
</blockquote>
<h2 id="6-_总结">6. 总结</h2><p>其实一路跟下来发现其实原理很简单，其实 DelayLoad 其实只是一个很小的点，关键是教大家如何去跟踪一个自己不认识的知识点或者优化，这里面主要用到了两个工具：Systrace 和 Method Trace， 以及源码编译和调试。<br>关于 Systrace 和 Method Trace 的使用，之后会有详细的文章去介绍，这两个工具非常有助于理解源码和一些技术的实现。</p>
<h3 id="Systrace">Systrace</h3><p><img src="/images/applunch2/2.png" alt="Systrace"></p>
<h3 id="Method_Trace">Method Trace</h3><p><img src="/images/applunch2/3.png" alt="Method Trace"></p>
<h3 id="源码编译与调试">源码编译与调试</h3><p><img src="/images/applunch2/4.png" alt="源码编译与调试"></p>
<h3 id="代码">代码</h3><p>本文章所所涉及到的代码我放到了Github上：<br><a href="https://github.com/Gracker/DelayLoadSample" target="_blank" rel="external">https://github.com/Gracker/DelayLoadSample</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://www.androidperformance.com/2015/11/18/Android-app-lunch-optimize-delay-load.html">上一篇文章</a>我们使用第三种方法来实现延迟加载。不过上一篇写的比较简单，只是讲解了如何去实现，这一篇就来讲一下为何要这么做，以及这么做后面的原理。<br>其中会涉及到一些 Android 中的比较重要的类，以及 Activity 生命周期中比较重要的几个函数。<br>其实这个其中的原理比较简单，不过要弄清楚其实现的过程，还是一件蛮好玩的事情，其中会用到一些工具，自己加调试代码等，一步一步下来，自己对 Activity 的启动的理解又深了一层，希望大家读完之后也会对大家有一定的帮助。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/tags/Android/"/>
    
      <category term="DelayLoad" scheme="http://androidperformance.com/tags/DelayLoad/"/>
    
      <category term="启动优化" scheme="http://androidperformance.com/tags/%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
      <category term="性能优化" scheme="http://androidperformance.com/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android应用启动优化:一种DelayLoad的实现和原理(上篇)]]></title>
    <link href="http://androidperformance.com/2015/11/18/Android-app-lunch-optimize-delay-load.html"/>
    <id>http://androidperformance.com/2015/11/18/Android-app-lunch-optimize-delay-load.html</id>
    <published>2015-11-18T12:23:14.000Z</published>
    <updated>2015-12-29T08:34:58.000Z</updated>
    <content type="html"><![CDATA[<h1 id="0-_应用启动优化概述">0. 应用启动优化概述</h1><p>在 Android 开发中,应用启动速度是一个非常重要的点,应用启动优化也是一个非常重要的过程.对于应用启动优化,其实核心思想就是在启动过程中少做事情,具体实践的时候无非就是下面几种:</p>
<ol>
<li>异步加载</li>
<li>延时加载</li>
<li>懒加载</li>
</ol>
<p>不用一一去解释,做过启动优化的估计都使用过,本篇文章将详细讲解一下一种延时加载的实现以及其原理.<br>其实这种加载的实现是非常简单的,但是其中的原理可能比较复杂,还涉及到Looper/Handler/MessageQueue/VSYNC等.以及其中碰到的一些问题,还会有一些我自己额外的思考.</p>
<a id="more"></a>
<h1 id="1-_优化后的DelayLoad的实现">1. 优化后的DelayLoad的实现</h1><p>一提到DelayLoad,大家可能第一时间想到的就是在 onCreate 里面调用 Handler.postDelayed方法, 将需要 Delay 加载的东西放到这里面去初始化, 这个也是一个比较方便的方法. Delay一段时间再去执行,这时候应用已经加载完成,界面已经显示出来了, 不过这个方法有一个致命的问题: 延迟多久?<br>大家都知道,在 Android 的高端机型上,应用的启动是非常快的 , 这时候只需要 Delay 很短的时间就可以了, 但是在低端机型上,应用的启动就没有那么快了,而且现在应用为了兼容旧的机型,往往需要 Delay 较长的时间,这样带来体验上的差异是很明显的.</p>
<p>这里先说优化方案:</p>
<ol>
<li><p>首先 , 创建 Handler 和 Runnable 对象, 其中 Runnable 对象的 run方法里面去更新 UI 线程.</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler myHandler = <span class="keyword">new</span> Handler();</span><br><span class="line"><span class="keyword">private</span> Runnable mLoadingRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    updateText(); <span class="comment">//更新UI线程</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在主 Activity 的 onCreate 中加入下面的代码</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getWindow().getDecorView().post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    myHandler.post(mLoadingRunnable);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>其实实现的话非常简单,我们来对比一下三种方案的效果.</p>
<h1 id="2-_三种写法的差异对比">2. 三种写法的差异对比</h1><p>为了验证我们优化的 DelayLoad的效果,我们写了一个简单的app , 这个 App 中包含三张不同大小的图片,每张图片下面都会有一个 TextView , 来标记图片的显示高度和宽度. MainActivity的代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEALY_TIME = <span class="number">300</span> ;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ImageView imageView1;</span><br><span class="line">  <span class="keyword">private</span> ImageView imageView2;</span><br><span class="line">  <span class="keyword">private</span> ImageView imageView3;</span><br><span class="line">  <span class="keyword">private</span> TextView textView1;</span><br><span class="line">  <span class="keyword">private</span> TextView textView2;</span><br><span class="line">  <span class="keyword">private</span> TextView textView3;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Handler myHandler = <span class="keyword">new</span> Handler();</span><br><span class="line">  <span class="keyword">private</span> Runnable mLoadingRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      updateText();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    imageView1 = (ImageView) findViewById(R.id.image1);</span><br><span class="line">    imageView2 = (ImageView) findViewById(R.id.image2);</span><br><span class="line">    imageView3 = (ImageView) findViewById(R.id.image3);</span><br><span class="line"></span><br><span class="line">    textView1 = (TextView) findViewById(R.id.text1);</span><br><span class="line">    textView2 = (TextView) findViewById(R.id.text2);</span><br><span class="line">    textView3 = (TextView) findViewById(R.id.text3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  第一种写法:直接Post</span></span><br><span class="line">    myHandler.post(mLoadingRunnable);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  第二种写法:直接PostDelay 300ms.</span></span><br><span class="line"><span class="comment">//  myHandler.postDelayed(mLoadingRunnable, DEALY_TIME);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  第三种写法:优化的DelayLoad</span></span><br><span class="line"><span class="comment">//  getWindow().getDecorView().post(new Runnable() &#123;</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public void run() &#123;</span></span><br><span class="line"><span class="comment">//      myHandler.post(mLoadingRunnable);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//  &#125;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dump当前的MessageQueue信息.</span></span><br><span class="line">    getMainLooper().dump(<span class="keyword">new</span> Printer() &#123;</span><br><span class="line"></span><br><span class="line">      <span class="annotation">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">"Gracker"</span>,x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="string">"onCreate"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TraceCompat.beginSection(<span class="string">"updateText"</span>);</span><br><span class="line">    textView1.setText(<span class="string">"image1 : w="</span> + imageView1.getWidth() +</span><br><span class="line">      <span class="string">" h ="</span> + imageView1.getHeight());</span><br><span class="line">    textView2.setText(<span class="string">"image2 : w="</span> + imageView2.getWidth() +</span><br><span class="line">      <span class="string">" h ="</span> + imageView2.getHeight());</span><br><span class="line">    textView3.setText(<span class="string">"image3 : w="</span> + imageView3.getWidth() +</span><br><span class="line">      <span class="string">" h ="</span> + imageView3.getHeight());</span><br><span class="line">    TraceCompat.endSection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要关注两个点:</p>
<ul>
<li>updateText 这个函数是什么时候被执行的?</li>
<li>App 启动后,三个图片的长宽是否可以被正确地显示出来?</li>
<li>是否有 Delay Load 的效果?</li>
</ul>
<h2 id="2-1_第一种写法">2.1 第一种写法</h2><ol>
<li><p>updateText执行的时机?<br>下面是第一种写法的Trace图:<br><img src="/images/app-lunch/1.png" alt="第一种写法"><br>可以看到 updateText 是在 Activity 的 onCreate/onStart/onResume三个回调执行完成后才去执行的.</p>
</li>
<li><p>图片的宽高是否正确显示?<br><img src="/images/app-lunch/2.png" alt="第一种写法"></p>
<p>从图片看一看到,宽高并没有显示. 这是为什么呢? 这个问题就要从Activity 的 onCreate/onStart/onResume三个回调说起了. 其实Activity 的 onCreate/onStart/onResume三个回调中,并没有执行Measure和Layout操作, 这个是在后面的performTraversals中才执行的. 所以在这之前宽高都是0.</p>
</li>
<li><p>是否有 Delay Load 的效果?<br>并没有. 因为我们知道, 应用启动的时候,要等两次 performTraversals 都执行完成之后才会显示第一帧, 而 updateText 这个方法在第一个 performTraversals 执行之前就执行了. 所以 updateText 方法的执行时间是算在应用启动的时间里面的.</p>
</li>
</ol>
<h2 id="2-2_第二种写法">2.2 第二种写法</h2><p>第二种写法我们Delay了300ms .我们来看一下表现.</p>
<ol>
<li><p>updateText执行的时机?<br><img src="/images/app-lunch/3.png" alt="第二种写法"></p>
<p>可以看到,这种写法的话,updateText是在两个performTraversals 执行完成之后(这时候 APP 的第一帧才显示出来)才去执行的, 执行完成之后又调用了一次 performTraversals 将 TextView 的内容进行更新.</p>
</li>
<li><p>图片的宽高是否正确显示?<br><img src="/images/app-lunch/4.png" alt="第二种写法"></p>
<p>从上图可以看到,图片的宽高是正确显示了出来. 原因上面已经说了,measure/layout执行完成后,宽高的数据就可以获取了.</p>
</li>
<li><p>是否有 Delay Load 的效果?<br>不一定,取决于 Delay的时长.<br>从前面的 Trace 图上我们可以看到 , updateText 方法由于 Delay 了300ms, 所以在应用第一帧显示出来170ms之后, 图片的文字信息才进行了更新. 这个是有 Delay Load 的效果的.<br>但是这里只是一个简单的TextView的更新, 如果是较大模块的加载 , 用户视觉上会有很明显的 “ 空白->内容填充” 这个过程, 或者会附加”闪一下”特效…这显然是我们不想看到的.</p>
<p>有人会说:可以把Delay的时间减小一点嘛,这样就不会闪了. 话是这么说,但是由于 Android 机器的多元性(其实就是有很多高端机器,也有很多低端机器) , 在这个机子上300ms的延迟算是快,在另外一个机子上300ms算是很慢.</p>
<p>我们将Delay时间调整为50ms, 其Trace图如下:</p>
<p><img src="/images/app-lunch/5.png" alt="第二种写法:Delay 50ms"></p>
<p>可以看到,updateText 方法在第一个 performTraversals 之后就执行了,所以也没有 Delay Load 的效果(虽然宽高是正确显示了,因为在第一个 performTraversals 方法中就执行了layout和measure).</p>
</li>
</ol>
<h2 id="2-3_第三种写法">2.3 第三种写法</h2><p>经过前两个方法 , 我们就会想, 如果能不使用Delay方法, updateText 方法能在 第二个performTraversals 方法执行完成后(即APP第一帧在屏幕上显示),马上就去执行,那么即起到了 Delay Load的作用,又可以正确显示图片的宽高.<br>第三种写法就是这个效果:</p>
<ol>
<li><p>updateText执行的时机?</p>
<p><img src="/images/app-lunch/6.png" alt="第三种写法"></p>
<p>可以看到这种写法. updateText 在第二个 performTraversals 方法执行完成后马上就执行了, 然后下一个 VSYNC 信号来了之后, TextView就更新了.</p>
</li>
<li><p>图片的宽高是否正确显示?<br>当然是正确显示的.如图:<br><img src="/images/app-lunch/7.png" alt="第三种写法"></p>
</li>
<li>是否有 Delay Load 的效果?<br>从 Trace 图上看, 是有 Delay Load的效果的, 而且可以在应用第一帧显示后马上进行数据 Load , 不用考虑 Delay时间的长短.</li>
</ol>
<h1 id="3-_一些思考">3. 一些思考</h1><p>关于优化的 Delay Load 的实现,从代码层面来看其实是非常简单的.其带来的效果也是很赞的.<br>但是实现之后我们还需要思考一下,为何这么做就可以实现这种功能呢?很显然要回答这个问题,我们需要知道更底层的一些东西.这个还涉及到 Handler/Message/MessageQueue/Looper/VSYNC/ViewRootImpl等知识. 往大里说应该还涉及到AMS/WMS等.由于涉及到的东西比较多,我就不在这一篇里面阐述了, 下一篇文章将会从从原理上讲解一下为何优化的 Delay Load 会起作用.</p>
<h1 id="4-_代码">4. 代码</h1><p>本文章所所涉及到的代码我放到了Github上：<br><a href="https://github.com/Gracker/DelayLoadSample" target="_blank" rel="external">https://github.com/Gracker/DelayLoadSample</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0-_应用启动优化概述">0. 应用启动优化概述</h1><p>在 Android 开发中,应用启动速度是一个非常重要的点,应用启动优化也是一个非常重要的过程.对于应用启动优化,其实核心思想就是在启动过程中少做事情,具体实践的时候无非就是下面几种:</p>
<ol>
<li>异步加载</li>
<li>延时加载</li>
<li>懒加载</li>
</ol>
<p>不用一一去解释,做过启动优化的估计都使用过,本篇文章将详细讲解一下一种延时加载的实现以及其原理.<br>其实这种加载的实现是非常简单的,但是其中的原理可能比较复杂,还涉及到Looper/Handler/MessageQueue/VSYNC等.以及其中碰到的一些问题,还会有一些我自己额外的思考.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/tags/Android/"/>
    
      <category term="DelayLoad" scheme="http://androidperformance.com/tags/DelayLoad/"/>
    
      <category term="启动优化" scheme="http://androidperformance.com/tags/%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
      <category term="性能优化" scheme="http://androidperformance.com/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android5.0中 hwui 中 RenderThread 工作流程]]></title>
    <link href="http://androidperformance.com/2015/08/12/AndroidL-hwui-RenderThread-workflow.html"/>
    <id>http://androidperformance.com/2015/08/12/AndroidL-hwui-RenderThread-workflow.html</id>
    <published>2015-08-12T14:38:01.000Z</published>
    <updated>2015-08-12T14:45:31.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本篇文章是自己的一个学习笔记，记录了 Android 5.0 中 hwui 中的 RenderThread 的简单工作流程。由于是学习笔记，所以其中一些细节不会太详细，我只是将大概的流程走一遍，将其工作流标注出来，下次遇到问题的时候就可以知道去哪里查。</p>
<p>下图是我用 Systrace 抓取的一个应用启动的时候 RenderThread 的第一次 Draw 的 Trace 图，从这里面的顺序来看 RenderThread 的流程。熟悉应用启动流程的话应该知道，只有当第一次 DrawFrame 完成之后，整个应用的界面才会显示在手机上，在这之前，用户看到的是应用的 StartingWindow 的界面。</p>
<a id="more"></a>
<p><img src="/images/hwui/renderthread/1.png" alt="RenderThread Draw first frame"></p>
<h2 id="从Java层说起">从Java层说起</h2><p>应用程序的每一帧是从接收到 VSYNC 信号开始进行计算和绘制的,这要从 Choreographer 这个类说起了，不过由于篇幅原因，我们直接看一帧的绘制调用关系链即可：</p>
<p><img src="/images/hwui/renderthread/2.png" alt="绘制关系链"></p>
<p>Choreographer 的 drawFrame 会调用到 ViewRootImpl 的 performTraversals 方法，而 performTraversals 方法最终会调用到performDraw() 方法， performDraw 又会调用到 draw(boolean fullRedrawNeeded) 方法，这个 draw 方法是 ViewRootImpl 的私有方法，和我们熟知的那个draw并不是同一个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (mAttachInfo.mHardwareRenderer != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mHardwareRenderer.isEnabled()) &#123;</span><br><span class="line">                mIsAnimating = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">boolean</span> invalidateRoot = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (mHardwareYOffset != yOffset || mHardwareXOffset != xOffset) &#123;</span><br><span class="line">                    mHardwareYOffset = yOffset;</span><br><span class="line">                    mHardwareXOffset = xOffset;</span><br><span class="line">                    mAttachInfo.mHardwareRenderer.invalidateRoot();</span><br><span class="line">                &#125;</span><br><span class="line">                mResizeAlpha = resizeAlpha;</span><br><span class="line"></span><br><span class="line">                dirty.setEmpty();</span><br><span class="line"></span><br><span class="line">                mBlockResizeBuffer = <span class="keyword">false</span>;</span><br><span class="line">                mAttachInfo.mHardwareRenderer.draw(mView, mAttachInfo, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是走硬件绘制路线的话，则会走这一条先，之后就会调用 mHardwareRenderer 的 draw 方法,这里的 mHardwareRenderer 指的是 ThreadedRenderer ，其 Draw 函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(View view, AttachInfo attachInfo, HardwareDrawCallbacks callbacks)</span> </span>&#123;</span><br><span class="line">    attachInfo.mIgnoreDirtyState = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">long</span> frameTimeNanos = mChoreographer.getFrameTimeNanos();</span><br><span class="line">    attachInfo.mDrawingTime = frameTimeNanos / TimeUtils.NANOS_PER_MS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> recordDuration = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (mProfilingEnabled) &#123;</span><br><span class="line">        recordDuration = System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    updateRootDisplayList(view, callbacks);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mProfilingEnabled) &#123;</span><br><span class="line">        recordDuration = System.nanoTime() - recordDuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    attachInfo.mIgnoreDirtyState = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// register animating rendernodes which started animating prior to renderer</span></span><br><span class="line">    <span class="comment">// creation, which is typical for animators started prior to first draw</span></span><br><span class="line">    <span class="keyword">if</span> (attachInfo.mPendingAnimatingRenderNodes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = attachInfo.mPendingAnimatingRenderNodes.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            registerAnimatingRenderNode(</span><br><span class="line">                    attachInfo.mPendingAnimatingRenderNodes.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        attachInfo.mPendingAnimatingRenderNodes.clear();</span><br><span class="line">        <span class="comment">// We don't need this anymore as subsequent calls to</span></span><br><span class="line">        <span class="comment">// ViewRootImpl#attachRenderNodeAnimator will go directly to us.</span></span><br><span class="line">        attachInfo.mPendingAnimatingRenderNodes = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> syncResult = nSyncAndDrawFrame(mNativeProxy, frameTimeNanos,</span><br><span class="line">            recordDuration, view.getResources().getDisplayMetrics().density);</span><br><span class="line">    <span class="keyword">if</span> ((syncResult &amp; SYNC_INVALIDATE_REQUIRED) != <span class="number">0</span>) &#123;</span><br><span class="line">        attachInfo.mViewRootImpl.invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数里面的 updateRootDisplayList(view, callbacks) ;即 getDisplayList 操作。接下来就是比较重要的一个操作：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int syncResult = nSyncAndDrawFrame<span class="list">(<span class="keyword">mNativeProxy</span>, frameTimeNanos,</span><br><span class="line">        recordDuration, view.getResources<span class="list">()</span>.getDisplayMetrics<span class="list">()</span>.density)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>可以看出这是一个阻塞操作，等Native层完成后，拿到返回值后才会进行下一步的操作。</p>
<h2 id="Native层">Native层</h2><p>其Native代码在android_view_ThreadedRenderer.cpp中，对应的实现代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">android_view_ThreadedRenderer_syncAndDrawFrame</span><span class="params">(JNIEnv* env, jobject clazz,</span><br><span class="line">        jlong proxyPtr, jlong frameTimeNanos, jlong recordDuration, jfloat density)</span> </span>&#123;</span><br><span class="line">    RenderProxy* proxy = <span class="keyword">reinterpret_cast</span>&lt;RenderProxy*&gt;(proxyPtr);</span><br><span class="line">    <span class="keyword">return</span> proxy-&gt;syncAndDrawFrame(frameTimeNanos, recordDuration, density);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RenderProxy的路径位于frameworks/base/libs/hwui/renderthread/RenderProxy.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> RenderProxy::syncAndDrawFrame(<span class="keyword">nsecs_t</span> frameTimeNanos, <span class="keyword">nsecs_t</span> recordDurationNanos,</span><br><span class="line">        <span class="keyword">float</span> density) &#123;</span><br><span class="line">    mDrawFrameTask.setDensity(density);</span><br><span class="line">    <span class="keyword">return</span> mDrawFrameTask.drawFrame(frameTimeNanos, recordDurationNanos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 mDrawFrameTask 是一个 DrawFrameTask 对象，其路径位于frameworks/base/libs/hwui/renderthread/DrawFrameTask.cpp，其中drawFrame代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> DrawFrameTask::drawFrame(<span class="keyword">nsecs_t</span> frameTimeNanos, <span class="keyword">nsecs_t</span> recordDurationNanos) &#123;</span><br><span class="line">    mSyncResult = kSync_OK;</span><br><span class="line">    mFrameTimeNanos = frameTimeNanos;</span><br><span class="line">    mRecordDurationNanos = recordDurationNanos;</span><br><span class="line">    postAndWait();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset the single-frame data</span></span><br><span class="line">    mFrameTimeNanos = <span class="number">0</span>;</span><br><span class="line">    mRecordDurationNanos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mSyncResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 postAndWait() 的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DrawFrameTask::postAndWait() &#123;</span><br><span class="line">    AutoMutex _lock(mLock);</span><br><span class="line">    mRenderThread-&gt;<span class="built_in">queue</span>(<span class="keyword">this</span>);</span><br><span class="line">    mSignal.wait(mLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是将一个 DrawFrameTask 放入到了 mRenderThread 中,其中 queue 方法实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RenderThread::<span class="built_in">queue</span>(RenderTask* task) &#123;</span><br><span class="line">    AutoMutex _lock(mLock);</span><br><span class="line">    mQueue.<span class="built_in">queue</span>(task);</span><br><span class="line">    <span class="keyword">if</span> (mNextWakeup &amp;&amp; task-&gt;mRunAt &lt; mNextWakeup) &#123;</span><br><span class="line">        mNextWakeup = <span class="number">0</span>;</span><br><span class="line">        mLooper-&gt;wake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 mQueue 是一个 TaskQueue 对象，其</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> TaskQueue::queue(RenderTask* <span class="keyword">task</span>) &#123;</span><br><span class="line">    <span class="comment">// Since the RenderTask itself forms the linked list it is not allowed</span></span><br><span class="line">    <span class="comment">// to have the same task queued twice</span></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(<span class="keyword">task</span>-&gt;mNext || mTail == <span class="keyword">task</span>, <span class="string">"Task is already in the queue!"</span>);</span><br><span class="line">    <span class="keyword">if</span> (mTail) &#123;</span><br><span class="line">        <span class="comment">// Fast path if we can just append</span></span><br><span class="line">        <span class="keyword">if</span> (mTail-&gt;mRunAt &lt;= <span class="keyword">task</span>-&gt;mRunAt) &#123;</span><br><span class="line">            mTail-&gt;mNext = <span class="keyword">task</span>;</span><br><span class="line">            mTail = <span class="keyword">task</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Need to find the proper insertion point</span></span><br><span class="line">            RenderTask* <span class="keyword">previous</span> = <span class="number">0</span>;</span><br><span class="line">            RenderTask* <span class="keyword">next</span> = mHead;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">next</span> &amp;&amp; <span class="keyword">next</span>-&gt;mRunAt &lt;= <span class="keyword">task</span>-&gt;mRunAt) &#123;</span><br><span class="line">                <span class="keyword">previous</span> = <span class="keyword">next</span>;</span><br><span class="line">                <span class="keyword">next</span> = <span class="keyword">next</span>-&gt;mNext;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">previous</span>) &#123;</span><br><span class="line">                <span class="keyword">task</span>-&gt;mNext = mHead;</span><br><span class="line">                mHead = <span class="keyword">task</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">previous</span>-&gt;mNext = <span class="keyword">task</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">next</span>) &#123;</span><br><span class="line">                    <span class="keyword">task</span>-&gt;mNext = <span class="keyword">next</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mTail = <span class="keyword">task</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mTail = mHead = <span class="keyword">task</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着看 RenderThread 之前的 queue 方法，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::wake() &#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> nWrite;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        nWrite = write(mWakeWritePipeFd, <span class="string">"W"</span>, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (nWrite == -<span class="number">1</span> &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nWrite != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">            ALOGW(<span class="string">"Could not write wake signal, errno=%d"</span>, errno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>wake 函数则更为简单，仅仅向管道的写端写入一个字符“W”，这样管道的读端就会因为有数据可读而从等待状态中醒来。</p>
<h2 id="HWUI-RenderThread">HWUI-RenderThread</h2><p>接下来会到哪里去，我们首先要熟悉一下RenderThread，RenderThread是继承自Thread的，这个Thread是utils/Thread.h,RenderThread的初始化函数</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RenderThread::RenderThread() : Thread(<span class="keyword">true</span>), Singleton&lt;RenderThread&gt;()</span><br><span class="line">        , mNextWakeup(LLONG_MAX)</span><br><span class="line">        , mDisplayEventReceiver(0)</span><br><span class="line">        , mVsyncRequested(<span class="keyword">false</span>)</span><br><span class="line">        , mFrameCallbackTaskPending(<span class="keyword">false</span>)</span><br><span class="line">        , mFrameCallbackTask(0)</span><br><span class="line">        , mRenderState(NULL)</span><br><span class="line">        , mEglManager(NULL) &#123;</span><br><span class="line">    mFrameCallbackTask = <span class="keyword">new</span> DispatchFrameCallbacks(<span class="keyword">this</span>);</span><br><span class="line">    mLooper = <span class="keyword">new</span> Looper(<span class="keyword">false</span>);</span><br><span class="line">    run(<span class="string">"RenderThread"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其 run 方法在 Thread 中有说明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start the thread in threadLoop() which needs to be implemented.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> status_t    <span class="title">run</span><span class="params">(    <span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="number">0</span>,</span><br><span class="line">                            int32_t priority = PRIORITY_DEFAULT,</span><br><span class="line">                            size_t <span class="built_in">stack</span> = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>即启动 threadLoop 函数，我们来看 RenderThread 的 threadLoop 函数，这个函数比较重要：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> RenderThread::threadLoop() &#123;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(HAVE_PTHREADS)</span></span><br><span class="line">    setpriority(PRIO_PROCESS, <span class="number">0</span>, PRIORITY_DISPLAY);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">    initThreadLocals();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> timeoutMillis = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> result = mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">        LOG_ALWAYS_FATAL_IF(result == Looper::POLL_ERROR,</span><br><span class="line">                <span class="string">"RenderThread Looper POLL_ERROR!"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">nsecs_t</span> nextWakeup;</span><br><span class="line">        <span class="comment">// Process our queue, if we have anything</span></span><br><span class="line">        <span class="keyword">while</span> (RenderTask* task = nextTask(&amp;nextWakeup)) &#123;</span><br><span class="line">            task-&gt;run();</span><br><span class="line">            <span class="comment">// task may have deleted itself, do not reference it again</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nextWakeup == LLONG_MAX) &#123;</span><br><span class="line">            timeoutMillis = -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">nsecs_t</span> timeoutNanos = nextWakeup - systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">            timeoutMillis = nanoseconds_to_milliseconds(timeoutNanos);</span><br><span class="line">            <span class="keyword">if</span> (timeoutMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                timeoutMillis = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mPendingRegistrationFrameCallbacks.size() &amp;&amp; !mFrameCallbackTaskPending) &#123;</span><br><span class="line">            drainDisplayEventQueue(<span class="literal">true</span>);</span><br><span class="line">            mFrameCallbacks.insert(</span><br><span class="line">                    mPendingRegistrationFrameCallbacks.begin(), mPendingRegistrationFrameCallbacks.end());</span><br><span class="line">            mPendingRegistrationFrameCallbacks.clear();</span><br><span class="line">            requestVsync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，一个 for 循环是一个无限循环，而其中 pollOnce 是一个阻塞函数，直到我们上面调用了 mLooper-&gt;wake() 之后，会继续往下走，走到 while 循环中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (RenderTask* task = nextTask(&amp;nextWakeup)) &#123;</span><br><span class="line">            task-&gt;run();</span><br><span class="line">            <span class="comment">// task may have deleted itself, do not reference it again</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>会将 RenderTask 取出来执行其 run 方法，经过前面的流程我们知道这个 RenderTask 是一个 DrawFrameTask ，其run方法如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void DrawFrameTask::run() &#123;</span><br><span class="line">    ATRACE_NAME("DrawFrame");</span><br><span class="line"></span><br><span class="line">    mContext-&gt;profiler().setDensity(mDensity);</span><br><span class="line">    mContext-&gt;profiler().startFrame(mRecordDurationNanos);</span><br><span class="line"></span><br><span class="line">    bool canUnblockUiThread;</span><br><span class="line">    bool canDrawThisFrame;</span><br><span class="line">    &#123;</span><br><span class="line">        TreeInfo info(TreeInfo::MODE_FULL, mRenderThread-&gt;renderState());</span><br><span class="line">        canUnblockUiThread = syncFrameState(info);</span><br><span class="line">        canDrawThisFrame = info.out.canDrawThisFrame;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Grab a copy of everything we need</span><br><span class="line">    CanvasContext* context = mContext;</span><br><span class="line"></span><br><span class="line">    // From this point on anything in "this" is *UNSAFE TO ACCESS*</span><br><span class="line">    if (canUnblockUiThread) &#123;</span><br><span class="line">        unblockUiThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (CC_LIKELY(canDrawThisFrame)) &#123;</span><br><span class="line">        context-&gt;draw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!canUnblockUiThread) &#123;</span><br><span class="line">        unblockUiThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RenderThread-DrawFrame">RenderThread.DrawFrame</h2><p>上面说到了 DrawFrameTask 的 run 方法，这里 run 方法中的执行的方法即我们在最前面那张图中所示的部分（即文章最前面那张图），下面的流程就是那张图中的函数调用，我们结合代码和图，一部分一部分来走整个 DrawFrame 的流程：</p>
<h3 id="1-_syncFrameState">1. syncFrameState</h3><p>第一个比较重要的函数是 syncFrameState ，从函数名就可以知道， syncFrameState 的作用就是同步 frame 信息，将 Java 层维护的 frame 信息同步到 RenderThread中。</p>
<blockquote>
<p>Main Thread 和Render Thread 都各自维护了一份应用程序窗口视图信息。各自维护了一份应用程序窗口视图信息的目的，就是为了可以互不干扰，进而实现最大程度的并行。其中，Render Thread维护的应用程序窗口视图信息是来自于 Main Thread 的。因此，当Main Thread 维护的应用程序窗口信息发生了变化时，就需要同步到 Render Thread 去。</p>
</blockquote>
<p>所以查看代码就可以知道有两个 RenderNode，一个在 hwui 中，一个在 View 中。简单来说，同步信息就是将 Java 层的 RenderNode 中的信息同步到 hwui 中的 RenderNode 中。 注意syncFrameState的返回值赋给了 canUnblockUiThread ，从名字可以看出这个 canUnblockUiThread 的作用是判断是否唤醒 Main Thread ，也就是说如果返回为 true 的话，会提前唤醒主线程来执行其他的事情，而不用等到 draw 完成后再去唤醒 Main Thread。 这也是 Android 5.0 和 Android 4.x 最大的区别了。</p>
<p><img src="/images/hwui/renderthread/3.png" alt="syncFrameState"></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> DrawFrameTask::syncFrameState(TreeInfo&amp; info) &#123;</span><br><span class="line">    mRenderThread-&gt;timeLord().vsyncReceived(mFrameTimeNanos);</span><br><span class="line">    mContext-&gt;makeCurrent();</span><br><span class="line">    Caches::getInstance().textureCache.resetMarkInUse();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; mLayers.size(); i++) &#123;</span><br><span class="line">        mContext-&gt;processLayerUpdate(mLayers[i].get());</span><br><span class="line">    &#125;</span><br><span class="line">    mLayers.clear();</span><br><span class="line">    mContext-&gt;prepareTree(info);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.out.hasAnimations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (info.out.requiresUiRedraw) &#123;</span><br><span class="line">            mSyncResult |= kSync_UIRedrawRequired;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If prepareTextures is false, we ran out of texture cache space</span></span><br><span class="line">    <span class="keyword">return</span> info.prepareTextures;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是makeCurrent，这里的mContext是一个CanvasContext对象，其makeCurrent实现如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CanvasContext::makeCurrent() &#123;</span><br><span class="line">    <span class="comment">// In the meantime this matches the behavior of GLRenderer, so it is not a regression</span></span><br><span class="line">    mHaveNewSurface |= mEglManager.makeCurrent(mEglSurface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mEglManager是一个EglManager对象，其实现为：</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bool EglManager::makeCurrent(EGLSurface <span class="keyword">surface</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isCurrent(<span class="keyword">surface</span>)) <span class="keyword">return</span> false;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">surface</span> == EGL_NO_SURFACE) &#123;</span><br><span class="line">        <span class="comment">// If we are setting EGL_NO_SURFACE we don't care about any of the potential</span></span><br><span class="line">        <span class="comment">// return errors, which would only happen if mEglDisplay had already been</span></span><br><span class="line">        <span class="comment">// destroyed in which case the current context is already NO_CONTEXT</span></span><br><span class="line">        TIME_LOG(<span class="string">"eglMakeCurrent"</span>, eglMakeCurrent(mEglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        EGLBoolean success;</span><br><span class="line">        TIME_LOG(<span class="string">"eglMakeCurrent"</span>, success = eglMakeCurrent(mEglDisplay, <span class="keyword">surface</span>, <span class="keyword">surface</span>, mEglContext));</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            LOG_ALWAYS_FATAL(<span class="string">"Failed to make current on surface %p, error=%s"</span>,</span><br><span class="line">                (void<span class="variable">*)</span><span class="keyword">surface</span>, egl_error_str());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mCurrentSurface = <span class="keyword">surface</span>;</span><br><span class="line">    <span class="keyword">return</span> true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会判断mCurrentSurface == surface，如果成立，则不用再初始化操作，如果是另外一个surface。，则会执行eglMakeCurrent，来重新创建上下文。</p>
<p>makeCurrent之后，会调用mContext-&gt;prepareTree(info)，其实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CanvasContext::prepareTree(TreeInfo&amp; info) &#123;</span><br><span class="line">    mRenderThread.removeFrameCallback(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    info.damageAccumulator = &amp;mDamageAccumulator;</span><br><span class="line">    info.renderer = mCanvas;</span><br><span class="line">    <span class="keyword">if</span> (mPrefetechedLayers.size() &amp;&amp; info.mode == TreeInfo::MODE_FULL) &#123;</span><br><span class="line">        info.canvasContext = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mAnimationContext-&gt;startFrame(info.mode);</span><br><span class="line">    mRootRenderNode-&gt;prepareTree(info);</span><br><span class="line">    mAnimationContext-&gt;runRemainingAnimations(info);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.canvasContext) &#123;</span><br><span class="line">        freePrefetechedLayers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> runningBehind = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> This query is moderately expensive, investigate adding some sort</span></span><br><span class="line">    <span class="comment">// of fast-path based off when we last called eglSwapBuffers() as well as</span></span><br><span class="line">    <span class="comment">// last vsync time. Or something.</span></span><br><span class="line">    TIME_LOG(<span class="string">"nativeWindowQuery"</span>, mNativeWindow-&gt;query(mNativeWindow.get(),</span><br><span class="line">            NATIVE_WINDOW_CONSUMER_RUNNING_BEHIND, &amp;runningBehind));</span><br><span class="line">    info.out.canDrawThisFrame = !runningBehind;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.out.hasAnimations || !info.out.canDrawThisFrame) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!info.out.requiresUiRedraw) &#123;</span><br><span class="line">            <span class="comment">// If animationsNeedsRedraw is set don't bother posting for an RT anim</span></span><br><span class="line">            <span class="comment">// as we will just end up fighting the UI thread.</span></span><br><span class="line">            mRenderThread.postFrameCallback(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 mRootRenderNode-&gt;prepareTree(info) 又是最重要的。回到Java层，我们知道 ThreadedRenderer 在初始化时，初始化了一个指针</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> rootNodePtr = nCreateRootRenderNode();</span><br></pre></td></tr></table></figure>
<p>这个RootRenderNode也就是一个根Node，</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mRootNode = RenderNode.adopt(rootNodePtr)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>然后会创建一个 mNativeProxy 指针，在 Native 层初始化一个 RenderProxy 对象，将 rootNodePtr 传给 RenderProxy 对象，这样在 RenderProxy 我们就可以得到这个对象的指针了。其中 CanvasContext 也是在 RenderProxy 对象初始化的时候被初始化的，初始化的时候将 rootNodePtr 传给了 CanvasContext 对象。</p>
<p>我们之前提到 ThreadedRenderer 的 draw 方法中首先会调用updateRootDisplayList，即我们熟悉的 getDisplayList 。这个方法中，其实也分为两个步骤，第一个步骤是 updateViewTreeDisplayList，第二个步骤是将根 Node 加入到 DrawOp 中：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">canvas</span><span class="class">.insertReorderBarrier</span>();</span><br><span class="line"><span class="tag">canvas</span><span class="class">.drawRenderNode</span>(<span class="tag">view</span><span class="class">.getDisplayList</span>());</span><br><span class="line"><span class="tag">canvas</span><span class="class">.insertInorderBarrier</span>();</span><br></pre></td></tr></table></figure></p>
<p>其最终实现在</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> DisplayListRenderer::drawRenderNode(RenderNode* renderNode, Rect&amp; dirty, <span class="keyword">int32_t</span> flags) &#123;</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(!renderNode, <span class="string">"missing rendernode"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dirty is an out parameter and should not be recorded,</span></span><br><span class="line">    <span class="comment">// it matters only when replaying the display list</span></span><br><span class="line">    DrawRenderNodeOp* op = <span class="keyword">new</span> (alloc()) DrawRenderNodeOp(renderNode, flags, *currentTransform());</span><br><span class="line">    addRenderNodeOp(op);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DrawGlInfo::kStatusDone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再回到我们之前的 CanvasContext.prepareTree 中提到的 mRootRenderNode-&gt;prepareTree(info)，这时候这里的 mRootRenderNode 就是 CanvasContext 初始化是传进来的。</p>
<p>其实现在 RenderNode.cpp 中：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void RenderNode::prepareTree(Tree<span class="number">Inf</span>o&amp; <span class="number">inf</span>o) &#123;</span><br><span class="line">    prepareTreeImpl(<span class="number">inf</span>o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void RenderNode::prepareTreeImpl(Tree<span class="number">Inf</span>o&amp; <span class="number">inf</span>o) &#123;</span><br><span class="line">    TT_START_MARK(getName());</span><br><span class="line">    <span class="number">inf</span>o.damageAccumulator-&gt;pushTransform(this);</span><br><span class="line"></span><br><span class="line">    if (<span class="number">inf</span>o.mode == Tree<span class="number">Inf</span>o::MODE_FULL) &#123;</span><br><span class="line">        pushStagingPropertiesChanges(<span class="number">inf</span>o); //同步当前正在处理的Render <span class="keyword">Node</span><span class="identifier"></span><span class="title">的Property</span></span><br><span class="line">    &#125;</span><br><span class="line">    uint32_t animatorDirtyMask = <span class="number">0</span>;</span><br><span class="line">    if (CC_LIKELY(<span class="number">inf</span>o.runAnimations)) &#123;</span><br><span class="line">        animatorDirtyMask = mAnimatorManager.animate(<span class="number">inf</span>o);//执行动画相关的操作</span><br><span class="line">    &#125;</span><br><span class="line">    prepareLayer(<span class="number">inf</span>o, animatorDirtyMask);</span><br><span class="line">    if (<span class="number">inf</span>o.mode == Tree<span class="number">Inf</span>o::MODE_FULL) &#123;</span><br><span class="line">        pushStagingDisplayListChanges(<span class="number">inf</span>o);  //同步当前正在处理的Render <span class="keyword">Node</span><span class="identifier"></span><span class="title">的Display</span> List</span><br><span class="line">    &#125;</span><br><span class="line">    prepareSubTree(<span class="number">inf</span>o, mDisplayListData); //同步当前正在处理的Render <span class="keyword">Node</span><span class="identifier"></span><span class="title">的Display</span> List引用的Bitmap，以及当前正在处理的Render <span class="keyword">Node</span><span class="identifier"></span><span class="title">的子Render</span> <span class="keyword">Node</span><span class="identifier"></span><span class="title">的Display</span> List等信息</span><br><span class="line">    pushLayerUpdate(<span class="number">inf</span>o); //检查当前正在处理的Render <span class="keyword">Node</span><span class="identifier"></span><span class="title">是否设置了Layer</span>。如果设置了的话，就对这些Layer进行处理</span><br><span class="line"></span><br><span class="line">    <span class="number">inf</span>o.damageAccumulator-&gt;popTransform();</span><br><span class="line">    TT_END_MARK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里所涉及到的进一步的具体操作大家可以自行去看代码。</p>
<h2 id="2-_draw">2. draw</h2><p><img src="/images/hwui/renderthread/4.png" alt="Draw"></p>
<p>执行完syncFrameState之后，接下来就是执行draw</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span> <span class="params">(<span class="variable">CC_LIKELY</span>(can<span class="variable">DrawThisFrame</span>)</span>) &#123;</span><br><span class="line">    <span class="title">context</span>-&gt;</span><span class="function_name">draw</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CanvasContext的draw函数是一个核心函数，其位置在 frameworks/base/libs/hwui/OpenGLRenderer.cpp ，其实现如下：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> CanvasContext<span class="tag">::draw</span>() &#123;</span><br><span class="line">    profiler()<span class="built_in">.</span>markPlaybackStart();</span><br><span class="line"></span><br><span class="line">    SkRect dirty;</span><br><span class="line">    mDamageAccumulat<span class="subst">or</span><span class="built_in">.</span>finish(<span class="subst">&amp;</span>dirty);</span><br><span class="line"></span><br><span class="line">    <span class="attribute">...</span><span class="attribute">...</span></span><br><span class="line"></span><br><span class="line">    status_t status;</span><br><span class="line">    <span class="keyword">if</span> (<span class="subst">!</span>dirty<span class="built_in">.</span>isEmpty()) &#123;</span><br><span class="line">        status = mCanvas<span class="subst">-&gt;</span>prepareDirty(dirty<span class="built_in">.</span>fLeft, dirty<span class="built_in">.</span>fTop,</span><br><span class="line">                dirty<span class="built_in">.</span>fRight, dirty<span class="built_in">.</span>fBottom, mOpaque);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        status = mCanvas<span class="subst">-&gt;</span>prepare(mOpaque);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Rect outBounds;</span><br><span class="line">    status |= mCanvas<span class="subst">-&gt;</span>drawRenderNode(mRootRenderNode<span class="built_in">.</span>get(), outBounds);</span><br><span class="line"></span><br><span class="line">    profiler()<span class="built_in">.</span>draw(mCanvas);</span><br><span class="line"></span><br><span class="line">    mCanvas<span class="subst">-&gt;</span>finish();</span><br><span class="line"></span><br><span class="line">    profiler()<span class="built_in">.</span>markPlaybackEnd();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status <span class="subst">&amp;</span> DrawGlInfo<span class="tag">::kStatusDrew</span>) &#123;</span><br><span class="line">        swapBuffers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    profiler()<span class="built_in">.</span>finishFrame();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// M: enable to get overdraw count</span></span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(g_HWUI_debug_overdraw)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="subst">!</span>mDebugOverdrawLayer) &#123;</span><br><span class="line">            mDebugOverdrawLayer = LayerRenderer<span class="tag">::createRenderLayer</span>(mRenderThread<span class="built_in">.</span>renderState(),</span><br><span class="line">                mCanvas<span class="subst">-&gt;</span>getWidth(), mCanvas<span class="subst">-&gt;</span>getHeight());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mDebugOverdrawLayer<span class="subst">-&gt;</span>layer<span class="built_in">.</span>getWidth() != mCanvas<span class="subst">-&gt;</span>getWidth() <span class="subst">||</span></span><br><span class="line">                   mDebugOverdrawLayer<span class="subst">-&gt;</span>layer<span class="built_in">.</span>getHeight() != mCanvas<span class="subst">-&gt;</span>getHeight()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="subst">!</span>LayerRenderer<span class="tag">::resizeLayer</span>(mDebugOverdrawLayer, mCanvas<span class="subst">-&gt;</span>getWidth(), mCanvas<span class="subst">-&gt;</span>getHeight())) &#123;</span><br><span class="line">                LayerRenderer<span class="tag">::destroyLayer</span>(mDebugOverdrawLayer);</span><br><span class="line">                mDebugOverdrawLayer = <span class="built_in">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">...</span><span class="attribute">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1_eglBeginFrame">2.1 eglBeginFrame</h4><p>首先来看eglBeginFrame的实现</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void EglManager<span class="value">::<span class="function">beginFrame</span>(EGLSurface surface, EGLint* width, EGLint* height) &#123;</span><br><span class="line">    <span class="function">makeCurrent</span>(surface);</span></span><br><span class="line">    if (<span class="attribute">width</span>) &#123;</span><br><span class="line">        <span class="function">eglQuerySurface</span>(mEglDisplay, surface, EGL_WIDTH, <span class="attribute">width</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    if (<span class="attribute">height</span>) &#123;</span><br><span class="line">        <span class="function">eglQuerySurface</span>(mEglDisplay, surface, EGL_HEIGHT, <span class="attribute">height</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">eglBeginFrame</span>(mEglDisplay, surface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>makeCurrent是用来管理上下文，eglBeginFrame主要是校验参数的合法性。</p>
<h4 id="2-2_prepareDirty">2.2 prepareDirty</h4><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">status_t <span class="keyword">status</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="comment">!dirty.isEmpty()) &#123;</span></span><br><span class="line">    <span class="keyword">status</span> = mCanvas-&gt;prepareDirty(dirty.fLeft, dirty.fTop,</span><br><span class="line">            dirty.fRight, dirty.fBottom, mOpaque);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">status</span> = mCanvas-&gt;prepare(mOpaque);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的mCanvas是一个OpenGLRenderer对象，其prepareDirty实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span>增加函数功能描述</span></span><br><span class="line"><span class="keyword">status_t</span> OpenGLRenderer::prepareDirty(<span class="keyword">float</span> left, <span class="keyword">float</span> top,</span><br><span class="line">        <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">bool</span> opaque) &#123;</span><br><span class="line">    setupFrameState(left, top, right, bottom, opaque);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Layer renderers will start the frame immediately</span></span><br><span class="line">    <span class="comment">// The framebuffer renderer will first defer the display list</span></span><br><span class="line">    <span class="comment">// for each layer and wait until the first drawing command</span></span><br><span class="line">    <span class="comment">// to start the frame</span></span><br><span class="line">    <span class="keyword">if</span> (currentSnapshot()-&gt;fbo == <span class="number">0</span>) &#123;</span><br><span class="line">        syncState();</span><br><span class="line">        updateLayers();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> startFrame();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DrawGlInfo::kStatusDone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3_drawRenderNode">2.3 drawRenderNode</h4><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rect outBounds<span class="comment">;</span></span><br><span class="line">status |= mCanvas-&gt;drawRenderNode(mRootRenderNode.get(), outBounds)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>接下来就是调用OpenGLRenderer的drawRenderNode方法进行绘制</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">status_t OpenGLRenderer::drawRenderNode(RenderNode* renderNode, Rect&amp; dirty, int32_t replayFlags) &#123;</span><br><span class="line">    status_t status;</span><br><span class="line">    <span class="comment">// All the usual checks and setup operations (quickReject, setupDraw, etc.)</span></span><br><span class="line">    <span class="comment">// will be performed by the display list itself</span></span><br><span class="line">    <span class="keyword">if</span> (renderNode &amp;&amp; renderNode-&gt;isRenderable()) &#123;</span><br><span class="line">        <span class="comment">// compute 3d ordering</span></span><br><span class="line">        renderNode-&gt;computeOrdering();</span><br><span class="line">        <span class="keyword">if</span> (CC_UNLIKELY(mCaches.drawDeferDisabled)) &#123; <span class="comment">//判断是否不重排序</span></span><br><span class="line">            status = startFrame();</span><br><span class="line">            <span class="function">ReplayStateStruct <span class="title">replayStruct</span><span class="params">(*<span class="keyword">this</span>, dirty, replayFlags)</span></span>;</span><br><span class="line">            renderNode-&gt;replay(replayStruct, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> status | replayStruct.mDrawGlStatus;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要重新排序</span></span><br><span class="line">        bool avoidOverdraw = !mCaches.debugOverdraw &amp;&amp; !mCountOverdraw; <span class="comment">// shh, don't tell devs!</span></span><br><span class="line">        DeferredDisplayList deferredList(*currentClipRect(), avoidOverdraw);</span><br><span class="line">        <span class="function">DeferStateStruct <span class="title">deferStruct</span><span class="params">(deferredList, *<span class="keyword">this</span>, replayFlags)</span></span>;</span><br><span class="line">        renderNode-&gt;defer(deferStruct, <span class="number">0</span>); <span class="comment">//递归进行重排操作</span></span><br><span class="line"></span><br><span class="line">        flushLayers(); <span class="comment">// 首先执行设置了 Layer 的子 Render Node 的绘制命令，以便得到一个对应的FBO</span></span><br><span class="line">        status = startFrame(); <span class="comment">//执行一些诸如清理颜色绘冲区等基本操作</span></span><br><span class="line">        status = deferredList.flush(*<span class="keyword">this</span>, dirty) | status;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Even if there is no drawing command(Ex: invisible),</span></span><br><span class="line">    <span class="comment">// it still needs startFrame to clear buffer and start tiling.</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">startFrame</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 renderNode 是一个 Root Render Node，</p>
<p>可以看到，到了这里虽然只是开始，但是其实已经结束了，这个函数里面最重要的几步:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">renderNode-&gt;defer(deferStruct, <span class="number">0</span>); <span class="comment">//进行重排序</span></span><br><span class="line"></span><br><span class="line">flushLayers(); 首先执行设置了 Layer 的子 Render Node 的绘制命令，以便得到一个对应的FBO</span><br><span class="line"></span><br><span class="line">status = deferredList.flush(*<span class="keyword">this</span>, dirty) | status;   <span class="comment">//对deferredList中的绘制命令进行真正的绘制操作</span></span><br></pre></td></tr></table></figure>
<p>这几个是渲染部分真正的核心部分，其中的代码细节需要自己去研究。老罗在这部分讲的很细，有空可以去看看他的文章<a href="http://blog.csdn.net/Luoshengyang/article/details/46281499" target="_blank" rel="external"><a href="http://blog.csdn.net/luoshengyang/article/details/46281499" target="_blank" rel="external">Android应用程序UI硬件加速渲染的Display List渲染过程分析</a></a>.</p>
<h4 id="2-4_swapBuffers">2.4 swapBuffers</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(status &amp; DrawGlInfo::kStatusDrew)</span> &#123;</span><br><span class="line">    swapBuffers<span class="comment">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其核心就是调用EGL的 eglSwapBuffers(mEglDisplay, surface), duration)函数。</p>
<h4 id="2-5_FinishFrame">2.5  FinishFrame</h4><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">profiler<span class="literal">()</span>.finishFrame<span class="literal">()</span>;</span><br></pre></td></tr></table></figure>
<p>主要是记录时间信息。</p>
<h2 id="总结">总结</h2><p>鉴于我比较懒，而且总结能力不如老罗，就直接把他的总结贴过来了。<br>RenderThread的总的流程如下：</p>
<blockquote>
<ol>
<li><p>将Main Thread维护的Display List同步到Render Thread维护的Display List去。这个同步过程由Render Thread执行，但是Main Thread会被阻塞住。</p>
</li>
<li><p>如果能够完全地将Main Thread维护的Display List同步到Render Thread维护的Display List去，那么Main Thread就会被唤醒，此后Main Thread和Render Thread就互不干扰，各自操作各自内部维护的Display List；否则的话，Main Thread就会继续阻塞，直到Render Thread完成应用程序窗口当前帧的渲染为止。</p>
</li>
<li><p>Render Thread在渲染应用程序窗口的Root Render Node的Display List之前，首先将那些设置了Layer的子Render Node的Display List渲染在各自的一个FBO上，接下来再一起将这些FBO以及那些没有设置Layer的子Render Node的Display List一起渲染在Frame Buffer之上，也就是渲染在从Surface Flinger请求回来的一个图形缓冲区上。这个图形缓冲区最终会被提交给Surface Flinger合并以及显示在屏幕上。</p>
</li>
</ol>
<p>第2步能够完全将Main Thread维护的Display List同步到Render Thread维护的Display List去很关键，它使得Main Thread和Render Thread可以并行执行，这意味着Render Thread在渲染应用程序窗口当前帧的Display List的同时，Main Thread可以去准备应用程序窗口下一帧的Display List，这样就使得应用程序窗口的UI更流畅。</p>
</blockquote>
<p>注意最后一段，在 Android 4.x 时代，没有RenderThread的时代，只有 Main Thread ，也就是说 必须要等到 Draw 完成后，才会去准备下一帧的数据，如下图：</p>
<p><img src="/images/hwui/renderthread/5.png" alt="Paste_Image.png"></p>
<p>Android5.0 之后，如老罗所说，有两种情况，</p>
<p><img src="/images/hwui/renderthread/6.png" alt="Main Thread 和 Render Thread"></p>
<p><img src="/images/hwui/renderthread/7.png" alt="Render Thread 提前唤醒了 Main Thread"></p>
<p>可以看到第二张图中，Render Thread 并没有绘制完成，但是由于其提前唤醒了 Main Thread ，所以 Main Thread 在下一个Vsync信号到来的时候，响应了Vsync事件，开始准备下一帧。<br>此时虽然由于第一帧绘制时间过长，导致掉了一帧，但是第二帧没有收到任何影响。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本篇文章是自己的一个学习笔记，记录了 Android 5.0 中 hwui 中的 RenderThread 的简单工作流程。由于是学习笔记，所以其中一些细节不会太详细，我只是将大概的流程走一遍，将其工作流标注出来，下次遇到问题的时候就可以知道去哪里查。</p>
<p>下图是我用 Systrace 抓取的一个应用启动的时候 RenderThread 的第一次 Draw 的 Trace 图，从这里面的顺序来看 RenderThread 的流程。熟悉应用启动流程的话应该知道，只有当第一次 DrawFrame 完成之后，整个应用的界面才会显示在手机上，在这之前，用户看到的是应用的 StartingWindow 的界面。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/tags/Android/"/>
    
      <category term="Menory" scheme="http://androidperformance.com/tags/Menory/"/>
    
      <category term="RenderThread" scheme="http://androidperformance.com/tags/RenderThread/"/>
    
      <category term="hwui" scheme="http://androidperformance.com/tags/hwui/"/>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
      <category term="View" scheme="http://androidperformance.com/categories/Android/View/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HashMap源码分析]]></title>
    <link href="http://androidperformance.com/2015/08/05/HashMap.html"/>
    <id>http://androidperformance.com/2015/08/05/HashMap.html</id>
    <published>2015-08-05T12:27:13.000Z</published>
    <updated>2015-12-17T07:33:08.000Z</updated>
    <content type="html"><![CDATA[<p>链表和数组可以按照人们意愿排列元素的次序，但是，如果想要查看某个指定的元素，却又忘记了它的位置，就需要访问所有的元素，直到找到为止。如果集合中元素很多，将会消耗很多时间。有一种数据结构可以快速查找所需要查找的对象，这个就是哈希表（hash table）.</p>
<p>HashMap是基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
<a id="more"></a>
<h3 id="1-_HashMap的数据结构：">1. HashMap的数据结构：</h3><p>HashMap使用数组和链表来共同组成的。可以看出底层是一个数组，而数组的每个元素都是一个链表头。</p>
<p><img src="/images/hashMapSourceAnalysis/hs.20150729.01.jpg" alt="enter image description here"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line">        <span class="keyword">int</span> hash;</span><br><span class="line">        ...</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>Entry是HashMap中的一个内部静态类，包级私有，实现了Map中的接口Entey<k,v>。可以看出来它内部含有一个指向下一个元素的指针。</k,v></p>
<h3 id="2-构造函数">2.构造函数</h3><p>HashMap的构造函数有四个：</p>
<ol>
<li>HashMap() — 构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。 </li>
<li>HashMap(int initialCapacity)  — 构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。 </li>
<li>HashMap(int initialCapacity, float loadFactor) — 构造一个带指定初始容量和加载因子的空 HashMap。 </li>
<li>HashMap(Map&lt;? extends K,? extends V&gt; m) — 构造一个映射关系与指定 Map 相同的新 HashMap</li>
</ol>
<p>实际上就两种，一个是指定初始容量和加载因子，一个是用一个给定的映射关系生成一个新的HashMap。说一下第一种。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * Constructs an empty &lt;tt&gt;HashMap &lt;/tt&gt; with the specified initial</span><br><span class="line">    * capacity and load factor.</span><br><span class="line">    *</span><br><span class="line">    * <span class="doctag">@param</span>  initialCapacity the initial capacity</span><br><span class="line">    * <span class="doctag">@param</span>  loadFactor      the load factor</span><br><span class="line">    * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span><br><span class="line">    *         or the load factor is nonpositive</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">( <span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException( <span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float. isNaN(loadFactor))</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException( <span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                              loadFactor);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Find a power of 2 &gt;= initialCapacity</span></span><br><span class="line">       <span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (capacity &lt; initialCapacity)</span><br><span class="line">           capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">       threshold = (<span class="keyword">int</span>)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">       table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">       useAltHashing = sun.misc.VM. isBooted() &amp;&amp;</span><br><span class="line">               (capacity &gt;= Holder. ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">       init();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>参数很简单，初始容量，和加载因子。初始容量定义了初识数组的大小，加载因子和初始容量的乘积确定了一个阈值。阈值最大是(1&lt;&lt;30) + 1。初始容量一定是2的N次方，而且刚刚比要设置的值大。默认初始容量是16，默认加载因子是0.75。当表中的元素数量大于等于阈值时，数组的容量会翻倍，并重新插入元素到新的数组中，所以HashMap不保证顺序恒久不变。</p>
<p>当输入的加载因子小于零或者不是浮点数时会抛出异常（IllegalArgumentException）。</p>
<h3 id="3-put操作">3.put操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * Associates the specified value with the specified key in this map.</span><br><span class="line">    * If the map previously contained a mapping for the key, the old</span><br><span class="line">    * value is replaced.</span><br><span class="line">    *</span><br><span class="line">    * <span class="doctag">@param</span> key key with which the specified value is to be associated</span><br><span class="line">    * <span class="doctag">@param</span> value value to be associated with the specified key</span><br><span class="line">    * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key &lt;/tt&gt;, or</span><br><span class="line">    *         &lt;tt&gt;null &lt;/tt&gt; if there was no mapping for &lt;tt&gt; key&lt;/tt&gt; .</span><br><span class="line">    *         (A &lt;tt&gt;null &lt;/tt&gt; return can also indicate that the map</span><br><span class="line">    *         previously associated &lt;tt&gt;null &lt;/tt&gt; with &lt;tt&gt; key&lt;/tt&gt; .)</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">       <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">       <span class="keyword">int</span> i = indexFor(hash, table .length );</span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e. next) &#123;</span><br><span class="line">           Object k;</span><br><span class="line">           <span class="keyword">if</span> (e. hash == hash &amp;&amp; ((k = e. key) == key || key.equals(k))) &#123;</span><br><span class="line">               V oldValue = e. value;</span><br><span class="line">               e. value = value;</span><br><span class="line">               e.recordAccess( <span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line">       addEntry(hash, key, value, i);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>由于HashMap只是key值为null，所以首先要判断key值是不是为null，是则进行特殊处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * Offloaded version of put for null keys</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e. next) &#123;</span><br><span class="line">           <span class="keyword">if</span> (e. key == <span class="keyword">null</span>) &#123;</span><br><span class="line">               V oldValue = e. value;</span><br><span class="line">               e. value = value;</span><br><span class="line">               e.recordAccess( <span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       modCount++;</span><br><span class="line">       addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出key值为null则会插入到数组的第一个位置。如果第一个位置存在，则替代，不存在则添加一个新的。稍后会看到addEntry函数。</p>
<p><strong> PS：考虑一个问题，key值为null会插入到table[0]，那为什么还要遍历整个链表呢？</strong></p>
<p>回到put函数中。在判断key不为null后，会求key的hash值，并通过indexFor函数找出这个key应该存在table中的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">    * Returns index for hash code h.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span> <span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>indexFor函数很简短，但是却实现的很巧妙。一般来说我们把一个数映射到一个固定的长度会用取余（%）运算，也就是h % length，但里巧妙地运用了table.length的特性。还记得前面说了数组的容量都是很特殊的数，是2的N次方。用二进制表示也就是一个1后面N个0，（length-1）就是N个1了。这里直接用与运算，运算速度快，效率高。但是这是是利用了length的特殊性，如果length不是2的N次方的话可能会增加冲突。</p>
<p>前面的问题在这里就有答案了。因为indexFor函数返回值的范围是0到（length-1），所以可能会有key值不是null的Entry存到table[0]中，所以前面还是需要遍历链表的。</p>
<p>得到key值对应在table中的位置，就可以对链表进行遍历，如果存在该key则，替换value，并把旧的value返回，modCount++代表操作数加1。这个属性用于Fail-Fast机制，后面讲到。如果遍历链表后发现key不存在，则要插入一个新的Entry到链表中。这时就会调用addEntry函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Adds a new entry with the specified key, value and hash code to</span><br><span class="line"> * the specified bucket.  It is the responsibility of this</span><br><span class="line"> * method to resize the table if appropriate.</span><br><span class="line"> *</span><br><span class="line"> * Subclass overrides this to alter the behavior of put method.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span> <span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; ( <span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table. length);</span><br><span class="line">        hash = ( <span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数有四个参数，第一个是key的hash值，第二个第三个分别是key和value，最后一个是这个key在table中的位置，也就是indexFor(hash(key), table.length-1)。首先会判断size（当前表中的元素个数）是不是大于或等于阈值。并且判断数组这个位置是不是空。如果条件满足则要resize(2 * table. length)，等下我们来看这个操作。超过阈值要resize是为了减少冲突，提高访问效率。判断当前位置不是空时才resize是为了尽可能减少resize次数，因为这个位置是空，放一个元素在这也没有冲突，所以不影响效率，就先不进行resize了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Rehashes the contents of this map into a new array with a</span><br><span class="line"> * larger capacity.  This method is called automatically when the</span><br><span class="line"> * number of keys in this map reaches its threshold.</span><br><span class="line"> *</span><br><span class="line"> * If current capacity is MAXIMUM_CAPACITY, this method does not</span><br><span class="line"> * resize the map, but sets threshold to Integer.MAX_VALUE.</span><br><span class="line"> * This has the effect of preventing future calls.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> newCapacity the new capacity, MUST be a power of two;</span><br><span class="line"> *        must be greater than current capacity unless current</span><br><span class="line"> *        capacity is MAXIMUM_CAPACITY (in which case value</span><br><span class="line"> *        is irrelevant).</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable. length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer. MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="keyword">boolean</span> oldAltHashing = useAltHashing;</span><br><span class="line">    useAltHashing |= sun.misc.VM. isBooted() &amp;&amp;</span><br><span class="line">            (newCapacity &gt;= Holder. ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">    <span class="keyword">boolean</span> rehash = oldAltHashing ^ useAltHashing;</span><br><span class="line">    transfer(newTable, rehash);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor , MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>resize操作先要判断当前table的长度是不是已经等于最大容量（1&lt;&lt;30）了，如果是则把阈值调到整数的最大值（(1&lt;&lt;31) - 1），就没有再拓展table的必要了。如果没有到达最大容量，就要生成一个新的空数组，长度是原来的两倍。这时候可能要问了，如果oldTable. length不等于MAXIMUM_CAPACITY，但是（2 * oldTable. length）也就是newCapacity大于MAXIMUM_CAPACITY怎么办？这个是不可能的，因为数组长度是2的N次方，而MAXIMUM_CAPACITY = 1&lt;&lt;30。<br>生成新的数组后要执行transfer函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Transfers all entries from current table to newTable.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable. length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>( <span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e. next;</span><br><span class="line">            <span class="keyword">if</span> ( rehash) &#123;</span><br><span class="line">                e. hash = <span class="keyword">null</span> == e. key ? <span class="number">0</span> : hash(e. key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e. next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数要做的就是把原来table中的值挨个拿出来插到新数组中，由于数组长度发生了改变，所以元素的位置肯定发生变化，所以HashMap不能保证该顺序恒久不变。回到resize函数，这时新的数组已经生成了，只需要替换原来数组就好了。并且要更新一下阈值。可以看出来resize是个比较消耗资源的函数，所以能减少resize的次数就尽量减少。</p>
<p>回到函数addEntry 中，判断完是不是需要resize后就需要创建一个新的Entry了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Like addEntry except that this version is used when creating entries</span><br><span class="line"> * as part of Map construction or "pseudo -construction" (cloning,</span><br><span class="line"> * deserialization).  This version needn't worry about resizing the table.</span><br><span class="line"> *</span><br><span class="line"> * Subclass overrides this to alter the behavior of HashMap(Map),</span><br><span class="line"> * clone, and readObject.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">( <span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用createEntry函数，参数跟addEntry一样，第一个是key的hash值，第二个第三个分别是key和value，最后一个是这个key在table中的位置。这里的操作与Entry的构造函数有关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Creates new entry.</span><br><span class="line"> */</span></span><br><span class="line">Entry (<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">    value = v;</span><br><span class="line">    next = n;</span><br><span class="line">    key = k;</span><br><span class="line">    hash = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数中传入一个Entry对象，并把它当做这个新生成的Entry的next。所以createEntry函数中的操作相当于把table[bucketIndex]上的链表拿下来，放在新的Entry后面，然后再把新的Entry放到table[bucketIndex]上。</p>
<p><img src="/images/hashMapSourceAnalysis/hs.20150729.02.jpg" alt="enter image description here"></p>
<p>到这里整个put函数算是结束了。如果新插入的K，V则会返回null。</p>
<h3 id="4-get操作">4.get操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Returns the value to which the specified key is mapped,</span><br><span class="line"> * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;More formally, if this map contains a mapping from a key</span><br><span class="line"> * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span><br><span class="line"> * key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span><br><span class="line"> * it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily &lt;/i&gt;</span><br><span class="line"> * indicate that the map contains no mapping for the key; it's also</span><br><span class="line"> * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span><br><span class="line"> * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span><br><span class="line"> * distinguish these two cases.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@see</span> #put(Object, Object)</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也是先判断key是不是null，做特殊处理。直接上代码，不赘述。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Offloaded version of get() to look up null keys.  Null keys map</span><br><span class="line"> * to index 0.  This null case is split out into separate methods</span><br><span class="line"> * for the sake of performance in the two most commonly used</span><br><span class="line"> * operations (get and put), but incorporated with conditionals in</span><br><span class="line"> * others.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">getForNullKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e. next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e. key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> e. value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>key不是null则会调用getEntry函数，并返回一个Entry对象，如果不是null，就返回entry的value。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Returns the entry associated with the specified key in the</span><br><span class="line"> * HashMap.  Returns null if the HashMap contains no mapping</span><br><span class="line"> * for the key.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[ indexFor(hash, table.length)];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = e. next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e. hash == hash &amp;&amp;</span><br><span class="line">            ((k = e. key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接求key值hash值，然后求table中的位置，遍历链表。有返回entry对象，没有返回null。</p>
<h3 id="5-_Fail-Fast机制">5. Fail-Fast机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * The number of times this HashMap has been structurally modified</span><br><span class="line"> * Structural modifications are those that change the number of mappings in</span><br><span class="line"> * the HashMap or otherwise modify its internal structure (e.g.,</span><br><span class="line"> * rehash).  This field is used to make iterators on Collection-views of</span><br><span class="line"> * the HashMap fail -fast.  (See ConcurrentModificationException).</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure>
<p>我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。</p>
<p>这一策略在源码中的实现是通过modCount域，保证线程之间修改的可见性。，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。</p>
<p><strong>注意</strong>，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。</p>
<h3 id="参考">参考</h3><ul>
<li>《Core JAVA》</li>
<li>《JAVA API》</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>链表和数组可以按照人们意愿排列元素的次序，但是，如果想要查看某个指定的元素，却又忘记了它的位置，就需要访问所有的元素，直到找到为止。如果集合中元素很多，将会消耗很多时间。有一种数据结构可以快速查找所需要查找的对象，这个就是哈希表（hash table）.</p>
<p>HashMap是基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>]]>
    
    </summary>
    
      <category term="HashMap" scheme="http://androidperformance.com/tags/HashMap/"/>
    
      <category term="Java" scheme="http://androidperformance.com/tags/Java/"/>
    
      <category term="Java" scheme="http://androidperformance.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android代码内存优化建议-OnTrimMemory优化]]></title>
    <link href="http://androidperformance.com/2015/07/20/Android-Performance-Memory-onTrimMemory.html"/>
    <id>http://androidperformance.com/2015/07/20/Android-Performance-Memory-onTrimMemory.html</id>
    <published>2015-07-20T04:42:10.000Z</published>
    <updated>2015-07-20T04:49:37.000Z</updated>
    <content type="html"><![CDATA[<p>OnTrimMemory 回调是 Android 4.0 之后提供的一个API，这个 API 是提供给开发者的，它的主要作用是提示开发者在系统内存不足的时候，通过处理部分资源来释放内存，从而避免被 Android 系统杀死。这样应用在下一次启动的时候，速度就会比较快。</p>
<p>本文通过问答的方式，从各个方面来讲解 OnTrimMemory 回调的使用过程和效果。想要开发高性能且用户体验良好的 Android 应用，那么这篇文章你不应该错过。</p>
<a id="more"></a>
<h2 id="0-_OnTrimMemory回调的作用？">0. OnTrimMemory回调的作用？</h2><p>OnTrimMemory是Android在4.0之后加入的一个回调，任何实现了ComponentCallbacks2接口的类都可以重写实现这个回调方法．OnTrimMemory的主要作用就是<strong>指导应用程序在不同的情况下进行自身的内存释放，以避免被系统直接杀掉，提高应用程序的用户体验.</strong></p>
<p>Android系统会根据不同等级的内存使用情况，调用这个函数，并传入对应的等级：</p>
<ul>
<li>TRIM_MEMORY_UI_HIDDEN 表示应用程序的<strong>所有UI界面</strong>被隐藏了，即用户点击了Home键或者Back键导致应用的UI界面不可见．这时候应该释放一些资源．<br>TRIM_MEMORY_UI_HIDDEN这个等级比较常用，和下面六个的关系不是很强，所以单独说．</li>
</ul>
<p>下面三个等级是当我们的应用程序真正运行时的回调：</p>
<ul>
<li>TRIM_MEMORY_RUNNING_MODERATE    表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经有点低了，系统可能会开始根据LRU缓存规则来去杀死进程了。</li>
<li>TRIM_MEMORY_RUNNING_LOW    表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经非常低了，我们应该去释放掉一些不必要的资源以提升系统的性能，同时这也会直接影响到我们应用程序的性能。</li>
<li>TRIM_MEMORY_RUNNING_CRITICAL    表示应用程序仍然正常运行，但是系统已经根据LRU缓存规则杀掉了大部分缓存的进程了。这个时候我们应当尽可能地去释放任何不必要的资源，不然的话系统可能会继续杀掉所有缓存中的进程，并且开始杀掉一些本来应当保持运行的进程，比如说后台运行的服务。</li>
</ul>
<p>当应用程序是缓存的，则会收到以下几种类型的回调：</p>
<ul>
<li>TRIM_MEMORY_BACKGROUND    表示手机目前内存已经很低了，系统准备开始根据LRU缓存来清理进程。这个时候我们的程序在LRU缓存列表的最近位置，是不太可能被清理掉的，但这时去释放掉一些比较容易恢复的资源能够让手机的内存变得比较充足，从而让我们的程序更长时间地保留在缓存当中，这样当用户返回我们的程序时会感觉非常顺畅，而不是经历了一次重新启动的过程。</li>
<li>TRIM_MEMORY_MODERATE    表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的中间位置，如果手机内存还得不到进一步释放的话，那么我们的程序就有被系统杀掉的风险了。</li>
<li>TRIM_MEMORY_COMPLETE    表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的最边缘位置，系统会最优先考虑杀掉我们的应用程序，在这个时候应当尽可能地把一切可以释放的东西都进行释放。</li>
</ul>
<h2 id="1-_哪些组件可以实现OnTrimMemory回调？">1. 哪些组件可以实现OnTrimMemory回调？</h2><ul>
<li>Application.onTrimMemory()</li>
<li>Activity.onTrimMemory()</li>
<li>Fragement.OnTrimMemory()</li>
<li>Service.onTrimMemory()</li>
<li>ContentProvider.OnTrimMemory()</li>
</ul>
<h2 id="2-_OnTrimMemory回调中可以释放哪些资源？">2. OnTrimMemory回调中可以释放哪些资源？</h2><p>通常在架构阶段就要考虑清楚，我们有哪些东西是要常驻内存的，有哪些是伴随界面存在的．一般情况下，有下面几种资源需要进行释放：</p>
<ul>
<li>缓存  缓存包括一些文件缓存，图片缓存等，在用户正常使用的时候这些缓存很有作用，但当你的应用程序UI不可见的时候，这些缓存就可以被清除以减少内存的使用．比如第三方图片库的缓存．</li>
<li>一些动态生成动态添加的View．　这些动态生成和添加的View且少数情况下才使用到的View，这时候可以被释放，下次使用的时候再进行动态生成即可．比如原生桌面中，会在OnTrimMemory的TRIM_MEMORY_MODERATE等级中，释放所有AppsCustomizePagedView的资源，来保证在低内存的时候，桌面不会轻易被杀掉．</li>
</ul>
<h4 id="2-1_例子：释放不常用到的View．">2.1 例子：释放不常用到的View．</h4><p>代码出处：Launcher</p>
<p>Launcher.java:<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onTrimMemory</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onTrimMemory(level);</span><br><span class="line">    <span class="keyword">if</span> (level &gt;= ComponentCallbacks2.TRIM_MEMORY_MODERATE) &#123;</span><br><span class="line">        mAppsCustomizeTabHost.onTrimMemory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AppsCustomizeTabHost.java:<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onTrimMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mContent.setVisibility(GONE);</span><br><span class="line">    <span class="comment">// Clear the widget pages of all their subviews - this will trigger the widget previews</span></span><br><span class="line">    <span class="comment">// to delete their bitmaps</span></span><br><span class="line">    mPagedView.clearAllWidgetPages();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AppsCustomizePagedView.java:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearAllWidgetPages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cancelAllTasks();</span><br><span class="line">    <span class="keyword">int</span> count = getChildCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        View v = getPageAt(i);</span><br><span class="line">        <span class="keyword">if</span> (v instanceof PagedViewGridLayout) &#123;</span><br><span class="line">            ((PagedViewGridLayout) v).removeAllViewsOnPage();</span><br><span class="line">            mDirtyPageContent.<span class="built_in">set</span>(i, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PagedViewGridLayout.java<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">removeAllViewsOnPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    removeAllViews();</span><br><span class="line">    mOnLayoutListener = <span class="keyword">null</span>;</span><br><span class="line">    setLayerType(LAYER_TYPE_NONE, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-2_例子:_清除缓存">2.2 例子: 清除缓存</h4><p>代码出处：Contact</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onTrimMemory</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (level &gt;= ComponentCallbacks2.TRIM_MEMORY_MODERATE) &#123;</span><br><span class="line">        <span class="comment">// Clear the caches.  Note all pending requests will be removed too.</span></span><br><span class="line">        clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mPendingRequests.clear();</span><br><span class="line">    mBitmapHolderCache.evictAll();</span><br><span class="line">    mBitmapCache.evictAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-_OnTrimMemory和onStop的关系？">3. OnTrimMemory和onStop的关系？</h2><p>onTrimMemory()方法中的TRIM_MEMORY_UI_HIDDEN回调只有当我们程序中的所有UI组件全部不可见的时候才会触发，这和onStop()方法还是有很大区别的，因为onStop()方法只是当一个Activity完全不可见的时候就会调用，比如说用户打开了我们程序中的另一个Activity。</p>
<p>因此，我们可以在onStop()方法中去释放一些Activity相关的资源，比如说取消网络连接或者注销广播接收器等，但是像UI相关的资源应该一直要等到onTrimMemory(TRIM_MEMORY_UI_HIDDEN)这个回调之后才去释放，这样可以保证如果用户只是从我们程序的一个Activity回到了另外一个Activity，界面相关的资源都不需要重新加载，从而提升响应速度。</p>
<p>需要注意的是，onTrimMemory的TRIM_MEMORY_UI_HIDDEN 等级是在onStop方法之前调用的．</p>
<h2 id="4-_OnTrimMemory和OnLowMemory的关系？">4. OnTrimMemory和OnLowMemory的关系？</h2><p>在引入OnTrimMemory之前都是使用OnLowMemory回调，需要知道的是，OnLowMemory大概和OnTrimMemory中的TRIM_MEMORY_COMPLETE级别相同，如果你想兼容api&lt;14的机器，那么可以用OnLowMemory来实现，否则你可以忽略OnLowMemory，直接使用OnTrimMemory即可．</p>
<h2 id="5-_为什么要调用OnTrimMemory？">5. 为什么要调用OnTrimMemory？</h2><p>尽管系统在内存不足的时候杀进程的顺序是按照LRU Cache中从低到高来的，但是它同时也会考虑杀掉那些占用内存较高的应用来让系统更快地获得更多的内存。</p>
<p>所以如果你的应用占用内存较小，就可以增加不被杀掉的几率，从而快速地恢复（如果不被杀掉，启动的时候就是热启动，否则就是冷启动，其速度差在2~3倍）。</p>
<p>所以说在几个不同的OnTrimMemory回调中释放自己的UI资源，可以有效地提高用户体验。</p>
<h2 id="6-_有哪些典型的使用场景？">6. 有哪些典型的使用场景？</h2><h3 id="6-1_常驻内存的应用">6.1 常驻内存的应用</h3><p>一些常驻内存的应用，比如Launcher、安全中心、电话等，在用户使用过要退出的时候，需要调用OnTrimMemory来及时释放用户使用的时候所产生的多余的内存资源：比如动态生成的View、图片缓存、Fragment等。</p>
<h3 id="6-2_有后台Service运行的应用">6.2 有后台Service运行的应用</h3><p>这些应用不是常驻内存的，意味着可以被任务管理器杀掉，但是在某些场景下用户不会去杀。<br>这类应用包括：音乐、下载等。用户退出UI界面后，音乐还在继续播放，下载程序还在运行。这时候音乐应该释放部分UI资源和Cache。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>OnTrimMemory 回调是 Android 4.0 之后提供的一个API，这个 API 是提供给开发者的，它的主要作用是提示开发者在系统内存不足的时候，通过处理部分资源来释放内存，从而避免被 Android 系统杀死。这样应用在下一次启动的时候，速度就会比较快。</p>
<p>本文通过问答的方式，从各个方面来讲解 OnTrimMemory 回调的使用过程和效果。想要开发高性能且用户体验良好的 Android 应用，那么这篇文章你不应该错过。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/tags/Android/"/>
    
      <category term="MAT" scheme="http://androidperformance.com/tags/MAT/"/>
    
      <category term="Menory" scheme="http://androidperformance.com/tags/Menory/"/>
    
      <category term="Performance" scheme="http://androidperformance.com/tags/Performance/"/>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
      <category term="Menory" scheme="http://androidperformance.com/categories/Android/Menory/"/>
    
      <category term="Performance" scheme="http://androidperformance.com/categories/Android/Menory/Performance/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android代码内存优化建议-Android资源篇]]></title>
    <link href="http://androidperformance.com/2015/07/20/Android-Performance-Memory-AndroidResource.html"/>
    <id>http://androidperformance.com/2015/07/20/Android-Performance-Memory-AndroidResource.html</id>
    <published>2015-07-20T03:48:30.000Z</published>
    <updated>2015-07-20T05:50:22.000Z</updated>
    <content type="html"><![CDATA[<p>这篇文章主要介绍在实际Android应用程序的开发中，容易导致内存泄露的一些情况。开发人员如果在进行代码编写之前就有内存泄露方面的基础知识，那么写出来的代码会强壮许多，写这篇文章也是这个初衷。本文从Android开发中的资源使用情况入手，介绍了如何在Bitmap、数据库查询、9-patch、过渡绘制等方面优化内存的使用。</p>
<a id="more"></a>
<h1 id="Android资源优化">Android资源优化</h1><h2 id="1-_Bitmap优化">1. Bitmap优化</h2><p>Android中的大部分内存问题归根结底都是Bitmap的问题，如果打开MAT(Memory analyzer tool)来看，实际占用内存大的都是一些Bitmap(以byte数组的形式存储)。所以Bitmap的优化应该是我们着重去解决的。Google在其官方有针对Bitmap的使用专门写了一个专题 : <a href="http://developer.android.com/training/displaying-bitmaps/index.html" target="_blank" rel="external">Displaying Bitmaps Efficiently</a>, 对应的中文翻译在 ：<a href="https://github.com/kesenhoo/android-training-course-in-chinese/tree/master/graphics/displaying-bitmaps" target="_blank" rel="external">displaying-bitmaps</a> , 在优化Bitmap资源之前，请先看看这个系列的文档，以确保自己正确地使用了Bitmap。</p>
<p>Bitmap如果没有被释放，那么一般只有两个问题：</p>
<ul>
<li>用户在使用完这个Bitmap之后，没有主动去释放Bitmap资源。</li>
<li>这个Bitmap资源被引用所以无法被释放 。</li>
</ul>
<h3 id="1-1_主动释放Bitmap资源">1.1 主动释放Bitmap资源</h3><p>当你确定这个Bitmap资源不会再被使用的时候(当然这个Bitmap不释放可能会让程序下一次启动或者resume快一些，但是其占用的内存资源太大，可能导致程序在后台的时候被杀掉，反而得不偿失)，我们建议手动调用recycle()方法，释放其Native内存：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">if</span>(<span class="keyword">bitmap </span>!= null &amp;&amp; !<span class="keyword">bitmap.isRecycled())&#123; </span> </span><br><span class="line">    <span class="keyword">bitmap.recycle(); </span></span><br><span class="line">    <span class="keyword">bitmap </span>= null<span class="comment">; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以看一下Bitmap.java中recycle()方法的说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span><br><span class="line">     * Free the native object associated with this bitmap, and clear the</span><br><span class="line">     * reference to the pixel data. This will not free the pixel data synchronously;</span><br><span class="line">     * it simply allows it to be garbage collected if there are no other references.</span><br><span class="line">     * The bitmap is marked as "dead", meaning it will throw an exception if</span><br><span class="line">     * getPixels() or setPixels() is called, and will draw nothing. This operation</span><br><span class="line">     * cannot be reversed, so it should only be called if you are sure there are no</span><br><span class="line">     * further uses for the bitmap. This is an advanced call, and normally need</span><br><span class="line">     * not be called, since the normal GC process will free up this memory when</span><br><span class="line">     * there are no more references to this bitmap.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mRecycled) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nativeRecycle(mNativeBitmap)) &#123;</span><br><span class="line">                <span class="comment">// return value indicates whether native pixel object was actually recycled.</span></span><br><span class="line">                <span class="comment">// false indicates that it is still in use at the native level and these</span></span><br><span class="line">                <span class="comment">// objects should not be collected now. They will be collected later when the</span></span><br><span class="line">                <span class="comment">// Bitmap itself is collected.</span></span><br><span class="line">                mBuffer = <span class="keyword">null</span>;</span><br><span class="line">                mNinePatchChunk = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mRecycled = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"><span class="comment">//如果使用过程中抛出异常的判断</span></span><br><span class="line"><span class="keyword">if</span> (bitmap.isRecycled()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Canvas: trying to use a recycled bitmap "</span> + bitmap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用bitmap.recycle之后，这个Bitmap如果没有被引用到，那么就会被垃圾回收器回收。如果不主动调用这个方法，垃圾回收器也会进行回收工作，只不过垃圾回收器的不确定性太大，依赖其自动回收不靠谱(比如垃圾回收器一次性要回收好多Bitmap，那么需要的时间就会很多，导致回收的时候会卡顿)。所以我们需要主动调用recycle。</p>
<h3 id="1-2_主动释放ImageView的图片资源">1.2 主动释放ImageView的图片资源</h3><p>由于我们在实际开发中，很多情况是在xml布局文件中设置ImageView的src或者在代码中调用ImageView.setImageResource/setImageURI/setImageDrawable等方法设置图像，下面代码可以回收这个ImageView所对应的资源：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">private</span> static void recycleImageViewBitMap(ImageView imageView) &#123;</span><br><span class="line">    <span class="preprocessor">if</span> (imageView != null) &#123;</span><br><span class="line">        <span class="keyword">BitmapDrawable </span><span class="keyword">bd </span>= (<span class="keyword">BitmapDrawable) </span>imageView.getDrawable()<span class="comment">;</span></span><br><span class="line">        rceycleBitmapDrawable(<span class="keyword">bd);</span><br><span class="line"></span>    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="label">private</span> static void rceycleBitmapDrawable(<span class="keyword">BitmapDrawable </span><span class="keyword">bitmapDrawable) </span>&#123;</span><br><span class="line">    <span class="preprocessor">if</span> (<span class="keyword">bitmapDrawable </span>!= null) &#123;</span><br><span class="line">        <span class="keyword">Bitmap </span><span class="keyword">bitmap </span>= <span class="keyword">bitmapDrawable.getBitmap();</span><br><span class="line"></span>        rceycleBitmap(<span class="keyword">bitmap);</span><br><span class="line"></span>    &#125;</span><br><span class="line">    <span class="keyword">bitmapDrawable </span>= null<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="label">private</span> static void rceycleBitmap(<span class="keyword">Bitmap </span><span class="keyword">bitmap) </span>&#123;</span><br><span class="line">    <span class="preprocessor">if</span> (<span class="keyword">bitmap </span>!= null &amp;&amp; !<span class="keyword">bitmap.isRecycled()) </span>&#123;</span><br><span class="line">        <span class="keyword">bitmap.recycle();</span><br><span class="line"></span>        <span class="keyword">bitmap </span>= null<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3_主动释放ImageView的背景资源">1.3 主动释放ImageView的背景资源</h3><p>如果你的ImageView是有Background，那么下面的代码可以释放他：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">public</span> static void recycleBackgroundBitMap(ImageView view) &#123;</span><br><span class="line">    <span class="preprocessor">if</span> (view != null) &#123;</span><br><span class="line">        <span class="keyword">BitmapDrawable </span><span class="keyword">bd </span>= (<span class="keyword">BitmapDrawable) </span>view.getBackground()<span class="comment">;</span></span><br><span class="line">        rceycleBitmapDrawable(<span class="keyword">bd);</span><br><span class="line"></span>    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="label">public</span> static void recycleImageViewBitMap(ImageView imageView) &#123;</span><br><span class="line">    <span class="preprocessor">if</span> (imageView != null) &#123;</span><br><span class="line">        <span class="keyword">BitmapDrawable </span><span class="keyword">bd </span>= (<span class="keyword">BitmapDrawable) </span>imageView.getDrawable()<span class="comment">;</span></span><br><span class="line">        rceycleBitmapDrawable(<span class="keyword">bd);</span><br><span class="line"></span>    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="label">private</span> static void rceycleBitmapDrawable(<span class="keyword">BitmapDrawable </span><span class="keyword">bitmapDrawable) </span>&#123;</span><br><span class="line">    <span class="preprocessor">if</span> (<span class="keyword">bitmapDrawable </span>!= null) &#123;</span><br><span class="line">        <span class="keyword">Bitmap </span><span class="keyword">bitmap </span>= <span class="keyword">bitmapDrawable.getBitmap();</span><br><span class="line"></span>        rceycleBitmap(<span class="keyword">bitmap);</span><br><span class="line"></span>    &#125;</span><br><span class="line">    <span class="keyword">bitmapDrawable </span>= null<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4_尽量少用Png图，多用NinePatch的图">1.4 尽量少用Png图，多用NinePatch的图</h3><p>现在手机的分辨率越来越高，图片资源在被加载后所占用的内存也越来越大，所以要尽量避免使用大的PNG图，在产品设计的时候就要尽量避免用一张大图来进行展示，尽量多用NinePatch资源。</p>
<p>Android中的NinePatch指的是一种拉伸后不会变形的特殊png图，NinePatch的拉伸区域可以自己定义。这种图的优点是体积小，拉伸不变形，可以适配多机型。Android SDK中有自带NinePatch资源制作工具，Android-Studio中在普通png图片点击右键可以将其转换为NinePatch资源，使用起来非常方便。</p>
<p><img src="/images/Memory_AndroidSoruce/1.png" alt="左边是原图，右边是拉伸后的效果"></p>
<h3 id="1-5_使用大图之前，尽量先对其进行压缩">1.5 使用大图之前，尽量先对其进行压缩</h3><p>图片有不同的形状与大小。在大多数情况下它们的实际大小都比需要呈现出来的要大很多。例如，系统的Gallery程序会显示那些你使用设备camera拍摄的图片，但是那些图片的分辨率通常都比你的设备屏幕分辨率要高很多。</p>
<p>考虑到程序是在有限的内存下工作，理想情况是你只需要在内存中加载一个低分辨率的版本即可。这个低分辨率的版本应该是与你的UI大小所匹配的，这样才便于显示。一个高分辨率的图片不会提供任何可见的好处，却会占用宝贵的(precious)的内存资源，并且会在快速滑动图片时导致(incurs)附加的效率问题。</p>
<p>Google官网的Training中，有一篇文章专门介绍如何有效地加载大图，里面提到了两个比较重要的技术：</p>
<ul>
<li>在图片加载前获取其宽高和类型</li>
<li>加载一个按比例缩小的版本到内存中</li>
</ul>
<p>原文地址：<a href="http://developer.android.com/training/displaying-bitmaps/load-bitmap.html#read-bitmap" target="_blank" rel="external">Loading Large Bitmaps Efficiently</a>,中文翻译地址：<a href="https://github.com/kesenhoo/android-training-course-in-chinese/blob/master/graphics/displaying-bitmaps/load-bitmap.md" target="_blank" rel="external">有效地加载大尺寸位图</a>，强烈建议每一位Android开发者都去看一下，并在自己的实际项目中使用到。</p>
<p>更多关于Bitmap的使用和优化，可以参考Android官方Training专题的<a href="http://developer.android.com/training/displaying-bitmaps/index.html" target="_blank" rel="external">displaying-bitmaps</a></p>
<h2 id="2_查询数据库没有关闭游标">2 查询数据库没有关闭游标</h2><p>程序中经常会进行查询数据库的操作，但是经常会有使用完毕Cursor后没有关闭的情况。如果我们的查询结果集比较小，对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会复现内存问题，这样就会给以后的测试和问题排查带来困难和风险。<br>示例代码：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Curs<span class="subst">or</span> curs<span class="subst">or</span> = getContentResolver()<span class="built_in">.</span>query(uri <span class="attribute">...</span>);</span><br><span class="line">	<span class="keyword">if</span> (curs<span class="subst">or</span><span class="built_in">.</span>moveToNext()) &#123;</span><br><span class="line"> 	<span class="attribute">...</span> <span class="attribute">...</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修正示例代码:</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Cursor <span class="built_in">cursor</span> = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  	<span class="built_in">cursor</span> = getContentResolver().query(uri ...);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">cursor</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">cursor</span>.moveToNext()) &#123;</span><br><span class="line">	... ... </span><br><span class="line">	&#125;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">cursor</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123; </span><br><span class="line">		<span class="built_in">cursor</span>.close();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		<span class="comment">//ignore this</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>`</p>
<h2 id="3_构造Adapter时，没有使用缓存的convertView">3 构造Adapter时，没有使用缓存的convertView</h2><p>以构造ListView的BaseAdapter为例，在BaseAdapter中提供了方法：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> View getView(<span class="built_in">int</span> <span class="keyword">position</span>, View convertView, ViewGroup parent)</span><br></pre></td></tr></table></figure>
<p>来向ListView提供每一个item所需要的view对象。初始时ListView会从BaseAdapter中根据当前的屏幕布局实例化一定数量的view对象，同时ListView会将这些view对象缓存起来。当向上滚动ListView时，原先位于最上面的list item的view对象会被回收，然后被用来构造新出现的最下面的list item。这个构造过程就是由getView()方法完成的，getView()的第二个形参 View convertView就是被缓存起来的list item的view对象(初始化时缓存中没有view对象则convertView是null)。<br>由此可以看出，如果我们不去使用convertView，而是每次都在getView()中重新实例化一个View对象的话，即浪费资源也浪费时间，也会使得内存占用越来越大。ListView回收list item的view对象的过程可以查看:android.widget.AbsListView.java –> void addScrapView(View scrap) 方法。</p>
<p><img src="/images/Memory_AndroidSoruce/2.png" alt="ListView的getView"></p>
<p>示例代码：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> View getView(int position, View convertView, ViewGroup <span class="keyword">parent</span>) &#123;</span><br><span class="line"> View view = <span class="literal">new</span> Xxx(<span class="attribute">...</span>);</span><br><span class="line"> <span class="attribute">...</span> <span class="attribute">...</span></span><br><span class="line"> <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>`<br>示例修正代码：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> View getView(int position, View convertView, ViewGroup <span class="keyword">parent</span>) &#123;</span><br><span class="line"> View view = <span class="built_in">null</span>;</span><br><span class="line"> <span class="keyword">if</span> (convertView != <span class="built_in">null</span>) &#123;</span><br><span class="line"> view = convertView;</span><br><span class="line"> populate(view, getItem(position));</span><br><span class="line"> <span class="attribute">...</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> view = <span class="literal">new</span> Xxx(<span class="attribute">...</span>);</span><br><span class="line"> <span class="attribute">...</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于ListView的使用和优化，可以参考这两篇文章：</p>
<ul>
<li><a href="http://www.vogella.com/tutorials/AndroidListView/article.html" target="_blank" rel="external">Using lists in Android (ListView) - Tutorial
  </a></li>
<li><a href="http://developer.android.com/training/improving-layouts/smooth-scrolling.html#ViewHolder" target="_blank" rel="external">Making ListView Scrolling Smooth</a></li>
</ul>
<h2 id="4_释放对象的引用">4 释放对象的引用</h2><p>前面有说过，一个对象的内存没有被释放是因为他被其他的对象所引用，系统不回去释放这些有GC Root的对象。</p>
<p>示例A：<br>假设有如下操作</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DemoActivity</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Activity</span> &#123;</span></span><br><span class="line">	... ...</span><br><span class="line">	<span class="keyword">private</span> <span class="type">Handler</span> mHandler = ...</span><br><span class="line">	<span class="keyword">private</span> <span class="type">Object</span> obj;</span><br><span class="line">	public void operation() &#123;</span><br><span class="line">	 obj = initObj();</span><br><span class="line">	 ...</span><br><span class="line">	 [<span class="type">Mark</span>]</span><br><span class="line">	 mHandler.post(<span class="keyword">new</span> <span class="type">Runnable</span>() &#123;</span><br><span class="line">	        public void run() &#123;</span><br><span class="line">	         useObj(obj);</span><br><span class="line">	        &#125;</span><br><span class="line">	 &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们有一个成员变量 obj，在operation()中我们希望能够将处理obj实例的操作post到某个线程的MessageQueue中。在以上的代码中，即便是mHandler所在的线程使用完了obj所引用的对象，但这个对象仍然不会被垃圾回收掉，因为DemoActivity.obj还保有这个对象的引用。所以如果在DemoActivity中不再使用这个对象了，可以在[Mark]的位置释放对象的引用，而代码可以修改为：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	obj = initObj();</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">final</span> Object o = obj;</span><br><span class="line">	obj = <span class="keyword">null</span>;</span><br><span class="line">	mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">	    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	        useObj(o);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例B：<br>假设我们希望在锁屏界面(LockScreen)中，监听系统中的电话服务以获取一些信息(如信号强度等)，则可以在LockScreen中定义一个PhoneStateListener的对象，同时将它注册到TelephonyManager服务中。对于LockScreen对象，当需要显示锁屏界面的时候就会创建一个LockScreen对象，而当锁屏界面消失的时候LockScreen对象就会被释放掉。  </p>
<p>但是如果在释放LockScreen对象的时候忘记取消我们之前注册的PhoneStateListener对象，则会导致LockScreen无法被垃圾回收。如果不断的使锁屏界面显示和消失，则最终会由于大量的LockScreen对象没有办法被回收而引起OutOfMemory,使得system_ui进程挂掉。</p>
<p>总之当一个生命周期较短的对象A，被一个生命周期较长的对象B保有其引用的情况下，在A的生命周期结束时，要在B中清除掉对A的引用。</p>
<p>使用MAT可以很方便地查看对象之间的引用，</p>
<h2 id="5_在Activity的生命周期中释放资源">5 在Activity的生命周期中释放资源</h2><p>Android应用程序中最典型的需要注意释放资源的情况是在Activity的生命周期中，在onPause()、onStop()、onDestroy()方法中需要适当的释放资源的情况。由于此情况很基础，在此不详细说明，具体可以查看官方文档对Activity生命周期的介绍，以明确何时应该释放哪些资源。</p>
<h2 id="6_消除过渡绘制">6 消除过渡绘制</h2><p>过渡绘制指的是在屏幕一个像素上绘制多次(超过一次),比如一个TextView后有背景，那么显示文本的像素至少绘了两次，一次是背景，一次是文本。GPU过度绘制或多或少对性能有些影响,设备的内存带宽是有限的，当过度绘制导致应用需要更多的带宽(超过了可用带宽)的时候性能就会降低。带宽的限制每个设备都可能是不一样的。</p>
<p>过渡绘制的原因:</p>
<ol>
<li>同一层级的View叠加</li>
<li>复杂的层级叠加</li>
</ol>
<p>减少过渡绘制能去掉一些无用的View，能有效减少GPU的负载，也可以减轻一部分内存压力。关于过渡绘制我专门写了一篇文章来介绍：<a href="http://www.androidperformance.com/android-performance-optimization-overdraw-1.html" target="_blank" rel="external">过渡绘制及其优化</a></p>
<h2 id="7_使用Android系统自带的资源">7 使用Android系统自带的资源</h2><p>在Android应用开发过程中，屏幕上控件的布局代码和程序的逻辑代码通常是分开的。界面的布局代码是放在一个独立的xml文件中的，这个文件里面是树型组织的，控制着页面的布局。通常，在这个页面中会用到很多控件，控件会用到很多的资源。Android系统本身有很多的资源，包括各种各样的字符串、图片、动画、样式和布局等等，这些都可以在应用程序中直接使用。这样做的好处很多，既可以减少内存的使用，又可以减少部分工作量，也可以缩减程序安装包的大小。</p>
<p>比如下面的代码就是使用系统的ListView：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ListView </span><br><span class="line">    android:<span class="property">id</span>=<span class="string">"@android:id/list"</span></span><br><span class="line">    android:layout_width=<span class="string">"fill_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"fill_parent"</span>/&gt;</span><br></pre></td></tr></table></figure>
<h2 id="8_使用内存相关工具检测">8 使用内存相关工具检测</h2><p>在开发中，不可能保证一次就开发出一个内存管理非常棒的应用，所以在开发的每一个阶段，都要有意识地去针对内存进行专门的检查。目前Android提供了许多布局、内存相关的工具，比如Lint、MAT等。学会这些工具的使用是一个Android开发者必不可少的技能。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇文章主要介绍在实际Android应用程序的开发中，容易导致内存泄露的一些情况。开发人员如果在进行代码编写之前就有内存泄露方面的基础知识，那么写出来的代码会强壮许多，写这篇文章也是这个初衷。本文从Android开发中的资源使用情况入手，介绍了如何在Bitmap、数据库查询、9-patch、过渡绘制等方面优化内存的使用。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/tags/Android/"/>
    
      <category term="MAT" scheme="http://androidperformance.com/tags/MAT/"/>
    
      <category term="Menory" scheme="http://androidperformance.com/tags/Menory/"/>
    
      <category term="Performance" scheme="http://androidperformance.com/tags/Performance/"/>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
      <category term="Menory" scheme="http://androidperformance.com/categories/Android/Menory/"/>
    
      <category term="Performance" scheme="http://androidperformance.com/categories/Android/Menory/Performance/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android代码内存优化建议-Android官方篇]]></title>
    <link href="http://androidperformance.com/2015/07/20/Android-Performance-Memory-Google.html"/>
    <id>http://androidperformance.com/2015/07/20/Android-Performance-Memory-Google.html</id>
    <published>2015-07-20T03:29:32.000Z</published>
    <updated>2015-07-20T03:32:02.000Z</updated>
    <content type="html"><![CDATA[<p>为了使垃圾回收器可以正常释放程序所占用的内存，在编写代码的时候就一定要注意尽量避免出现内存泄漏的情况（通常都是由于全局成员变量持有对象引用所导致的），并且在适当的时候去释放对象引用。对于大多数的应用程序而言，后面其它的事情就可以都交给垃圾回收器去完成了，如果一个对象的引用不再被其它对象所持有，那么系统就会将这个对象所分配的内存进行回收。</p>
<p>我们在开发软件的时候应当自始至终都把内存的问题充分考虑进去，这样的话才能开发出更加高性能的软件。而内存问题也并不是无规律可行的，Android系统给我们提出了很多内存优化的建议技巧，只要按照这些技巧来编写程序，就可以让我们的程序在内存性能发面表现得相当不错。</p>
<a id="more"></a>
<h2 id="正文">正文</h2><p>本文原文来自Android开发者官网<a href="http://developer.android.com/training/articles/memory.html" target="_blank" rel="external">Managing Your App’s Memory</a>章节中的<br><a href="http://developer.android.com/training/articles/memory.html#YourApp" target="_blank" rel="external">How Your App Should Manage Memory</a>部分。是Android官方帮助应用开发者更好地管理应用的内存而写的。作为一个应用程序开发者，你需要在你开发应用程序的时时刻刻都考虑内存问题。</p>
<h3 id="1-_节制地使用Service">1. 节制地使用Service</h3><p>如果应用程序当中需要使用Service来执行后台任务的话，请一定要注意只有当任务正在执行的时候才应该让Service运行起来。另外，当任务执行完之后去停止Service的时候，要小心Service停止失败导致内存泄漏的情况。</p>
<p>当我们启动一个Service时，系统会倾向于将这个Service所依赖的进程进行保留，这样就会导致这个进程变得非常消耗内存。并且，系统可以在LRU cache当中缓存的进程数量也会减少，导致切换应用程序的时候耗费更多性能。严重的话，甚至有可能会导致崩溃，因为系统在内存非常吃紧的时候可能已无法维护所有正在运行的Service所依赖的进程了。</p>
<p>为了能够控制Service的生命周期，Android官方推荐的最佳解决方案就是使用<a href="http://developer.android.com/reference/android/app/IntentService.html" target="_blank" rel="external"><strong>IntentService</strong></a>，这种Service的最大特点就是当后台任务执行结束后会自动停止，从而极大程度上避免了Service内存泄漏的可能性。</p>
<p>让一个Service在后台一直保持运行，即使它并不执行任何工作，这是编写Android程序时最糟糕的做法之一。所以Android官方极度建议开发人员们不要过于贪婪，让Service在后台一直运行，这不仅可能会导致手机和程序的性能非常低下，而且被用户发现了之后也有可能直接导致我们的软件被卸载</p>
<h3 id="2-_当界面不可见时释放内存">2. 当界面不可见时释放内存</h3><p>当用户打开了另外一个程序，我们的程序界面已经不再可见的时候，我们应当将所有和界面相关的资源进行释放。在这种场景下释放资源可以让系统缓存后台进程的能力显著增加，因此也会让用户体验变得更好。<br>那么我们如何才能知道程序界面是不是已经不可见了呢？其实很简单，只需要在Activity中重写onTrimMemory()方法，然后在这个方法中监听TRIM_MEMORY_UI_HIDDEN这个级别，一旦触发了之后就说明用户已经离开了我们的程序，那么此时就可以进行资源释放操作了，如下所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="typename">void</span> onTrimMemory(<span class="typename">int</span> level) &#123;  </span><br><span class="line">    <span class="keyword">super</span>.onTrimMemory(level);  </span><br><span class="line">    <span class="keyword">switch</span> (level) &#123;  </span><br><span class="line">    <span class="keyword">case</span> <span class="string">TRIM_MEMORY_UI_HIDDEN:</span>  </span><br><span class="line">        <span class="comment">// 进行资源释放操作  </span></span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意onTrimMemory()方法中的TRIM_MEMORY_UI_HIDDEN回调只有当我们程序中的所有UI组件全部不可见的时候才会触发，这和onStop()方法还是有很大区别的，因为onStop()方法只是当一个Activity完全不可见的时候就会调用，比如说用户打开了我们程序中的另一个Activity。因此，我们可以在onStop()方法中去释放一些Activity相关的资源，比如说取消网络连接或者注销广播接收器等，但是像UI相关的资源应该一直要等到onTrimMemory(TRIM_MEMORY_UI_HIDDEN)这个回调之后才去释放，这样可以保证如果用户只是从我们程序的一个Activity回到了另外一个Activity，界面相关的资源都不需要重新加载，从而提升响应速度。</p>
<h3 id="3-当内存紧张时释放内存">3.当内存紧张时释放内存</h3><p>除了刚才讲的<strong>TRIM_MEMORY_UI_HIDDEN</strong>这个回调，onTrimMemory()方法还有很多种其它类型的回调，可以在手机内存降低的时候及时通知我们。我们应该根据回调中传入的级别来去决定如何释放应用程序的资源：</p>
<h4 id="3-1_应用程序正在运行时">3.1 应用程序正在运行时</h4><p><strong>TRIM_MEMORY_RUNNING_MODERATE</strong> 表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经有点低了，系统可能会开始根据LRU缓存规则来去杀死进程了。<br><strong>TRIM_MEMORY_RUNNING_LOW</strong> 表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经非常低了，我们应该去释放掉一些不必要的资源以提升系统的性能，同时这也会直接影响到我们应用程序的性能。<br><strong>TRIM_MEMORY_RUNNING_CRITICAL</strong> 表示应用程序仍然正常运行，但是系统已经根据LRU缓存规则杀掉了大部分缓存的进程了。这个时候我们应当尽可能地去释放任何不必要的资源，不然的话系统可能会继续杀掉所有缓存中的进程，并且开始杀掉一些本来应当保持运行的进程，比如说后台运行的服务。</p>
<h4 id="3-2_应用程序被缓存">3.2 应用程序被缓存</h4><p><strong>TRIM_MEMORY_BACKGROUND</strong> 表示手机目前内存已经很低了，系统准备开始根据LRU缓存来清理进程。这个时候我们的程序在LRU缓存列表的最近位置，是不太可能被清理掉的，但这时去释放掉一些比较容易恢复的资源能够让手机的内存变得比较充足，从而让我们的程序更长时间地保留在缓存当中，这样当用户返回我们的程序时会感觉非常顺畅，而不是经历了一次重新启动的过程。<br><strong>TRIM_MEMORY_MODERATE</strong> 表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的中间位置，如果手机内存还得不到进一步释放的话，那么我们的程序就有被系统杀掉的风险了。<br><strong>TRIM_MEMORY_COMPLETE</strong> 表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的最边缘位置，系统会最优先考虑杀掉我们的应用程序，在这个时候应当尽可能地把一切可以释放的东西都进行释放。</p>
<p>因为onTrimMemory()是在API14才加进来的，所以如果要支持API14之前的话，则可以考虑 <a href="http://developer.android.com/reference/android/content/ComponentCallbacks.html#onLowMemory(" target="_blank" rel="external">onLowMemory()</a>)这个方法，它粗略的相等于onTrimMemory()回调的TRIM_MEMORY_COMPLETE事件。</p>
<blockquote>
<p>注意：当系统安装LRU cache杀进程的时候，尽管大部分时间是从下往上按顺序杀，有时候系统也会将占用内存比较大的进程纳入被杀范围，以尽快得到足够的内存。所以你的应用在LRU list中占用的内存越少，你就越能避免被杀掉，当你恢复的时候也会更快。</p>
</blockquote>
<h3 id="4-_检查你应该使用多少的内存">4. 检查你应该使用多少的内存</h3><p>正如前面提到的，每一个Android设备都会有不同的RAM总大小与可用空间，因此不同设备为app提供了不同大小的heap限制。你可以通过调用<a href="http://developer.android.com/reference/android/app/ActivityManager.html#getMemoryClass(" target="_blank" rel="external">getMemoryClass()</a>)来获取你的app的可用heap大小。如果你的app尝试申请更多的内存，会出现OutOfMemory的错误。</p>
<p>在一些特殊的情景下，你可以通过在manifest的application标签下添加largeHeap=true的属性来声明一个更大的heap空间。如果你这样做，你可以通过<a href="http://developer.android.com/reference/android/app/ActivityManager.html#getLargeMemoryClass(" target="_blank" rel="external">getLargeMemoryClass()</a>)来获取到一个更大的heap size。</p>
<p>然而，能够获取更大heap的设计本意是为了一小部分会消耗大量RAM的应用(例如一个大图片的编辑应用)。<strong>不要轻易的因为你需要使用大量的内存而去请求一个大的heap size。</strong>只有当你清楚的知道哪里会使用大量的内存并且为什么这些内存必须被保留时才去使用large heap. 因此请尽量少使用large heap。使用额外的内存会影响系统整体的用户体验，并且会使得GC的每次运行时间更长。在任务切换时，系统的性能会变得大打折扣。</p>
<p>另外, large heap并不一定能够获取到更大的heap。在某些有严格限制的机器上，large heap的大小和通常的heap size是一样的。因此即使你申请了large heap，你还是应该通过执行getMemoryClass()来检查实际获取到的heap大小。</p>
<h3 id="5-_避免在Bitmap上浪费内存">5. 避免在Bitmap上浪费内存</h3><p>当我们读取一个Bitmap图片的时候，有一点一定要注意，就是千万不要去加载不需要的分辨率。在一个很小的ImageView上显示一张高分辨率的图片不会带来任何视觉上的好处，但却会占用我们相当多宝贵的内存。需要仅记的一点是，将一张图片解析成一个Bitmap对象时所占用的内存并不是这个图片在硬盘中的大小，可能一张图片只有100k你觉得它并不大，但是读取到内存当中是按照像素点来算的，比如这张图片是1500<em>1000像素，使用的ARGB_8888颜色类型，那么每个像素点就会占用4个字节，总内存就是1500</em>1000*4字节，也就是5.7M，这个数据看起来就比较恐怖了。</p>
<h3 id="6-_使用优化过的数据集合">6. 使用优化过的数据集合</h3><p>利用Android Framework里面优化过的容器类，例如<a href="http://developer.android.com/reference/android/util/SparseArray.html" target="_blank" rel="external">SparseArray</a>, <a href="http://developer.android.com/reference/android/util/SparseBooleanArray.html" target="_blank" rel="external">SparseBooleanArray</a>, 与 <a href="http://developer.android.com/reference/android/support/v4/util/LongSparseArray.html" target="_blank" rel="external">LongSparseArray</a>。 通常的HashMap的实现方式更加消耗内存，因为它需要一个额外的实例对象来记录Mapping操作。另外，SparseArray更加高效在于他们避免了对key与value的autobox自动装箱，并且避免了装箱后的解箱。</p>
<h3 id="7-_知晓内存的开支情况">7. 知晓内存的开支情况</h3><p>我们还应当清楚我们所使用语言的内存开支和消耗情况，并且在整个软件的设计和开发当中都应该将这些信息考虑在内。可能有一些看起来无关痛痒的写法，结果却会导致很大一部分的内存开支，例如：</p>
<ul>
<li>使用枚举通常会比使用静态常量要消耗两倍以上的内存，在Android开发当中我们应当尽可能地不使用枚举。</li>
<li>任何一个Java类，包括内部类、匿名类，都要占用大概500字节的内存空间。</li>
<li>任何一个类的实例要消耗12-16字节的内存开支，因此频繁创建实例也是会一定程序上影响内存的。</li>
<li>在使用HashMap时，即使你只设置了一个基本数据类型的键，比如说int，但是也会按照对象的大小来分配内存，大概是32字节，而不是4字节。因此最好的办法就是像上面所说的一样，使用优化过的数据集合。</li>
</ul>
<h3 id="8-_谨慎使用抽象编程">8. 谨慎使用抽象编程</h3><p>许多程序员都喜欢各种使用抽象来编程，认为这是一种很好的编程习惯。当然，这一点不可否认，因为的抽象的编程方法更加面向对象，而且在代码的维护和可扩展性方面都会有所提高。但是，在Android上使用抽象会带来额外的内存开支，因为抽象的编程方法需要编写额外的代码，虽然这些代码根本执行不到，但是却也要映射到内存当中，不仅占用了更多的内存，在执行效率方面也会有所降低。当然这里我并不是提倡大家完全不使用抽象编程，而是谨慎使用抽象编程，不要认为这是一种很酷的编程方式而去肆意使用它，只在你认为有必要的情况下才去使用。</p>
<h3 id="9-_为序列化的数据使用nano_protobufs">9. 为序列化的数据使用nano protobufs</h3><p><a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="external">Protocol buffers</a>是由Google为序列化结构数据而设计的，一种语言无关，平台无关，具有良好扩展性的协议。类似XML，却比XML更加轻量，快速，简单。如果你需要为你的数据实现协议化，你应该在客户端的代码中总是使用nano protobufs。通常的协议化操作会生成大量繁琐的代码，这容易给你的app带来许多问题：增加RAM的使用量，显著增加APK的大小，更慢的执行速度，更容易达到DEX的字符限制。</p>
<p>关于更多细节，请参考<a href="https://android.googlesource.com/platform/external/protobuf/+/master/java/README.txt" target="_blank" rel="external">protobuf readme</a>的”Nano version”章节。</p>
<h3 id="10-_尽量避免使用依赖注入框架">10. 尽量避免使用依赖注入框架</h3><p>现在有很多人都喜欢在Android工程当中使用依赖注入框架，比如说像Guice或者RoboGuice等，因为它们可以简化一些复杂的编码操作，比如可以将下面的一段代码：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class AndroidWay extends Activity &#123;   </span><br><span class="line">    TextView name<span class="comment">;   </span></span><br><span class="line">    ImageView thumbnail<span class="comment">;   </span></span><br><span class="line">    LocationManager loc<span class="comment">;   </span></span><br><span class="line">    Drawable icon<span class="comment">;   </span></span><br><span class="line">    String myName<span class="comment">;   </span></span><br><span class="line">  </span><br><span class="line">    public void onCreate(Bundle savedInstanceState) &#123;   </span><br><span class="line">        super.onCreate(savedInstanceState)<span class="comment">;   </span></span><br><span class="line">        setContentView(R.layout.main)<span class="comment">;  </span></span><br><span class="line">        name      = (TextView) findViewById(R.id.name)<span class="comment">;   </span></span><br><span class="line">        thumbnail = (ImageView) findViewById(R.id.thumbnail)<span class="comment">;   </span></span><br><span class="line">        loc       = (LocationManager) getSystemService(Activity.LOCATION_SERVICE)<span class="comment">;   </span></span><br><span class="line">        icon      = getResources().getDrawable(R.drawable.icon)<span class="comment">;   </span></span><br><span class="line">        myName    = getString(R.string.app_name)<span class="comment">;   </span></span><br><span class="line">        name.setText( "Hello, " + myName )<span class="comment">;   </span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简化成这样的一种写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@ContentView</span>(R.layout.main)  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoboWay</span> <span class="keyword">extends</span> <span class="title">RoboActivity</span> </span>&#123;   </span><br><span class="line">    <span class="annotation">@InjectView</span>(R.id.name)             TextView name;   </span><br><span class="line">    <span class="annotation">@InjectView</span>(R.id.thumbnail)        ImageView thumbnail;   </span><br><span class="line">    <span class="annotation">@InjectResource</span>(R.drawable.icon)   Drawable icon;   </span><br><span class="line">    <span class="annotation">@InjectResource</span>(R.string.app_name) String myName;   </span><br><span class="line">    <span class="annotation">@Inject</span>                            LocationManager loc;   </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);   </span><br><span class="line">        name.setText( <span class="string">"Hello, "</span> + myName );   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上去确实十分诱人，我们甚至可以将findViewById()这一类的繁琐操作全部省去了。但是这些框架为了要搜寻代码中的注解，通常都需要经历较长的初始化过程，并且还可能将一些你用不到的对象也一并加载到内存当中。这些用不到的对象会一直占用着内存空间，可能要过很久之后才会得到释放，相较之下，也许多敲几行看似繁琐的代码才是更好的选择。</p>
<h3 id="11-_谨慎使用external_libraries">11. 谨慎使用external libraries</h3><p>很多External library的代码都不是为移动网络环境而编写的，在移动客户端则显示的效率不高。至少，当你决定使用一个external library的时候，你应该针对移动网络做繁琐的porting与maintenance的工作。</p>
<p>即使是针对Android而设计的library，也可能是很危险的，因为每一个library所做的事情都是不一样的。例如，其中一个lib使用的是nano protobufs, 而另外一个使用的是micro protobufs。那么这样，在你的app里面就有2种protobuf的实现方式。这样的冲突同样可能发生在输出日志，加载图片，缓存等等模块里面。</p>
<p>同样不要陷入为了1个或者2个功能而导入整个library的陷阱。如果没有一个合适的库与你的需求相吻合，你应该考虑自己去实现，而不是导入一个大而全的解决方案。</p>
<h3 id="12-_优化整体性能">12. 优化整体性能</h3><p>官方有列出许多优化整个app性能的文章：<a href="http://developer.android.com/training/best-performance.html" target="_blank" rel="external">Best Practices for Performance</a>. 这篇文章就是其中之一。有些文章是讲解如何优化app的CPU使用效率，有些是如何优化app的内存使用效率。</p>
<p>你还应该阅读<a href="http://developer.android.com/tools/debugging/debugging-ui.html" target="_blank" rel="external">optimizing your UI</a>来为layout进行优化。同样还应该关注lint工具所提出的建议，进行优化。</p>
<h3 id="13-_使用ProGuard来剔除不需要的代码">13. 使用ProGuard来剔除不需要的代码</h3><p><a href="http://developer.android.com/tools/help/proguard.html" target="_blank" rel="external">ProGuard</a>能够通过移除不需要的代码，重命名类，域与方法等方对代码进行压缩，优化与混淆。使用ProGuard可以是的你的代码更加紧凑，这样能够使用更少mapped代码所需要的RAM。</p>
<h3 id="14-_对最终的APK使用zipalign">14. 对最终的APK使用zipalign</h3><p>在编写完所有代码，并通过编译系统生成APK之后，你需要使用<a href="http://developer.android.com/tools/help/zipalign.html" target="_blank" rel="external">zipalign</a>对APK进行重新校准。如果你不做这个步骤，会导致你的APK需要更多的RAM，因为一些类似图片资源的东西不能被mapped。</p>
<p><strong>Notes::</strong>Google Play不接受没有经过zipalign的APK。</p>
<h3 id="15-_分析你的RAM使用情况">15. 分析你的RAM使用情况</h3><p>一旦你获取到一个相对稳定的版本后，需要分析你的app整个生命周期内使用的内存情况，并进行优化，更多细节请参考<a href="http://developer.android.com/tools/debugging/debugging-memory.html" target="_blank" rel="external">Investigating Your RAM Usage</a>.</p>
<h3 id="16-_使用多进程">16. 使用多进程</h3><p>如果合适的话，有一个更高级的技术可以帮助你的app管理内存使用：通过把你的app组件切分成多个组件，运行在不同的进程中。这个技术必须谨慎使用，大多数app都不应该运行在多个进程中。因为如果使用不当，它会显著增加内存的使用，而不是减少。当你的app需要在后台运行与前台一样的大量的任务的时候，可以考虑使用这个技术。</p>
<p>一个典型的例子是创建一个可以长时间后台播放的Music Player。如果整个app运行在一个进程中，当后台播放的时候，前台的那些UI资源也没有办法得到释放。类似这样的app可以切分成2个进程：一个用来操作UI，另外一个用来后台的Service.</p>
<p>你可以通过在manifest文件中声明’android:process’属性来实现某个组件运行在另外一个进程的操作。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">service</span> <span class="attribute">android:name</span>=<span class="value">".PlaybackService"</span></span><br><span class="line">         <span class="attribute">android:process</span>=<span class="value">":background"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>更多关于使用这个技术的细节，请参考原文，链接如下。<br><a href="http://developer.android.com/training/articles/memory.html" target="_blank" rel="external">http://developer.android.com/training/articles/memory.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>为了使垃圾回收器可以正常释放程序所占用的内存，在编写代码的时候就一定要注意尽量避免出现内存泄漏的情况（通常都是由于全局成员变量持有对象引用所导致的），并且在适当的时候去释放对象引用。对于大多数的应用程序而言，后面其它的事情就可以都交给垃圾回收器去完成了，如果一个对象的引用不再被其它对象所持有，那么系统就会将这个对象所分配的内存进行回收。</p>
<p>我们在开发软件的时候应当自始至终都把内存的问题充分考虑进去，这样的话才能开发出更加高性能的软件。而内存问题也并不是无规律可行的，Android系统给我们提出了很多内存优化的建议技巧，只要按照这些技巧来编写程序，就可以让我们的程序在内存性能发面表现得相当不错。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/tags/Android/"/>
    
      <category term="MAT" scheme="http://androidperformance.com/tags/MAT/"/>
    
      <category term="Menory" scheme="http://androidperformance.com/tags/Menory/"/>
    
      <category term="Performance" scheme="http://androidperformance.com/tags/Performance/"/>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
      <category term="Menory" scheme="http://androidperformance.com/categories/Android/Menory/"/>
    
      <category term="Performance" scheme="http://androidperformance.com/categories/Android/Menory/Performance/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android代码内存优化建议-Java官方篇]]></title>
    <link href="http://androidperformance.com/2015/07/20/Android-Performance-Memory-Java.html"/>
    <id>http://androidperformance.com/2015/07/20/Android-Performance-Memory-Java.html</id>
    <published>2015-07-20T03:26:09.000Z</published>
    <updated>2015-07-20T03:32:38.000Z</updated>
    <content type="html"><![CDATA[<p>这篇文章主要是介绍了一些小细节的优化技巧，当这些小技巧综合使用起来的时候，对于整个App的性能提升还是有作用的，只是不能较大幅度的提升性能而已。选择合适的算法与数据结构才应该是你首要考虑的因素，在这篇文章中不会涉及这方面。你应该使用这篇文章中的小技巧作为平时写代码的习惯，这样能够提升代码的效率。</p>
<p>本文的原文为Google官方Training的性能优化部分，这一章节主要讲解的是高性能Android代码优化建议,建议所有Android应用开发者都仔细阅读这份文档，并将所提到的编码思想运用到实际的Android开发中。</p>
<a id="more"></a>
<blockquote>
<p>原文地址：<a href="http://developer.android.com/training/articles/perf-tips.html" target="_blank" rel="external">http://developer.android.com/training/articles/perf-tips.html</a></p>
</blockquote>
<h2 id="正文">正文</h2><p>通常来说，高效的代码需要满足下面两个规则：</p>
<ul>
<li>不要做冗余的动作</li>
<li>如果能避免，尽量不要分配内存</li>
</ul>
<p>你会面临最棘手的一个问题是当你优化一个肯定会在多种类型的硬件上运行的应用程序。不同版本的VM在不同的处理器上运行速度不同。它甚至不是你可以简单地说“设备X因为F原因比设备Y快/慢”那么简单,而且也不能简单地从一个设备拓展到另一个设备。特别提醒的是模拟器在性能方面和其他的设备没有可比性。通常有JIT优化和没有JIT优化的设备之间存在巨大差异:经过JIT代码优化的设备并不一定比没有经过JIT代码优化的设备好。</p>
<p>代码的执行效果会受到设备CPU,设备内存,系统版本等诸多因素的影响。为了确保代码能够在不同设备上都运行良好，需要最大化代码的效率。</p>
<h2 id="1)避免创建不必要的对象">1)避免创建不必要的对象</h2><p>虽然GC可以回收不用的对象，可是为这些对象分配内存，并回收它们同样是需要耗费资源的。<br>因此请尽量避免创建不必要的对象，有下面一些例子来说明这个问题：</p>
<ul>
<li>如果你需要返回一个String对象，并且你知道它最终会需要连接到一个StringBuffer，请修改你的实现方式，避免直接进行连接操作，应该采用创建一个临时对象来做这个操作.</li>
<li>当从输入的数据集中抽取出Strings的时候，尝试返回原数据的substring对象，而不是创建一个重复的对象。</li>
</ul>
<p>一个稍微激进点的做法是把所有多维的数据分解成1维的数组:</p>
<ul>
<li>一组int数据要比一组Integer对象要好很多。可以得知，两组1维数组要比一个2维数组更加的有效率。同样的，这个道理可以推广至其他原始数据类型。</li>
<li>如果你需要实现一个数组用来存放(Foo,Bar)的对象，尝试分解为Foo[]与Bar[]要比(Foo,Bar)好很多。(当然，为了某些好的API的设计，可以适当做一些妥协。但是在自己的代码内部，你应该多多使用分解后的容易。</li>
</ul>
<p>通常来说，需要避免创建更多的对象。更少的对象意味者更少的GC动作，GC会对用户体验有比较直接的影响。</p>
<h2 id="2)选择Static而不是Virtual">2)选择Static而不是Virtual</h2><p>如果你不需要访问一个对象的值域,请保证这个方法是static类型的,这样方法调用将快15%-20%。这是一个好的习惯，因为你可以从方法声明中得知调用无法改变这个对象的状态。</p>
<h2 id="3)常量声明为Static_Final">3)常量声明为Static Final</h2><p>先看下面这种声明的方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> intVal = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">static</span> String strVal = <span class="string">"Hello, world!"</span>;</span><br></pre></td></tr></table></figure></p>
<p>编译器会在类首次被使用到的时候，使用初始化<code>&lt;clinit&gt;</code>方法来初始化上面的值，之后访问的时候会需要先到它那里查找，然后才返回数据。我们可以使用static final来提升性能：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> intVal = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String strVal = <span class="string">"Hello, world!"</span>;</span><br></pre></td></tr></table></figure></p>
<p>这时再也不需要上面的那个方法来做多余的查找动作了。<br><strong> 所以，请尽可能的为常量声明为static final类型的。</strong></p>
<h2 id="4)避免内部的Getters/Setters">4)避免内部的Getters/Setters</h2><p>像C++等native language,通常使用getters(i = getCount())而不是直接访问变量(i = mCount).这是编写C++的一种优秀习惯，而且通常也被其他面向对象的语言所采用，例如C#与Java，因为编译器通常会做inline访问，而且你需要限制或者调试变量，你可以在任何时候在getter/setter里面添加代码。<br><strong>然而，在Android上，这是一个糟糕的写法</strong>。Virtual method的调用比起直接访问变量要耗费更多。那么合理的做法是：<strong>在面向对象的设计当中应该使用getter/setter，但是在类的内部你应该直接访问变量。</strong><br>没有<code>JIT(Just In Time Compiler)</code>时，直接访问变量的速度是调用getter的3倍。有JIT时,直接访问变量的速度是通过getter访问的7倍。<br>请注意，如果你使用<a href="http://developer.android.com/tools/help/proguard.html" target="_blank" rel="external">ProGuard</a>, 你可以获得同样的效果，因为ProGuard可以为你inline accessors.</p>
<h2 id="5)使用增强的For循环写法">5)使用增强的For循环写法</h2><p>请比较下面三种循环的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mSplat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo[] mArray = ...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mArray.length; ++i) &#123;</span><br><span class="line">        sum += mArray[i].mSplat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">one</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    Foo[] localArray = mArray;</span><br><span class="line">    <span class="keyword">int</span> len = localArray.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        sum += localArray[i].mSplat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">two</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Foo a : mArray) &#123;</span><br><span class="line">        sum += a.mSplat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>zero()是最慢的，因为JIT没有办法对它进行优化。</li>
<li>one()稍微快些。</li>
<li>two() 在没有做JIT时是最快的，可是如果经过JIT之后，与方法one()是差不多一样快的。它使用了增强的循环方法for-each。</li>
</ul>
<p>所以请尽量使用for-each的方法，但是对于ArrayList，请使用方法one()。</p>
<h2 id="6)使用包级访问而不是内部类的私有访问">6)使用包级访问而不是内部类的私有访问</h2><p>参考下面一段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">stuff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Foo.<span class="keyword">this</span>.doStuff(Foo.<span class="keyword">this</span>.mValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        mValue = <span class="number">27</span>;</span><br><span class="line">        in.stuff();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStuff</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Value is "</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里重要的是，我们定义了一个私有的内部类（Foo$Inner），它直接访问了外部类中的私有方法以及私有成员对象。这是合法的，这段代码也会如同预期一样打印出”Value is 27”。</p>
<p>问题是，VM因为Foo和Foo$Inner是不同的类，会认为在Foo$Inner中直接访问Foo类的私有成员是不合法的。即使Java语言允许内部类访问外部类的私有成员。为了去除这种差异，编译器会产生一些仿造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">int</span> Foo.access$<span class="number">100</span>(Foo foo) &#123;</span><br><span class="line">    <span class="keyword">return</span> foo.mValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">void</span> Foo.access$<span class="number">200</span>(Foo foo, <span class="keyword">int</span> value) &#123;</span><br><span class="line">    foo.doStuff(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当内部类需要访问外部类中的mValue成员或需要调用doStuff()函数时，它都会调用这些静态方法。这意味着，上面的代码可以归结为，通过accessor函数来访问成员变量。早些时候我们说过，通过accessor会比直接访问域要慢。所以，这是一个特定语言用法造成性能降低的例子。</p>
<p>如果你正在性能热区（hotspot:高频率、重复执行的代码段）使用像这样的代码，你可以把内部类需要访问的域和方法声明为包级访问，而不是私有访问权限。不幸的是，这意味着在相同包中的其他类也可以直接访问这些域，所以在公开的API中你不能这样做。</p>
<h2 id="7)避免使用float类型">7)避免使用float类型</h2><p>Android系统中float类型的数据存取速度是int类型的一半，尽量优先采用int类型。</p>
<h2 id="8)使用库函数">8)使用库函数</h2><p>尽量使用System.arraycopy()等一些封装好的库函数，它的效率是手动编写copy实现的9倍多。</p>
<p><strong> Tip: Also see Josh Bloch’s Effective Java, item 47. </strong></p>
<h2 id="9)谨慎使用native函数">9)谨慎使用native函数</h2><p>当你需要把已经存在的native code迁移到Android，请谨慎使用JNI。如果你要使用JNI,请学习<a href="http://developer.android.com/guide/practices/jni.html" target="_blank" rel="external">JNI Tips</a></p>
<h2 id="10)关于性能的误区">10)关于性能的误区</h2><p>在没有做JIT之前，使用一种确切的数据类型确实要比抽象的数据类型速度要更有效率。(例如，使用HashMap要比Map效率更高。) 有误传效率要高一倍，实际上只是6%左右。而且，在JIT之后，他们直接并没有大多差异。</p>
<h2 id="11)关于测量">11)关于测量</h2><p>上面文档中出现的数据是Android的实际运行效果。我们可以用<a href="http://developer.android.com/tools/debugging/debugging-tracing.html" target="_blank" rel="external">Traceview</a> 来测量，但是测量的数据是没有经过JIT优化的，所以实际的效果应该是要比测量的数据稍微好些。</p>
<p>关于如何测量与调试，还可以参考下面两篇文章：</p>
<ul>
<li><a href="http://developer.android.com/tools/debugging/debugging-tracing.html" target="_blank" rel="external">Profiling with Traceview and dmtracedump</a></li>
<li><a href="http://developer.android.com/tools/debugging/systrace.html" target="_blank" rel="external">Analysing Display and Performance with Systrace</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇文章主要是介绍了一些小细节的优化技巧，当这些小技巧综合使用起来的时候，对于整个App的性能提升还是有作用的，只是不能较大幅度的提升性能而已。选择合适的算法与数据结构才应该是你首要考虑的因素，在这篇文章中不会涉及这方面。你应该使用这篇文章中的小技巧作为平时写代码的习惯，这样能够提升代码的效率。</p>
<p>本文的原文为Google官方Training的性能优化部分，这一章节主要讲解的是高性能Android代码优化建议,建议所有Android应用开发者都仔细阅读这份文档，并将所提到的编码思想运用到实际的Android开发中。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/tags/Android/"/>
    
      <category term="MAT" scheme="http://androidperformance.com/tags/MAT/"/>
    
      <category term="Menory" scheme="http://androidperformance.com/tags/Menory/"/>
    
      <category term="Performance" scheme="http://androidperformance.com/tags/Performance/"/>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
      <category term="Menory" scheme="http://androidperformance.com/categories/Android/Menory/"/>
    
      <category term="Performance" scheme="http://androidperformance.com/categories/Android/Menory/Performance/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Nexus6 with Android M开启多窗口模式]]></title>
    <link href="http://androidperformance.com/2015/05/29/Nexus6-with-Android-M.html"/>
    <id>http://androidperformance.com/2015/05/29/Nexus6-with-Android-M.html</id>
    <published>2015-05-29T12:01:06.000Z</published>
    <updated>2015-07-20T03:33:03.000Z</updated>
    <content type="html"><![CDATA[<p>昨天的Google IO之后，Google放出了Android M Preview for Nexus6. 固件大家可以去Google的官网去下，下好了刷完之后，就可以体验一下最新的Android M了。下面是设置 里面的主界面和彩蛋界面:</p>
<a id="more"></a>
<p><img src="/images/nexus6/0.png" alt="主界面"></p>
<p><img src="/images/nexus6/1.png" alt="彩蛋"></p>
<h3 id="变化">变化</h3><ol>
<li>Android M给人最大的不一样就是其抽屉的变化：</li>
</ol>
<p><img src="/images/nexus6/2.png" alt="抽屉"></p>
<p>从图中可以看出,抽屉中的APP是使用字母进行索引的.最上面一排是最常用的的APP,目前是不可以定制的.</p>
<ol>
<li><p>另外一个感觉变化比较大的地方就是动画,文件夹动画和应用启动动画都变了,这个不好描述,大家回头可以自己去感受.</p>
</li>
<li><p>设置里面可以设置主题了,不过目前也就light和dark可以选择.</p>
</li>
</ol>
<p><img src="/images/nexus6/3.png" alt="模式选择"></p>
<h2 id="多窗口">多窗口</h2><p>Android M Preview官方固件里面默认是没有多窗口模式这个选项的.因为官方的固件是user版本的,而这个多窗口的模式是在userdebug中才能打开的. 所以必须要手动进行开启.</p>
<h3 id="刷入第三方Recovery">刷入第三方Recovery</h3><h4 id="1-_进入bootloader模式">1. 进入bootloader模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure>
<h4 id="2-_刷入twrp-img">2. 刷入twrp.img</h4><p>这个twrp是从官网下载的，下载速度略慢，我把它放到了百度网盘，方便大家去下载：<a href="http://pan.baidu.com/s/1eQ5ysE2" target="_blank" rel="external">twrp</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot flash recovery ~/Downloads/twrp-<span class="number">2.8</span>.6.0-shamu.img</span><br></pre></td></tr></table></figure>
<h4 id="3-_Mount_System">3. Mount System</h4><p>刷入recovery之后不用重启手机，直接进入recovery模式，进入mount，将system这一项前面的对勾选上。这一步是为了可以改system目录里面的值。</p>
<h4 id="4-_修改/system/build-prop">4. 修改/system/build.prop</h4><p>第三步结束后，使用adb devices查看是否可以看到手机。如果能正常看到手机，那么先进入shell：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br></pre></td></tr></table></figure>
<p>然后使用vi打开system/build.prop</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi system/build.prop</span><br></pre></td></tr></table></figure>
<p>找到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ro.build.type=user</span><br></pre></td></tr></table></figure>
<p>将其修改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ro.build.type=userdebug</span><br></pre></td></tr></table></figure>
<p>保存后退出shell，这时候执行adb reboot重启机器就可以看到在开发者选项中多了一项：</p>
<p><img src="/images/nexus6/4.png" alt="选择开启多窗口"></p>
<p>开启多窗口的方法是点击多任务按钮，选择一个任务窗口上面的三个框（选一个即可）<br>，第一个是在上面窗口，第二个是在下面的窗口，第三个是全屏。</p>
<p><img src="/images/nexus6/5.png" alt="多窗口位置选择"></p>
<p>然后就可以看到效果了：</p>
<p><img src="/images/nexus6/6.png" alt="多窗口效果"></p>
<h2 id="后记">后记</h2><p>说是多窗口，其实目前只支持双窗口。不过双窗口的窗口利用率其实并不高，多窗口就更加呵呵呵了。这个就看Google之后如何发挥这个了。</p>
<p>其实多窗口三星早就实现了。而且每个窗口还可以动态调整大小，不过这并没有什么卵用。测评中提到的也不多。可见多窗口现在其实还只是一个炫技的功能。至于使用的话，可能还得要多迭代几次才可以。</p>
<p>另外这篇文章的简书地址在此：<a href="http://www.jianshu.com/p/8bb7b44930e3" target="_blank" rel="external">Nexus6-with-Android-M开启多窗口模式</a> . 因为我写东西都是在简书上完成，然后才Copy到其他的地方，所以这里也给大家推荐一下简书吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>昨天的Google IO之后，Google放出了Android M Preview for Nexus6. 固件大家可以去Google的官网去下，下好了刷完之后，就可以体验一下最新的Android M了。下面是设置 里面的主界面和彩蛋界面:</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/tags/Android/"/>
    
      <category term="Nexus" scheme="http://androidperformance.com/tags/Nexus/"/>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[细说Java单例模式]]></title>
    <link href="http://androidperformance.com/2015/05/06/Java-Singleton.html"/>
    <id>http://androidperformance.com/2015/05/06/Java-Singleton.html</id>
    <published>2015-05-06T10:09:43.000Z</published>
    <updated>2015-08-05T12:28:14.000Z</updated>
    <content type="html"><![CDATA[<p>单例模式也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。本文就从单例模式的两种构建方式来带大家了解一下单例，最后介绍一种高级且简洁的单例模式。</p>
<a id="more"></a>
<h2 id="什么是单例模式">什么是单例模式</h2><blockquote>
<p><a href="http://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">单例模式</a>，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。</p>
</blockquote>
<p>中心原则就是：<strong>单例对象的类必须保证只有一个实例存在</strong></p>
<h2 id="单例模式的构建">单例模式的构建</h2><p>在java中主要有两种构建方式</p>
<ul>
<li>懒汉方式。指全局的单例实例在第一次被使用时构建。</li>
<li>饿汉方式。指全局的单例实例在类装载时构建。</li>
</ul>
<p>简单的说就是一个需要<em>延迟初始化</em>，一个则不需要。</p>
<p>比较简单的构建方式有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Private constructor suppresses   </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// default public constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式实现简单，实例在类装载时构建，如果想要实现一种实例在第一次被使用时构建应该怎么做？</p>
<p>有一种叫做<em>双重检查锁(double-checked locking)</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Private constructor suppresses </span></span><br><span class="line">    <span class="comment">// default public constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//thread safe and performance  promote </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//when more than two threads run into the first null check same time, to avoid instanced more than one time, it needs to be checked again.</span></span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此种方法只能用在JDK5及以后版本(注意 INSTANCE 被声明为 volatile)，之前的版本使用“双重检查锁”会发生非预期行为.</p>
<h2 id="另一种单例模式">另一种单例模式</h2><p>在第一条推荐阅读里提到了另一种实现单例的方式<em>lazy initialization holder class idiom</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Private constructor suppresses   </span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JVM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会执行类的初始化。在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化。相比其他实现方案（如double-checked locking等），该技术方案的实现代码较为简洁，并且在所有版本的编译器中都是可行的。</p>
<p>关于<em>static final Singleton INSTANCE</em>域的访问权限为什么时包级私有可以阅读:<a href="http://ifeve.com/initialization-on-demand-holder-idiom/" target="_blank" rel="external">Initialization On Demand Holder idiom的实现探讨</a></p>
<h2 id="使用枚举">使用枚举</h2><p>最后推荐实现最为简洁的一种方式: <strong>使用枚举</strong></p>
<p>代码极其简洁, 使用极其简单:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回顾一下前面集中单例的实现方式, 都只考虑了常规获取类对象的手段, 然而还可以通过序列化和反射机制获取对象.上面两种方式如果实现了序列化接口<em>Serializable</em>就必须重写<em>readResolve()</em>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使重写了 <em>readResolve()</em> 方法也会涉及某系域需要关键字 <em>transient</em> 的修饰, 具体讨论不再展开, 总之涉及序列化挺蛋疼. </p>
<p>关于防止反射暂时没有深入了解, 据了解: 因为反射的某些地方绕过了java机制的限制，private只在编译时进行权限的限制，但是在运行时是不存在这种权限的限制的, 此处仅供参考.</p>
<p>但是使用enum实现的单例自带防序列化与防反射功能, 详细参照枚举类反编译后代码(供参考)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">extends</span> <span class="title">Enum</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        Singleton asingleton[];</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        Singleton asingleton1[];</span><br><span class="line">        System.arraycopy(asingleton = ENUM$VALUES, <span class="number">0</span>, asingleton1 = <span class="keyword">new</span> Singleton[i = asingleton.length], <span class="number">0</span>, i);</span><br><span class="line">        <span class="keyword">return</span> asingleton1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">valueOf</span><span class="params">(String s)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Singleton)Enum.valueOf(singleton/Singleton, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Singleton(String s, <span class="keyword">int</span> i, Singleton singleton)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton ENUM$VALUES[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> Singleton(<span class="string">"INSTANCE"</span>, <span class="number">0</span>) ;</span><br><span class="line">        ENUM$VALUES = (<span class="keyword">new</span> Singleton[] &#123;</span><br><span class="line">            INSTANCE</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们实现的枚举都是继承了 <em>java.lang.Enum</em> 可以看出来单例的实现也是通过关键字 <em>static</em> 修饰的静态初始化块来实现.</p>
<p>那么为什么enum可以防御反射呢…很简单, 因为它是一个抽象类 <em>public abstract class Singleton extends Enum</em> 即使是反射机制也不能实例化了.</p>
<p>有为什么能防御序列化呢…这个要看java源码中对于对象序列化的处理.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">java.io.<span class="function">ObjectOutputStream</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject0</span><span class="params">(Object obj, <span class="keyword">boolean</span> unshared)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// remaining cases</span></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        writeString((String) obj, unshared);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">        writeArray(obj, desc, unshared);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">        writeEnum((Enum) obj, desc, unshared);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">        writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(cl.getName() + <span class="string">"\n"</span> + debugInfoStack.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(cl.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* Writes given enum constant to stream.</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeEnum</span><span class="params">(Enum en, ObjectStreamClass desc, <span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    bout.writeByte(TC_ENUM);</span><br><span class="line">    ObjectStreamClass sdesc = desc.getSuperDesc();</span><br><span class="line">    writeClassDesc((sdesc.forClass() == Enum.class) ? desc : sdesc, <span class="keyword">false</span>);</span><br><span class="line">    handles.assign(unshared ? <span class="keyword">null</span> : en);</span><br><span class="line">    writeString(en.name(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出enum在被序列化时时经过特殊处理的, 被序列化的仅仅是枚举的名字而已.所以可以猜测一下反序列的的代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> java.io.<span class="function">ObjectOutputStream</span><br><span class="line"><span class="keyword">private</span> Object <span class="title">readObject0</span><span class="params">(<span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (tc) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> TC_ENUM:</span><br><span class="line">        <span class="keyword">return</span> checkResolve(readEnum(unshared));</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Reads in and returns enum constant, or null if enum type is</span><br><span class="line"> * unresolvable.  Sets passHandle to enum constant's assigned handle.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Enum <span class="title">readEnum</span><span class="params">(<span class="keyword">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (cl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            en = Enum.valueOf(cl, name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> InvalidObjectException(</span><br><span class="line">                <span class="string">"enum constant "</span> + name + <span class="string">" does not exist in "</span> +</span><br><span class="line">                cl).initCause(ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!unshared) &#123;</span><br><span class="line">            handles.setObject(enumHandle, en);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> en;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反序列化也仅仅是通过name调用了方法 <em>Enum.valueOf(Class<t> enumType, String name)</t></em> 获取了一个枚举实例, 所以枚举也可以防止通过序列化产生新的单例.</p>
<p><strong> 友情建议: 在序列化枚举时要特别注意, 枚举的名称一定不能改变, 否则在反序列化时有可能会抛出异常!!!</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt;&gt; <span class="function">T <span class="title">valueOf</span><span class="params">(Class&lt;T&gt; enumType,</span><br><span class="line">                                            String name)</span> </span>&#123;</span><br><span class="line">    T result = enumType.enumConstantDirectory().get(name);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Name is null"</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">        <span class="string">"No enum constant "</span> + enumType.getCanonicalName() + <span class="string">"."</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>作者刘天昊，供职于人人网。Github主页：<a href="https://github.com/Popo-lth" target="_blank" rel="external">Popo-lth</a><br>本文Github地址：<a href="https://github.com/Popo-lth/Blog/blob/master/%E7%BB%86%E8%AF%B4%E5%8D%95%E4%BE%8B.md" target="_blank" rel="external">细说单例</a></p>
</blockquote>
<h2 id="推荐阅读:">推荐阅读:</h2><ol>
<li>Effective Java 第71条 慎用延迟初始化</li>
<li>Core Java 第一卷 14.5.8 Volatile 域</li>
<li><a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4" target="_blank" rel="external">JSL 17.4</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-jtp06197.html" target="_blank" rel="external">Java 理论与实践: 正确使用 Volatile 变量</a></li>
<li><a href="http://ifeve.com/double-checked-locking-with-delay-initialization/" target="_blank" rel="external">双重检查锁定与延迟初始化</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>单例模式也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。本文就从单例模式的两种构建方式来带大家了解一下单例，最后介绍一种高级且简洁的单例模式。</p>]]>
    
    </summary>
    
      <category term="Java" scheme="http://androidperformance.com/tags/Java/"/>
    
      <category term="Singleton" scheme="http://androidperformance.com/tags/Singleton/"/>
    
      <category term="Java" scheme="http://androidperformance.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android性能优化典范之Profile GPU Rendering]]></title>
    <link href="http://androidperformance.com/2015/04/19/Android-Performance-Patterns-4.html"/>
    <id>http://androidperformance.com/2015/04/19/Android-Performance-Patterns-4.html</id>
    <published>2015-04-19T07:53:31.000Z</published>
    <updated>2015-04-19T07:58:02.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>“If you can measure it, you can optimize it” is a common term in the computing world, and for Android’s rendering system, the same thing holds true. In order to optimize your pipeline to be more efficient for rendering, you need a tool to give you feedback on where the current perf problems lie.</p>
<p>And in this video, +Colt McAnlis walks you through an on-device tool that’s built for this exact reason. “Profile GPU Rendering” will help you understand the stages of the rendering pipeline, and also get a chance to see what portions of it might be taking too long, and what you can do about it for your application.</p>
</blockquote>
<h2 id="GPU_Profile工具">GPU Profile工具</h2><p>渲染性能问题往往是偷取你宝贵帧数的罪魁祸首,这种问题很容易产生,很容易出现,而且在一个非常方便的工具的帮助下,也非常容易去追踪. 使用Peofile GPU Rendering tool,你可以在手机上就可以看到究竟是什么导致你的应用程序出现卡顿,变慢的情况.</p>
<a id="more"></a>
<p>这个工具在设置-开发者选项-Profile GPU rendering选项,打开后选择on screen as bars:</p>
<p><img src="/images/performance-4/1.png" alt="Profile GPU rendering"></p>
<p>然后手机屏幕上就会出现三个颜色组成的小柱状图,以及一条绿线:</p>
<p><img src="/images/performance-4/2.png" alt="gpu工具"></p>
<p>这个工具会在屏幕上显示经过分析后的图形数据,最底部的图显示的是Navigation的相关信息,最上面显示的是Notification的相关信息,中间的图显示的是当前应用程序的图.</p>
<h2 id="使用GPU_Profile工具">使用GPU Profile工具</h2><p>当你的应用程序在运行时,你会看到一排柱状图在屏幕上,从左到右动态地显示,<strong>每一个垂直的柱状图代表一帧的渲染,越长的垂直柱状图表示这一帧需要渲染的时间越长</strong>.随着需要渲染的帧数越来越多,他们会堆积在一起,这样你就可以观察到这段时间帧率的变化.</p>
<h3 id="绿线">绿线</h3><p>下图中的绿线代表16ms,要确保一秒内打到60fps,你需要确保这些帧的每一条线都在绿色的16ms标记线之下.任何时候你看到一个竖线超过了绿色的标记现,你就会看到你的动画有卡顿现象产生.</p>
<p><img src="/images/performance-4/3.png" alt="绿线"></p>
<h3 id="柱状图">柱状图</h3><p>每一条柱状图都由三种颜色组成: 蓝-红-黄. 这些线直接和Android的渲染流水线和他实际运行帧数的时间关联:</p>
<p><img src="/images/performance-4/4.png" alt="柱状图"></p>
<ul>
<li><p>蓝色代表测量绘制的时间,或者说它代表需要多长时间去创建和更新你的DisplayList.在Android中,一个视图在可以实际的进行渲染之前,它必须被转换成GPU所熟悉的格式,简单来说就是几条绘图命令,复杂点的可能是你的自定义的View嵌入了自定义的Path. 一旦完成,结果会作为一个DisplayList对象被系统送入缓存,蓝色就是记录了需要花费多长时间在屏幕上更新视图(说白了就是执行每一个View的onDraw方法,创建或者更新每一个View的Display List对象).</p>
<p><img src="/images/performance-4/5.png" alt="Draw Phase"></p>
<p>当你看到蓝色的线很高的时候,<strong>有可能是因为你的一堆视图突然变得无效了(即需要重新绘制),或者你的几个自定义视图的onDraw函数过于复杂</strong>.</p>
<p><img src="/images/performance-4/6.png" alt="自定义视图"></p>
</li>
<li><p>红色代表执行的时间,这部分是Android进行2D渲染 Display List的时间,为了绘制到屏幕上,Android需要使用OpenGl ES的API接口来绘制Display List.这些API有效地将数据发送到GPU,最总在屏幕上显示出来.</p>
<p><img src="/images/performance-4/7.png" alt="红色"></p>
<p>记住绘制下图这样自定义的比较复杂的视图时,需要用到的OpenGl的绘制命令也会更复杂</p>
<p><img src="/images/performance-4/8.png" alt="自定义的复杂View"></p>
<p>当你看到红色的线非常高的时候,这些复杂的自定义View就是罪魁祸首:</p>
<p><img src="/images/performance-4/9.png" alt="Paste_Image.png"></p>
<p>值得一提的是,上面图中红色线较高的一种可能性是因为重新提交了视图而导致的.这些视图并不是失效的视图,但是有些时候发生了某些事,例如视图旋转,我们需要重新清理这个区域的视图,这样可能会影响这个视图下面的视图,因为这些视图都需要进行重新的绘制操作.</p>
</li>
<li><p>橙色部分表示的是处理时间,或者说是CPU告诉GPU渲染一帧的地方,这是一个阻塞调用,因为CPU会一直等待GPU发出接到命令的回复,如果柱状图很高,那就意味着你给GPU太多的工作,太多的负责视图需要OpenGL命令去绘制和处理.</p>
</li>
</ul>
<p>保持动画流畅的关键就在于让这些垂直的柱状条尽可能地保持在绿线下面,任何时候超过绿线,你就有可能丢失一帧的内容.</p>
<h3 id="总结">总结</h3><p>GPU Profile工具能够很好地帮助你找到渲染相关的问题,但是要修复这些问题就不是那么简单了. 你需要结合代码来具体分析,找到性能的瓶颈,并进行优化.</p>
<p>有时候你可以以这个为工具,让负责设计这个产品的人修改他的设计,以获得良好的用户体验.</p>
<h2 id="Perf_Matters">Perf Matters</h2><blockquote>
<p>keep calm, profile your code, and always remember, Perf Matters</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>“If you can measure it, you can optimize it” is a common term in the computing world, and for Android’s rendering system, the same thing holds true. In order to optimize your pipeline to be more efficient for rendering, you need a tool to give you feedback on where the current perf problems lie.</p>
<p>And in this video, +Colt McAnlis walks you through an on-device tool that’s built for this exact reason. “Profile GPU Rendering” will help you understand the stages of the rendering pipeline, and also get a chance to see what portions of it might be taking too long, and what you can do about it for your application.</p>
</blockquote>
<h2 id="GPU_Profile工具">GPU Profile工具</h2><p>渲染性能问题往往是偷取你宝贵帧数的罪魁祸首,这种问题很容易产生,很容易出现,而且在一个非常方便的工具的帮助下,也非常容易去追踪. 使用Peofile GPU Rendering tool,你可以在手机上就可以看到究竟是什么导致你的应用程序出现卡顿,变慢的情况.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/tags/Android/"/>
    
      <category term="MAT" scheme="http://androidperformance.com/tags/MAT/"/>
    
      <category term="Menory" scheme="http://androidperformance.com/tags/Menory/"/>
    
      <category term="Performance" scheme="http://androidperformance.com/tags/Performance/"/>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
      <category term="Menory" scheme="http://androidperformance.com/categories/Android/Menory/"/>
    
      <category term="Performance" scheme="http://androidperformance.com/categories/Android/Menory/Performance/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android性能优化典范之Understanding VSYNC]]></title>
    <link href="http://androidperformance.com/2015/04/19/Android-Performance-Patterns-3.html"/>
    <id>http://androidperformance.com/2015/04/19/Android-Performance-Patterns-3.html</id>
    <published>2015-04-19T07:47:25.000Z</published>
    <updated>2015-04-19T07:51:32.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>Unbeknown to most developers, there’s a simple hardware design that defines everything about how fast your application can draw things to the screen.</p>
<p>You may have heard the term VSYNC - VSYNC stands for vertical synchronization and it’s an event that happens every time your screen starts to refresh the content it wants to show you.</p>
<p>Effectively, VSYNC is the product of two components Refresh Rate (how fast the hardware can refresh the screen), and Frames Per Second (how fast the GPU can draw images), and in this video +Colt McAnlis walks through each of these topics, and discusses where VSYNC (and the 16ms rendering barrier) comes from, and why it’s critical to understand if you want a silky smooth application.</p>
</blockquote>
<h2 id="基本概念">基本概念</h2><p>想要开发一个高性能的应用程序,首先你得了解他的硬件工作原理,那么最好的办法就是去使用它,应用程序运行速度的快慢,很容易被人误解为硬件进程的控制问题,然而这最主要的根源在于渲染性能.如果你想要提高你应用程序的渲染性能,你就必须知道什么是<strong>VSYNC</strong>.</p>
<a id="more"></a>
<p>在了解<strong>VSYNC</strong>之前,我们需要了解两个概念:</p>
<h3 id="刷新率">刷新率</h3><p>刷新率代表屏幕在一秒内刷新屏幕的次数,这个值用赫兹来表示,取决于硬件的固定参数. 这个值一般是60Hz,即每16.66ms刷新一次屏幕.</p>
<p><img src="/images/performance-3/1.png" alt="刷新率"></p>
<h3 id="帧速率">帧速率</h3><p>帧速率代表了GPU在一秒内绘制操作的帧数,比如30fps/60fps.在这种情况下,高点的帧速率总是好的.</p>
<p><img src="/images/performance-3/2.png" alt="帧速率"></p>
<h2 id="工作原理">工作原理</h2><p>刷新率和帧速率需要协同工作,才能让你的应用程序的内容显示到屏幕上,GPU会获取图像数据进行绘制,然后硬件负责把内容呈现到屏幕上,这将在你的应用程序的生命周期中周而复始地发生.下面的图中每一个竖行代表了一帧的绘制和呈现工作.</p>
<p><img src="/images/performance-3/3.png" alt="协同工作"></p>
<p>不幸的是,刷新率和帧速率并不是总能够保持相同的节奏:</p>
<ul>
<li><p>如果帧速率实际上比刷新率快,那么就会出现一些视觉上的问题,下面的图中可以看到,当帧速率在100fps而刷新率只有75Hz的时候,GPU所渲染的图像并非全都被显示出来.</p>
<p><img src="/images/performance-3/4.png" alt="帧速率比刷新率快的情况"></p>
<p>举个例子, 你拍了一张照片,然后旋转5度再拍一张照片, 将两种图片的中间剪开并拼接在一起:</p>
<p><img src="/images/performance-3/5.png" alt="拍两张照片"></p>
<p><img src="/images/performance-3/6.png" alt="剪贴在一起"><br>这两张图有相似之处,但是上面和下面部分有明显的区别,这就叫Tearing(撕裂),是刷新率和帧速率不一致的结果.</p>
<p>上面的原因是因为,当你的显卡正在使用,一个内存区正在写入帧数据(用来显示一帧的一个Buffer),从顶部开始, 新的一帧覆盖前一帧,并立刻输出一行内容. 现在,当屏幕开始刷新时,实际上并不知道缓冲区是什么状态(即不知道缓冲区中的一帧是否绘制完毕,即存在只绘制了一半的情况,另一半还是之前的那帧),因此它从GPU中抓住的帧肯可能并不是完全完整的.</p>
<p><img src="/images/performance-3/7.png" alt="图像撕裂"></p>
<p>目前Android的双缓冲(或者三缓冲/四缓冲), 这是非常有效的,当GPU将一帧写入一个被成为后缓冲的存储器, 而存储器中的次级区域被称为帧缓冲,当写入下一帧时,它会开始填充后缓冲,而帧缓冲保持不变,现在我们刷新屏幕,它将使用帧缓冲(事先已经绘制好),而不是正在处于绘制状态的后缓冲, 这就是VSYNC的作用.如果在屏幕刷新中,VSYNC,即垂直同步,将会在让从后缓冲到帧缓冲的拷贝过程保持同样的复制操作:</p>
<p><img src="/images/performance-3/8.png" alt="Vsync"></p>
<p>GPU的频率比屏幕刷新率高是正常的,因为你的GPU刷新会比屏幕刷新快,在这种情况下,当屏幕刷新成功,你的GPU将会等待VSYNC信号,直到下一个VSYNC信号到来时(即屏幕刷新时),这时你的帧速率就可以达到设备的刷新率上限. 当然这只是理想情况, 当fps达到60的时候,GPU需要在16.66ms内准备好一帧,这对应用程序的要求是非常高的.更不用说100fps了…</p>
</li>
<li><p>屏幕刷新率比帧速率快的情况<br>如果屏幕刷新率比帧速率快,屏幕会在两帧中显示同一个画面,当这种断断续续的情况发生时,你就遇到麻烦了.比如你的帧速率比屏幕刷新率高的时候,用户看到的是非常流畅的画面, 但是帧速率降下来的时候(GPU绘制太多东西的时候),用户将会很明显地察觉到动画卡住了或者掉帧,然后又恢复了流畅.这通常会被描述为闪屏, 跳帧,延迟.</p>
<p><img src="/images/performance-3/9.png" alt="屏幕刷新率比帧速率快"></p>
<p>你的应用程序应该避免这些帧率突降的情况.以确保GPU迅速获取数据,并在屏幕再次刷新之前写录内容.</p>
</li>
</ul>
<h2 id="Perf_Matters">Perf Matters</h2><blockquote>
<p>keep calm, profile your code, and always remember, Perf Matters</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>Unbeknown to most developers, there’s a simple hardware design that defines everything about how fast your application can draw things to the screen.</p>
<p>You may have heard the term VSYNC - VSYNC stands for vertical synchronization and it’s an event that happens every time your screen starts to refresh the content it wants to show you.</p>
<p>Effectively, VSYNC is the product of two components Refresh Rate (how fast the hardware can refresh the screen), and Frames Per Second (how fast the GPU can draw images), and in this video +Colt McAnlis walks through each of these topics, and discusses where VSYNC (and the 16ms rendering barrier) comes from, and why it’s critical to understand if you want a silky smooth application.</p>
</blockquote>
<h2 id="基本概念">基本概念</h2><p>想要开发一个高性能的应用程序,首先你得了解他的硬件工作原理,那么最好的办法就是去使用它,应用程序运行速度的快慢,很容易被人误解为硬件进程的控制问题,然而这最主要的根源在于渲染性能.如果你想要提高你应用程序的渲染性能,你就必须知道什么是<strong>VSYNC</strong>.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/tags/Android/"/>
    
      <category term="MAT" scheme="http://androidperformance.com/tags/MAT/"/>
    
      <category term="Menory" scheme="http://androidperformance.com/tags/Menory/"/>
    
      <category term="Performance" scheme="http://androidperformance.com/tags/Performance/"/>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
      <category term="Menory" scheme="http://androidperformance.com/categories/Android/Menory/"/>
    
      <category term="Performance" scheme="http://androidperformance.com/categories/Android/Menory/Performance/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android性能优化典范之Understanding Overdraw]]></title>
    <link href="http://androidperformance.com/2015/04/19/Android-Performance-Patterns-2.html"/>
    <id>http://androidperformance.com/2015/04/19/Android-Performance-Patterns-2.html</id>
    <published>2015-04-19T07:38:48.000Z</published>
    <updated>2015-12-17T07:34:37.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>One of the most problematic performance problems on Android is the easiest to create; thankfully, it’s also easy to fix.</p>
<p><strong>OVERDRAW</strong> is a term used to describe how many times a pixel has been re-drawn in a single frame of rendering. It’s a troublesome issue, because in most cases, pixels that are overdrawn do not end up contributing to the final rendered image. As such, it amounts to wasted work for your GPU and CPU. </p>
<p>Fixing overdraw has everything to do with using the available on-device tools, like Show GPU Overdraw, and then adjusting your view hierarchy in order to reduce areas where it may be occurring.</p>
</blockquote>
<h2 id="OverDraw概念">OverDraw概念</h2><p>视频开头作者举了一个例子，说如果你是一个粉刷匠，你应该会知道，给墙壁粉刷是一件工作量非常大的工作，而且如果你需要重新粉刷一遍的话(比如对颜色不满意),那么第一次的粉刷就白干了. 同样的道理,如果你的应用程序中出现了过度绘制问题,那么你之前所做的事情也就白费了.如果你想兼顾高性能和完美的设计,那么你的程序可能会出现一个性能问题:<strong>OverDraw</strong>!</p>
<p><strong>OverDraw</strong>是一个术语, 它表示某些组件在屏幕上的一个像素点的绘制超过1次.如下面的图所示,我们有一堆重叠的卡片,被用户激活的卡片在最上面,而那些没有激活的卡片在下面,这意味着我们画大力气绘制的那些卡片,基本都是不可见的.问题就在于次,我们像素渲染的并不全是用户最后能看打的部分, 这是在浪费GPU的时间!</p>
<a id="more"></a>
<p><img src="/images/performance-2/1.png" alt="OverDraw"></p>
<p>目前流行的一些布局是一把双刃剑,带给我们漂亮的画面的同时,也带来了很大的麻烦.为了最大限度地提高应用程序的性能,你得减少<strong>OverDraw!</strong></p>
<p><img src="/images/performance-2/2.png" alt="性能和界面"></p>
<h2 id="追踪OverDraw">追踪OverDraw</h2><p>Android手机中提供了查看OverDraw情况的工具,在设置-开发者选项中,找到打开”Show GPU OverDraw”按钮即可:</p>
<p><img src="/images/performance-2/3.png" alt="Show GPU OverDraw"></p>
<p>Android会使用不同深浅的颜色来表示OverDraw的程序,没有OverDraw的时候, 你看到的是它本来的颜色,其他颜色表示不同的过度绘制程序:</p>
<ul>
<li>蓝色: 1倍过度绘制,即一个像素点绘制了2次</li>
<li>绿色:2倍过度绘制,即一个像素点绘制了3次</li>
<li>浅红色:3倍过度绘制,即一个像素点绘制了4次</li>
<li>深红色:4倍过度绘制及以上,即一个像素点绘制了5次及以上</li>
</ul>
<p><img src="/images/performance-2/4.png" alt="OverDraw"></p>
<p>你的应用程序的目标应该是尽可能地减少过度绘制,即更多的蓝色色块而不是红色色块:</p>
<p><img src="/images/performance-2/5.png" alt="Good and Bad"></p>
<h2 id="OverDraw的根源">OverDraw的根源</h2><p>虽然OverDraw很大程序上来自于你的视图互相重叠的问题,但是各位开发者更需要注意的是不必要的背景重叠.</p>
<p><img src="/images/performance-2/6.png" alt="Bad"></p>
<p>比如在一个应用程序中,你的所有的View都有背景的话,就会看起来像第一张图中那样,而在去除这些不必要的背景之后(指的是Window的默认背景,Layout的背景,文字以及图片的可能存在的背景),效果就像第二张图那样,基本没有过度绘制的情况.</p>
<p><img src="/images/performance-2/7.png" alt="去掉不必要的背景"></p>
<p>比如去除Window的默认背景:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">this</span><span class="class">.getWindow</span>()<span class="class">.setBackgroundDrawableResource</span>(<span class="tag">android</span><span class="class">.R</span><span class="class">.color</span><span class="class">.transparent</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="Perf_Matters">Perf Matters</h2><blockquote>
<p>keep calm, profile your code, and always remember, Perf Matters</p>
</blockquote>
<h2 id="附录">附录</h2><p>关于过度绘制及其优化,我博客有两篇文章专门介绍:</p>
<ul>
<li><a href="http://androidperformance.com/2014/10/20/android-performance-optimization-overdraw-1.html">Android过度绘制优化-基础篇</a></li>
<li><a href="http://androidperformance.com/2015/01/13/android-performance-optimization-overdraw-2.html">Android过度绘制优化-实战篇</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>One of the most problematic performance problems on Android is the easiest to create; thankfully, it’s also easy to fix.</p>
<p><strong>OVERDRAW</strong> is a term used to describe how many times a pixel has been re-drawn in a single frame of rendering. It’s a troublesome issue, because in most cases, pixels that are overdrawn do not end up contributing to the final rendered image. As such, it amounts to wasted work for your GPU and CPU. </p>
<p>Fixing overdraw has everything to do with using the available on-device tools, like Show GPU Overdraw, and then adjusting your view hierarchy in order to reduce areas where it may be occurring.</p>
</blockquote>
<h2 id="OverDraw概念">OverDraw概念</h2><p>视频开头作者举了一个例子，说如果你是一个粉刷匠，你应该会知道，给墙壁粉刷是一件工作量非常大的工作，而且如果你需要重新粉刷一遍的话(比如对颜色不满意),那么第一次的粉刷就白干了. 同样的道理,如果你的应用程序中出现了过度绘制问题,那么你之前所做的事情也就白费了.如果你想兼顾高性能和完美的设计,那么你的程序可能会出现一个性能问题:<strong>OverDraw</strong>!</p>
<p><strong>OverDraw</strong>是一个术语, 它表示某些组件在屏幕上的一个像素点的绘制超过1次.如下面的图所示,我们有一堆重叠的卡片,被用户激活的卡片在最上面,而那些没有激活的卡片在下面,这意味着我们画大力气绘制的那些卡片,基本都是不可见的.问题就在于次,我们像素渲染的并不全是用户最后能看打的部分, 这是在浪费GPU的时间!</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/tags/Android/"/>
    
      <category term="MAT" scheme="http://androidperformance.com/tags/MAT/"/>
    
      <category term="Menory" scheme="http://androidperformance.com/tags/Menory/"/>
    
      <category term="Performance" scheme="http://androidperformance.com/tags/Performance/"/>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
      <category term="Menory" scheme="http://androidperformance.com/categories/Android/Menory/"/>
    
      <category term="Performance" scheme="http://androidperformance.com/categories/Android/Menory/Performance/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android性能优化典范之Render Performance]]></title>
    <link href="http://androidperformance.com/2015/04/19/Android-Performance-Patterns-1.html"/>
    <id>http://androidperformance.com/2015/04/19/Android-Performance-Patterns-1.html</id>
    <published>2015-04-19T07:26:47.000Z</published>
    <updated>2015-04-19T07:38:36.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>Rendering performance is all about how fast you can draw your activity, and get it updated on the screen. Success here means your users feeling like your application is smooth and responsive, which means that you’ve got to get all your logic completed, <em>and</em> all your rendering done in 16ms or less, each and every frame. But that might be a bit more difficult than you think.</p>
<p>In this video, +Colt McAnlis takes a look at what “rendering performance” means to developers, alongside some of the most common pitfalls that are ran into; and let’s not forget the important stuff: the tools that help you track down, and fix these issues before they become large problems.</p>
</blockquote>
<h2 id="Android渲染知识">Android渲染知识</h2><p>当你觉得自己开发了一个改变世界的应用的时候，你的用户可能并不会这么认为，他们认为你的应用又慢又卡，达不到他们所期望的那种顺滑，更谈不上改变这该死的世界了，回收站走你！等等！明明我这个应用在我的Nexus5上非常顺滑啊？你咋能说又慢又卡呢？如果你对Android的碎片化有一定了解的话，你就应该知道，很多低配置的手机并不像Nexus5那样有强大的处理器和GPU，以及没有被怎么污染的原生系统。</p>
<p>如果有大量的用户投诉说你的应用又卡又慢的时候，不要总是抱怨用户的低端手机，有时候问题就出在你的应用本身，也就意味着你的Android存在比较严重的渲染性能问题。只有真正了解问题发生的根源，才能有效的解决问题。所以了解Android渲染相关的知识，是一个Android开发者必不可少的知识。</p>
<a id="more"></a>
<h2 id="设计与性能">设计与性能</h2><p>渲染问题是你建立一个应用程序是最经常碰到的问题，一方面，设计师希望展现给用户一个超自然的体验，另一方面，这些华丽的动画和视图并不能在所有的Android手机上都流畅地运行。所以这就是问题所在。</p>
<p><img src="/images/performance-1/1.png" alt="Design vs Performance"></p>
<h2 id="绘制原理">绘制原理</h2><p>Android系统每16ms都会重新绘制一次你的Activity，也就是说，你的逻辑控制画面更新要保证最多16ms一帧才能每秒达到60帧（至于为什么是60帧，这个后面会有一个专题来讲解这个）。如下图，每一帧都在16ms内绘制完成，此时的世界是顺滑的。</p>
<p><img src="/images/performance-1/2.png" alt="Draw Good]("></p>
<p>但是如果你的应用程序没有在16ms内完成这一帧的绘制，假设你花费了24ms来绘制这一帧，那么就会出现我们称之为<strong>掉帧</strong>的情况，世界变得有延迟了。如下图：</p>
<p><img src="/images/performance-1/3.png" alt="Draw Bad](]("></p>
<p>系统准备将新的一帧绘制到屏幕上，但是这一帧并没有准备好，所有就不会有绘制操作，画面也就不会刷新。反馈到用户身上，就是用户盯着同一张图看了32ms而不是16ms，也就是说掉帧发生了。</p>
<h2 id="掉帧">掉帧</h2><p>掉帧是用户体验中一个非常核心的问题，用户将很容易察觉到由于掉帧而产生的卡顿感，如果此时用户正在与系统进行交互，比如滑动列表，或者正在打字，那么卡顿感是非常明显的。用户会马上对你的应用进行吐槽，下一步工作肯定是回收站走你！所以弄清楚掉帧的原因是非常重要的。</p>
<p>不过蛋疼的是，引起掉帧发生的原因非常多，比如：</p>
<ul>
<li><strong>你花了太多的时间重新绘制你视图中的大部分东西，这样非常浪费CPU周期</strong><br><img src="/images/performance-1/4.png" alt="Too Much View](]("></li>
<li><strong>你有太多的对象堆叠到了一起，你在绘制用户看不到的对象上花费了太多的时间</strong><br><img src="/images/performance-1/5.png" alt="Draw Hidden View](]("></li>
<li><strong>你有一大堆的动画重复了一遍又一遍，导致CPU和GPU组件的大量浪费</strong><br><img src="/images/performance-1/6.png" alt="Too Much Animations](]("></li>
</ul>
<h2 id="检测和解决">检测和解决</h2><p>检测和解决这些问题很大程度上依赖于你的应用程序架构，但是幸运的是，我们有很多开发者工具来协助我们发现和解决这些问题，有些工具甚至能追踪到具体出错的代码行数或者UI控件，这些工具包括但不限于：</p>
<ul>
<li><h4 id="Hierarchy_View">Hierarchy View</h4><p><img src="/images/performance-1/7.png" alt="Hierarchy View](]("><br>你可以使用Hierarchy View 来查看你的View是否过于复杂，如果是，那么说明你有很多时间没有利用。并且浪费了许多时间进行重绘。<br>Hierarchy View 位于Android Device Monitor 中，Android Device Monitor在Eclipse和Android Studio中都有有对应的入口，依次选则Window-Open Perspective-Hierarchy View即可打开Hierarchy View视图。 Hierarchy View视图虽然比较简单，但是非常有效。花费一点了解这个工具每一个细节，对于以后排查问题来说都是事半功倍。关于Hierarchy View视图的用法，会有更详细的单独的教程来讲解。</p>
</li>
<li><h4 id="On-Device_Tools_–_Profile_GPU_Rendering_、Show_GPU_Overdraw、GPU_View_Updates">On-Device Tools – Profile GPU Rendering 、Show GPU Overdraw、GPU View Updates</h4><p><img src="/images/performance-1/8.png" alt="On-Device Tools](]("></p>
</li>
</ul>
<p>这三个选项在设置-辅助功能- 开发者选项中，默认都是关闭的。Profile GPU Rendering 和 GPU Overdraw比较重要，所以系列视频后面会有专门的专题会讲解，这里简单介绍一下GPU View Updates。GPU View Updates的作用是使用GPU进行绘图时闪烁显示窗口中的视图。随着android版本的更新，越来越多的绘制操作能使用GPU来完成，详见<a href="http://developer.android.com/guide/topics/graphics/hardware-accel.html" target="_blank" rel="external">http://developer.android.com/guide/topics/graphics/hardware-accel.html</a>，而这个工具打开之后，使用GPU绘制的区域会用红色来标注，而没有红色标注的区域，则是使用CPU绘制的。这个选项也可以用来查看redraw的区域大小。</p>
<ul>
<li><h4 id="TraceView">TraceView</h4></li>
</ul>
<p><img src="/images/performance-1/9.png" alt="TraceView](]("></p>
<p>TraceView是一个很棒的检查是否掉帧的工具，视频中没有对此工具进行介绍，但是这个工具非常的重要，他可以找到你代码中花费时间的地方，精确到每一个函数，不论这个函数是你应用程序中的还是系统函数。另外在Android Studio中，TraceView得到了改进，其视图能非常直观的显示出每一帧所消耗的时间，函数像倒金字塔一般展现在面前，我们可以很容易地看出掉帧的地方以及那一帧里面所有的函数调用情况。鉴于此工具非常实用，所有会有更详细的单独的教程来讲解。</p>
<h2 id="Perf_Matters">Perf Matters</h2><blockquote>
<p>keep calm, profile your code, and always remember, Perf Matters</p>
</blockquote>
<h2 id="总结">总结</h2><p>这是这个系列视频的第一个视频，从内容上来看，是从一个大的角度来看Render Performance，简单地讲述了一下Render Performance基本的概念，出现的原因以及排查的工具。在发现问题–定位问题–解决问题的流程上属于发现问题–定位问题，解决问题则基本没有提到。这也基本符合这一系列视频的基调：即着重于发现问题(使用工具发现问题、挖掘问题出现的原理和原因)和定位问题(使用工具定位)，如何解决问题则需要自己通过实战去进行锻炼，毕竟这种问题并没有一个通用的解决方法，每个应用都有每个应用自己的问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>Rendering performance is all about how fast you can draw your activity, and get it updated on the screen. Success here means your users feeling like your application is smooth and responsive, which means that you’ve got to get all your logic completed, <em>and</em> all your rendering done in 16ms or less, each and every frame. But that might be a bit more difficult than you think.</p>
<p>In this video, +Colt McAnlis takes a look at what “rendering performance” means to developers, alongside some of the most common pitfalls that are ran into; and let’s not forget the important stuff: the tools that help you track down, and fix these issues before they become large problems.</p>
</blockquote>
<h2 id="Android渲染知识">Android渲染知识</h2><p>当你觉得自己开发了一个改变世界的应用的时候，你的用户可能并不会这么认为，他们认为你的应用又慢又卡，达不到他们所期望的那种顺滑，更谈不上改变这该死的世界了，回收站走你！等等！明明我这个应用在我的Nexus5上非常顺滑啊？你咋能说又慢又卡呢？如果你对Android的碎片化有一定了解的话，你就应该知道，很多低配置的手机并不像Nexus5那样有强大的处理器和GPU，以及没有被怎么污染的原生系统。</p>
<p>如果有大量的用户投诉说你的应用又卡又慢的时候，不要总是抱怨用户的低端手机，有时候问题就出在你的应用本身，也就意味着你的Android存在比较严重的渲染性能问题。只有真正了解问题发生的根源，才能有效的解决问题。所以了解Android渲染相关的知识，是一个Android开发者必不可少的知识。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/tags/Android/"/>
    
      <category term="MAT" scheme="http://androidperformance.com/tags/MAT/"/>
    
      <category term="Menory" scheme="http://androidperformance.com/tags/Menory/"/>
    
      <category term="Performance" scheme="http://androidperformance.com/tags/Performance/"/>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
      <category term="Menory" scheme="http://androidperformance.com/categories/Android/Menory/"/>
    
      <category term="Performance" scheme="http://androidperformance.com/categories/Android/Menory/Performance/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android性能优化典范综述]]></title>
    <link href="http://androidperformance.com/2015/04/19/Android-Performance-Patterns.html"/>
    <id>http://androidperformance.com/2015/04/19/Android-Performance-Patterns.html</id>
    <published>2015-04-19T07:20:35.000Z</published>
    <updated>2015-04-19T07:25:41.000Z</updated>
    <content type="html"><![CDATA[<p>2015年1月6日，Google官方发布了一系列关于Android性能优化的小视频，将其命名为Android Performance Patterns，这一些列视频放在<a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE" target="_blank" rel="external">YouTube</a>上，观看的话需要科学地上网。</p>
<p><img src="/images/performance-0/1.jpg" alt="Android性能优化典范"></p>
<p>官方简介：</p>
<blockquote>
<p>Android Performance Patterns is a collection of videos focused entirely on helping developers write faster, more performant Android Applications. On one side, it’s about peeling back the layers of the Android System, and exposing how things are working under the hood. On the other side, it’s about teaching you how the tools work, and what to look for in order to extract the right perf out of your app.<br>But at the end of the day, Android Performance Patterns is all giving you the right resources, at the right time to help make the fastest, smoothest, most awesome experience for your users. And that’s the whole point, right?</p>
</blockquote>
<p>总之就是一系列讲解Android性能相关的视频。这些小视频的时间非常短，在3-5分钟之内，主讲人的英文语速也非常快，初期这些视频没有翻译的时候，着实考验了一把听力。好消息是现在这些视频已经都有中英文字幕了。</p>
<p>这些视频的时间虽然很短，但是信息量却非常大，有些他一句话带过的内容，我们却需要花费很多的时间去研究他的原理，或者研究一个调试工具如何使用。也就是说，这一系列视频并没有真正教你如何去优化你的应用，而是告诉你关于Android性能优化你需要知道的知识，这样你去优化你的Android应用的时候，<strong>知道该用什么工具，该采取什么样的步骤，需要达到什么样的目标。</strong></p>
<a id="more"></a>
<p>由于我最近也在研究Android性能优化相关的课题，这个视频第一时间出来的时候我就看了好几遍，所以一早就有将这一系列视频翻译成中文的想法。后来看了几遍之后，我发现仅仅翻译成中文其实意义不大，他所讲述的每一个知识点，都是可以写成一篇博文甚至好几篇博文的，所以就有了这一系列文章的出现。</p>
<p>每一篇文章中，我都会先将视频中涉及到的知识点列出来，然后一一进行讲解。有些调试工具由于篇幅原因，可能会写到单独的博文中。</p>
<p>另外催生我写这一系列文章的是胡凯，他的博客 <a href="http://hukai.me/android-performance-patterns" target="_blank" rel="external">http://hukai.me/android-performance-patterns</a> 第一时间就将这一些列视频的内容翻译成了中文，优美的排版加上过硬的翻译，让这篇博文被广泛传播，备受好评。同时他也是github上 <a href="https://github.com/kesenhoo/android-training-course-in-chinese" target="_blank" rel="external">android-training-course-in-chinese</a> 项目的发起人，他的Github主页：<a href="https://github.com/kesenhoo" target="_blank" rel="external">https://github.com/kesenhoo</a>。他对于分享的热情我非常敬佩。如果你并非是Android应用开发者或者对技术细节不感兴趣的话，直接看他的那篇Android性能优化典范即可，看完之后你会对这一些列视频有一个大概的认识。</p>
<p>下面是关于Android性能优化典范这一些列视频的一些资源信息：</p>
<ul>
<li>YouTube主页：<a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE" target="_blank" rel="external">Android Performance Patterns</a></li>
<li>作者Google+主页：</li>
<li>Android Performance Patterns的Google+社群：</li>
</ul>
<p>OK，Let us start！！！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>2015年1月6日，Google官方发布了一系列关于Android性能优化的小视频，将其命名为Android Performance Patterns，这一些列视频放在<a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE">YouTube</a>上，观看的话需要科学地上网。</p>
<p><img src="/images/performance-0/1.jpg" alt="Android性能优化典范"></p>
<p>官方简介：</p>
<blockquote>
<p>Android Performance Patterns is a collection of videos focused entirely on helping developers write faster, more performant Android Applications. On one side, it’s about peeling back the layers of the Android System, and exposing how things are working under the hood. On the other side, it’s about teaching you how the tools work, and what to look for in order to extract the right perf out of your app.<br>But at the end of the day, Android Performance Patterns is all giving you the right resources, at the right time to help make the fastest, smoothest, most awesome experience for your users. And that’s the whole point, right?</p>
</blockquote>
<p>总之就是一系列讲解Android性能相关的视频。这些小视频的时间非常短，在3-5分钟之内，主讲人的英文语速也非常快，初期这些视频没有翻译的时候，着实考验了一把听力。好消息是现在这些视频已经都有中英文字幕了。</p>
<p>这些视频的时间虽然很短，但是信息量却非常大，有些他一句话带过的内容，我们却需要花费很多的时间去研究他的原理，或者研究一个调试工具如何使用。也就是说，这一系列视频并没有真正教你如何去优化你的应用，而是告诉你关于Android性能优化你需要知道的知识，这样你去优化你的Android应用的时候，<strong>知道该用什么工具，该采取什么样的步骤，需要达到什么样的目标。</strong></p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/tags/Android/"/>
    
      <category term="MAT" scheme="http://androidperformance.com/tags/MAT/"/>
    
      <category term="Menory" scheme="http://androidperformance.com/tags/Menory/"/>
    
      <category term="Performance" scheme="http://androidperformance.com/tags/Performance/"/>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
      <category term="Menory" scheme="http://androidperformance.com/categories/Android/Menory/"/>
    
      <category term="Performance" scheme="http://androidperformance.com/categories/Android/Menory/Performance/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android内存优化之三：打开MAT中的Bitmap原图]]></title>
    <link href="http://androidperformance.com/2015/04/11/AndroidMemory-Open-Bitmap-Object-In-MAT.html"/>
    <id>http://androidperformance.com/2015/04/11/AndroidMemory-Open-Bitmap-Object-In-MAT.html</id>
    <published>2015-04-11T10:41:32.000Z</published>
    <updated>2015-07-20T03:42:19.000Z</updated>
    <content type="html"><![CDATA[<p>在使用MAT查看应用程序内存使用情况的时候,我们经常会碰到Bitmap对象以及BitmapDrawable$BitmapState对象,而且在内存使用上,Bitmap所占用的内存占大多数.在这样的情况下, Bitmap所造成的内存泄露尤其严重, 需要及时发现并且及时处理.在这样的需求下, 当我们在MAT中发现和图片相关的内存泄露的时候, 如果能知道是那一张图片,对分析问题会有很大的帮助.</p>
<p>本文就介绍如何将MAT中的Bitmap数组对象还原成一张图片。</p>
<a id="more"></a>
<p>Bitmap对象如图:</p>
<p><img src="/images/MAT_OpenBitmap/Image_1.png" alt="Bitmap对象"></p>
<h2 id="导出Bitmap原始数据">导出Bitmap原始数据</h2><p>在MAT中打开Dominator Tree视图 , 选择一个Bitmap对象 , 查看此时右边的Inspector窗口,内容如下图: </p>
<p><img src="/images/MAT_OpenBitmap/Image_2.png" alt="image"></p>
<p>这个视图中,可以看到这个Bitmap的一些基本的信息: mBuffer, mHeight, mWidth , mNativeBitmap等, 宽和高的值我们一会需要用的到 . </p>
<p>mBuffer的定义在Bitmap.java中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Backing buffer for the Bitmap.</span><br><span class="line"> * Made public for quick access from drawing methods -- do NOT modify</span><br><span class="line"> * from outside this class</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@hide</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="annotation">@SuppressWarnings</span>(<span class="string">"UnusedDeclaration"</span>) <span class="comment">// native code only</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] mBuffer;</span><br></pre></td></tr></table></figure>
<p>其值是保存在byte数组中的, 我们需要的就是这个byte数组中的内容. 在Inspector窗口的mBuffer这一栏或者Dominator Tree视图的Bitmap这一栏点开下一级,都可以看到这个byte数组的内容. 鼠标右键选择Copy –&gt;Save Value To File. 弹出如下对话框:</p>
<p><img src="/images/MAT_OpenBitmap/Image_3.png" alt="image"></p>
<p>选择存储路径和文件名,这里需要注意的是,<strong>文件名一定要以 .data为后缀</strong>,否则无法正常使用,切记.</p>
<h2 id="打开原始资源数据">打开原始资源数据</h2><h3 id="Linux">Linux</h3><p>这时需要借助Linux上强大的图片应用:GIMP,没安装的可以去安装一下. 安装好之后, 打开GIMP,选择文件-打开.选择我们上一步导出的.data文件(比如image.data),然后会出现如下图的属性框:</p>
<p><img src="/images/MAT_OpenBitmap/Image_4.png" alt="image"></p>
<p>图像类型这一栏选择RGB Alpha, 宽度和高度必填, 其值可以在MAT中查看到,第一步的时候有说到这个值的位置, 其他的选择默认即可,然后点击打开. GIMP就会把这个文件打开.</p>
<h3 id="Mac_&amp;&amp;_Windows">Mac &amp;&amp; Windows</h3><p>Mac和Windows可以选择使用PhotoShop作为打开的工具, 和Linux唯一不同的地方在于. 保存的文件的格式需要以.raw结尾 (比如image.raw),选择深度为32位. 其余的和Linux相同.</p>
<p>另外GIMP也有Mac、Windows版本，建议大家在各个平台都使用GIMP，这样学习成本比较低，而且GIMP为免费软件，使用起来功能也非常多。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在使用MAT查看应用程序内存使用情况的时候,我们经常会碰到Bitmap对象以及BitmapDrawable$BitmapState对象,而且在内存使用上,Bitmap所占用的内存占大多数.在这样的情况下, Bitmap所造成的内存泄露尤其严重, 需要及时发现并且及时处理.在这样的需求下, 当我们在MAT中发现和图片相关的内存泄露的时候, 如果能知道是那一张图片,对分析问题会有很大的帮助.</p>
<p>本文就介绍如何将MAT中的Bitmap数组对象还原成一张图片。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/tags/Android/"/>
    
      <category term="MAT" scheme="http://androidperformance.com/tags/MAT/"/>
    
      <category term="Menory" scheme="http://androidperformance.com/tags/Menory/"/>
    
      <category term="Performance" scheme="http://androidperformance.com/tags/Performance/"/>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
      <category term="Menory" scheme="http://androidperformance.com/categories/Android/Menory/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android内存优化之二：MAT使用进阶]]></title>
    <link href="http://androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT-Pro.html"/>
    <id>http://androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT-Pro.html</id>
    <published>2015-04-11T10:26:36.000Z</published>
    <updated>2015-04-11T10:38:30.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>第一篇文章<a href="http://androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT/">《Android内存优化之一：MAT使用入门》</a>介绍了MAT的基本使用方法，包括下载、安装、打开HPROF文件，和一些基本的视图。这篇文章介绍一下一些最新的工具使用方法，和第一篇中没有提到的一些其他的用法。</p>
<h2 id="Java的内存泄露的特点">Java的内存泄露的特点</h2><ul>
<li>Java中的内存泄露主要特征：可达，无用</li>
<li>无用指的是创建了但是不再使用之后没有释放</li>
<li>能重用但是却创建了新的对象进行处理</li>
</ul>
<h2 id="MAT使用技巧进阶">MAT使用技巧进阶</h2><h3 id="使用Android_Studio_Dump内存文件">使用Android Studio Dump内存文件</h3><p>Android Studio的最新版本可以直接获取hprof文件：</p>
<p><img src="/images/MAT_Pro/MAT_1.png" alt="Android-Studio"></p>
<a id="more"></a>
<p>然后选择文件，点击右键转换成标准的hprof文件，就可以在MAT中打开了。</p>
<blockquote>
<p>在使用使用Eclipse或者AndroidStudio抓内存之前，一定要手动点击 Initiate GC按钮手动触发GC，这样抓到的内存使用情况就是不包括Unreachable对象的。</p>
<p><img src="/images/MAT_Pro/MAT_2.png" alt="手动触发GC"></p>
</blockquote>
<h3 id="Unreachable对象">Unreachable对象</h3><p>Unreachable指的是可以被垃圾回收器回收的对象，但是由于没有GC发生，所以没有释放，这时抓的内存使用中的Unreachable就是这些对象。</p>
<p><img src="/images/MAT_Pro/MAT_3.png" alt="Unreachable Objects"></p>
<p><img src="/images/MAT_Pro/MAT_4.png" alt="Unreachable Objects Histogram"></p>
<p>点击Calculate Retained Size之后，会出现Retained Size这一列</p>
<p><img src="/images/MAT_Pro/MAT_5.png" alt="Calculate Retained Size"></p>
<p><img src="/images/MAT_Pro/MAT_6.png" alt="Unreachable Objects Histogram"></p>
<p>可以看到Unreachable Object的对象其Retained Heap值都为0.这也是正常的。</p>
<h3 id="Histogram">Histogram</h3><p>MAT中Histogram的主要作用是查看一个instance的数量，一般用来查看自己创建的类的实例的个数。</p>
<ul>
<li>可以很容易的找出占用内存最多的几个对象，根据Percentage（百分比）来排序。</li>
<li>可以分不同维度来查看对象的Dominator Tree视图，Group by class、Group by class  loader、Group by package<br>和Histogram类似，时间久了，通过多次对比也可以把溢出对象找出来。</li>
<li>Dominator Tree和Histogram的区别是站的角度不一样，Histogram是站在类的角度上去看，Dominator Tree是站的对象实例的角度上看，Dominator Tree可以更方便的看出其引用关系。</li>
</ul>
<p><img src="/images/MAT_Pro/MAT_7.png" alt="Histogram group by package"></p>
<p>通过查看Object的个数，结合代码就可以找出存在内存泄露的类（<strong>即可达但是无用的对象，或者是可以重用但是重新创建的对象</strong>）</p>
<p>Histogram中还可以对对象进行Group，更方便查看自己Package中的对象信息。</p>
<p><img src="/images/MAT_Pro/MAT_8.png" alt="Paste_Image.png"></p>
<h3 id="Thread信息">Thread信息</h3><p>MAT中可以查看当前的Thread信息：</p>
<p><img src="/images/MAT_Pro/MAT_9.png" alt="Thread"></p>
<p>从图中可以得到的信息：</p>
<ol>
<li><p>可以看到可能有内存问题的Thread：</p>
<p><img src="/images/MAT_Pro/MAT_10.png" alt="内存异常"></p>
</li>
<li><p>可以看到数量可能有问题的Thread</p>
<p><img src="/images/MAT_Pro/MAT_11.png" alt="数量异常"></p>
</li>
</ol>
<h3 id="帮助信息">帮助信息</h3><p>MAT中的各个视图中，在每一个Item中点击右键会出现很多选项，很多时候我们需要依赖这些选项来进行分析：</p>
<p><img src="/images/MAT_Pro/MAT_12.png" alt="右键选项"></p>
<p>这些选项的具体含义则可以通过右键中的Search Queries这个选项(上图中的倒数第四个选项)进行搜索和查看，非常的有用。</p>
<p><img src="/images/MAT_Pro/MAT_13.png" alt="帮助信息"></p>
<p>可以看到，所有的命令其实就是配置不同的SQL查询语句。</p>
<p>比如我们最常用的：</p>
<ul>
<li><strong>List objects -&gt; with incoming references</strong>：查看这个对象持有的外部对象引用</li>
<li><strong>List objects -&gt; with outcoming references</strong>：查看这个对象被哪些外部对象引用</li>
<li><strong>Path To GC Roots -&gt; exclude all phantim/weak/soft etc. references</strong>：查看这个对象的GC Root，不包含虚、弱引用、软引用，剩下的就是强引用。从GC上说，除了强引用外，其他的引用在JVM需要的情况下是都可以 被GC掉的，如果一个对象始终无法被GC，就是因为强引用的存在，从而导致在GC的过程中一直得不到回收，因此就内存溢出了。</li>
<li><strong>Path To GC Roots  -&gt; exclude weak/soft references</strong>：查看这个对象的GC Root，不含弱引用和软引用所有的引用.</li>
<li><strong>Merge Shortest path to GC root </strong>：找到从GC根节点到一个对象或一组对象的共同路径</li>
</ul>
<h3 id="Debug_Bitmap">Debug Bitmap</h3><p>如果经常使用MAT分析内存，就会发现Bitmap所占用的内存是非常大的，这个和其实际显示面积是有关系的。在2K屏幕上，一张Bitmap能达到20MB的大小。</p>
<p>所以要是MAT提供了一种方法，可以将存储Bitmap的byte数组导出来，使用第三方工具打开。这个大大提高了我们分析内存泄露的效率。</p>
<p>关于这个方法的操作流程，可以参考这篇文章<a href="">还原MAT中的Bitmap图像</a>.</p>
<h3 id="Debug_ArrayList">Debug ArrayList</h3><p>ArrayList是使用非常常用的一个数据结构，在MAT中，如果想知道ArrayList中有哪些数据，需要右键-&gt; List Objects -&gt; With outgoing references,然后可以看到下面的图：</p>
<p><img src="/images/MAT_Pro/MAT_14.png" alt="Outgoing"></p>
<p>从上图可以看到，这个ArrayList的内容在一个array数组中，即暴漏了ArrayList的内部结构，查看的时候有点不方便，所以MAT提供了另外一种查看ArrayList内数据的方式：</p>
<p><img src="/images/MAT_Pro/MAT_15.png" alt="Extrace List Values"></p>
<p>其结果非常直观：</p>
<p><img src="/images/MAT_Pro/MAT_16.png" alt="Extrace List Values Result"></p>
<h3 id="Big_Drops_In_Dominator_Tree">Big Drops In Dominator Tree</h3><p>Big Drops In Dominator Tree选项在右键-&gt;</p>
<blockquote>
<p>Displays memory accumulation points in the dominator tree. Displayed are objects with a big difference between the retained size of the parent and the children and the first “interesting” dominator of the accumulation point. These are places where the memory of many small objects is accumulated under one object.</p>
</blockquote>
<p><img src="/images/MAT_Pro/MAT_17.png" alt="Big Drops In Dominator Tree"></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>第一篇文章<a href="http://androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT/">《Android内存优化之一：MAT使用入门》</a>介绍了MAT的基本使用方法，包括下载、安装、打开HPROF文件，和一些基本的视图。这篇文章介绍一下一些最新的工具使用方法，和第一篇中没有提到的一些其他的用法。</p>
<h2 id="Java的内存泄露的特点">Java的内存泄露的特点</h2><ul>
<li>Java中的内存泄露主要特征：可达，无用</li>
<li>无用指的是创建了但是不再使用之后没有释放</li>
<li>能重用但是却创建了新的对象进行处理</li>
</ul>
<h2 id="MAT使用技巧进阶">MAT使用技巧进阶</h2><h3 id="使用Android_Studio_Dump内存文件">使用Android Studio Dump内存文件</h3><p>Android Studio的最新版本可以直接获取hprof文件：</p>
<p><img src="/images/MAT_Pro/MAT_1.png" alt="Android-Studio"></p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/tags/Android/"/>
    
      <category term="MAT" scheme="http://androidperformance.com/tags/MAT/"/>
    
      <category term="Menory" scheme="http://androidperformance.com/tags/Menory/"/>
    
      <category term="Performance" scheme="http://androidperformance.com/tags/Performance/"/>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
      <category term="Menory" scheme="http://androidperformance.com/categories/Android/Menory/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android内存优化之一：MAT使用入门]]></title>
    <link href="http://androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT.html"/>
    <id>http://androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT.html</id>
    <published>2015-04-11T10:10:29.000Z</published>
    <updated>2015-07-20T08:23:22.000Z</updated>
    <content type="html"><![CDATA[<h2 id="MAT简介">MAT简介</h2><h3 id="MAT介绍">MAT介绍</h3><p>MAT(Memory Analyzer Tool)，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的JAVA heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗。使用内存分析工具从众多的对象中进行分析，快速的计算出在内存中对象的占用大小，看看是谁阻止了垃圾收集器的回收工作，并可以通过报表直观的查看到可能造成这种结果的对象。  </p>
<p><img src="/images/MAT/MAT_Intro.png" alt="image"></p>
<p>当然MAT也有独立的不依赖Eclipse的版本，只不过这个版本在调试Android内存的时候，需要将DDMS生成的文件进行转换，才可以在独立版本的MAT上打开。不过Android SDK中已经提供了这个Tools，所以使用起来也是很方便的。</p>
<a id="more"></a>
<h3 id="MAT工具的下载安装">MAT工具的下载安装</h3><p>这里是MAT的下载地址：<a href="https://eclipse.org/mat/ downloads.php" target="_blank" rel="external">https://eclipse.org/mat/downloads.php</a>，下载时会提供三种选择的方式：</p>
<p><img src="/images/MAT/MAT_Download.png" alt="image"></p>
<ul>
<li>Update Site  这种方式后面会有一个网址：比如<a href="http://download.eclipse.org/mat/1.4/update-site/" target="_blank" rel="external">http://download.eclipse.org/mat/1.4/update-site/</a> ，安装过Eclipse插件的同学应该知道，只要把这段网址复制到对应的Eclipse的Install New Software那里，就可以进行在线下载了。</li>
</ul>
<p><img src="/images/MAT/MAT_Eclipse_Install.png" alt="image"></p>
<ul>
<li>Archived Update Site  这种方式安装的位置和上一种差不多，只不过第一种是在线下载，这一种是使用离线包进行更新，这种方式劣势是当这个插件更新后，需要重新下载离线包，而第一种方式则可以在线下载更新。</li>
<li>Stand-alone Eclipse RCP Applications 这种方式就是把MAT当成一个独立的工具使用，不再依附于Eclipse，适合不使用Eclipse而使用Android Studio的同学。这种方式有个麻烦的地方就是DDMS导出的文件，需要进行转换才可以在MAT中打开。</li>
</ul>
<p>下载安装好之后，就可以使用MAT进行实际的操作了。</p>
<h2 id="Android(Java)中常见的容易引起内存泄露的不良代码">Android(Java)中常见的容易引起内存泄露的不良代码</h2><h3 id="Android内存">Android内存</h3><p>使用MAT工具之前，要对Android的内存分配方式有基本的了解，对容易引起内存泄露的代码也要保持敏感，在代码级别对内存泄露的排查，有助于内存的使用。</p>
<p>Android主要应用在嵌入式设备当中，而嵌入式设备由于一些众所周知的条件限制，通常都不会有很高的配置，特别是内存是比较有限的。如果我们编写的代码当中有太多的对内存使用不当的地方，难免会使得我们的设备运行缓慢，甚至是死机。为了能够使得Android应用程序安全且快速的运行，Android的每个应用程序都会使用一个专有的Dalvik虚拟机实例来运行，它是由Zygote服务进程孵化出来的，也就是说每个应用程序都是在属于自己的进程中运行的。一方面，如果程序在运行过程中出现了内存泄漏的问题，仅仅会使得自己的进程被kill掉，而不会影响其他进程（如果是system_process等系统进程出问题的话，则会引起系统重启）。另一方面Android为不同类型的进程分配了不同的内存使用上限，如果应用进程使用的内存超过了这个上限，则会被系统视为内存泄漏，从而被kill掉。</p>
<h3 id="常见的内存使用不当的情况">常见的内存使用不当的情况</h3><h4 id="查询数据库没有关闭游标">查询数据库没有关闭游标</h4><p>描述：<br>程序中经常会进行查询数据库的操作，但是经常会有使用完毕Cursor后没有关闭的情况。如果我们的查询结果集比较小，对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会复现内存问题，这样就会给以后的测试和问题排查带来困难和风险。<br>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cursor cursor = getContentResolver().query(uri ...);</span><br><span class="line">	<span class="keyword">if</span> (cursor.moveToNext()) &#123;</span><br><span class="line"> 	... ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修正示例代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Cursor cursor = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  	cursor = getContentResolver().query(uri ...);</span><br><span class="line">	<span class="keyword">if</span> (cursor != <span class="keyword">null</span> &amp;&amp; cursor.moveToNext()) &#123;</span><br><span class="line">	... ... </span><br><span class="line">	&#125;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (cursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123; </span><br><span class="line">		cursor.close();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		<span class="comment">//ignore this</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>`</p>
<h4 id="构造Adapter时，没有使用缓存的_convertView">构造Adapter时，没有使用缓存的 convertView</h4><p>描述：以构造ListView的BaseAdapter为例，在BaseAdapter中提供了方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span></span></span><br></pre></td></tr></table></figure>
<p>来向ListView提供每一个item所需要的view对象。初始时ListView会从BaseAdapter中根据当前的屏幕布局实例化一定数量的view对象，同时ListView会将这些view对象缓存起来。当向上滚动ListView时，原先位于最上面的list item的view对象会被回收，然后被用来构造新出现的最下面的list item。这个构造过程就是由getView()方法完成的，getView()的第二个形参 View convertView就是被缓存起来的list item的view对象(初始化时缓存中没有view对象则convertView是null)。<br>由此可以看出，如果我们不去使用convertView，而是每次都在getView()中重新实例化一个View对象的话，即浪费资源也浪费时间，也会使得内存占用越来越大。ListView回收list item的view对象的过程可以查看:android.widget.AbsListView.java –> void addScrapView(View scrap) 方法。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line"> View view = <span class="keyword">new</span> Xxx(...);</span><br><span class="line"> ... ...</span><br><span class="line"> <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>`<br>示例修正代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line"> View view = <span class="keyword">null</span>;</span><br><span class="line"> <span class="keyword">if</span> (convertView != <span class="keyword">null</span>) &#123;</span><br><span class="line"> view = convertView;</span><br><span class="line"> populate(view, getItem(position));</span><br><span class="line"> ...</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> view = <span class="keyword">new</span> Xxx(...);</span><br><span class="line"> ...</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于ListView的使用和优化，可以参考这两篇文章：</p>
<ul>
<li><a href="http://www.vogella.com/tutorials/AndroidListView/article.html" target="_blank" rel="external">Using lists in Android (ListView) - Tutorial<br>  ]()</a></li>
<li><a href="http://developer.android.com/training/improving-layouts/smooth-scrolling.html#ViewHolder" target="_blank" rel="external">Making ListView Scrolling Smooth</a></li>
</ul>
<h4 id="Bitmap对象不在使用时调用recycle()释放内存">Bitmap对象不在使用时调用recycle()释放内存</h4><p>描述：有时我们会手工的操作Bitmap对象，如果一个Bitmap对象比较占内存，当它不在被使用的时候，可以调用Bitmap.recycle()方法回收此对象的像素所占用的内存。<br>另外在最新版本的Android开发时，使用下面的方法也可以释放此Bitmap所占用的内存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Bitmap bitmap ;</span><br><span class="line"> ...</span><br><span class="line"> bitmap初始化以及使用</span><br><span class="line"> ...</span><br><span class="line">bitmap = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<h4 id="释放对象的引用">释放对象的引用</h4><p>描述：这种情况描述起来比较麻烦，举两个例子进行说明。</p>
<p>示例A：<br>假设有如下操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">	... ...</span><br><span class="line">	<span class="keyword">private</span> Handler mHandler = ...</span><br><span class="line">	<span class="keyword">private</span> Object obj;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	 obj = initObj();</span><br><span class="line">	 ...</span><br><span class="line">	 [Mark]</span><br><span class="line">	 mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">	        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	         useObj(obj);</span><br><span class="line">	        &#125;</span><br><span class="line">	 &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们有一个成员变量 obj，在operation()中我们希望能够将处理obj实例的操作post到某个线程的MessageQueue中。在以上的代码中，即便是mHandler所在的线程使用完了obj所引用的对象，但这个对象仍然不会被垃圾回收掉，因为DemoActivity.obj还保有这个对象的引用。所以如果在DemoActivity中不再使用这个对象了，可以在[Mark]的位置释放对象的引用，而代码可以修改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	obj = initObj();</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">final</span> Object o = obj;</span><br><span class="line">	obj = <span class="keyword">null</span>;</span><br><span class="line">	mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	        useObj(o);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例B：<br>假设我们希望在锁屏界面(LockScreen)中，监听系统中的电话服务以获取一些信息(如信号强度等)，则可以在LockScreen中定义一个PhoneStateListener的对象，同时将它注册到TelephonyManager服务中。对于LockScreen对象，当需要显示锁屏界面的时候就会创建一个LockScreen对象，而当锁屏界面消失的时候LockScreen对象就会被释放掉。  </p>
<p>但是如果在释放LockScreen对象的时候忘记取消我们之前注册的PhoneStateListener对象，则会导致LockScreen无法被垃圾回收。如果不断的使锁屏界面显示和消失，则最终会由于大量的LockScreen对象没有办法被回收而引起OutOfMemory,使得system_process进程挂掉。</p>
<p>总之当一个生命周期较短的对象A，被一个生命周期较长的对象B保有其引用的情况下，在A的生命周期结束时，要在B中清除掉对A的引用。</p>
<h4 id="其他">其他</h4><p>Android应用程序中最典型的需要注意释放资源的情况是在Activity的生命周期中，在onPause()、onStop()、onDestroy()方法中需要适当的释放资源的情况。由于此情况很基础，在此不详细说明，具体可以查看官方文档对Activity生命周期的介绍，以明确何时应该释放哪些资源。</p>
<p>另外一些其他的例子，将会在补充版本加入。</p>
<h2 id="使用MAT进行内存调试">使用MAT进行内存调试</h2><h3 id="获取HPROF文件">获取HPROF文件</h3><p>HPROF文件是MAT能识别的文件，HPROF文件存储的是特定时间点，java进程的内存快照。有不同的格式来存储这些数据，总的来说包含了快照被触发时java对象和类在heap中的情况。由于快照只是一瞬间的事情，所以heap dump中无法包含一个对象在何时、何地（哪个方法中）被分配这样的信息。<br>这个文件可以使用DDMS导出：</p>
<ol>
<li><p>DDMS中在Devices上面有一排按钮，选择一个进程后（即在Devices下面列出的列表中选择你要调试的应用程序的包名），点击Dump HPROF file 按钮：</p>
<p><img src="/images/MAT/MAT_DDMS_ExportFile.png" alt="image">  </p>
</li>
</ol>
<p>选择存储路径保存后就可以得到对应进程的HPROF文件。eclipse插件可以把上面的工作一键完成。只需要点击Dump HPROF file图标，然后MAT插件就会自动转换格式，并且在eclipse中打开分析结果。eclipse中还专门有个Memory Analysis视图  </p>
<ol>
<li>得到对应的文件后，如果安装了Eclipse插件，那么切换到Memory Analyzer视图。使用独立安装的，要使用Android SDK自带的的工具（hprof-conv 位置在sdk/platform-tools/hprof-conv）进行转换</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hprof-conv xxx.xxx.xxx.hprof xxx.xxx.xxx.hprof</span><br></pre></td></tr></table></figure>
<p>转换过后的.hprof文件即可使用MAT工具打开了。</p>
<h3 id="MAT主界面介绍">MAT主界面介绍</h3><p>这里介绍的不是MAT这个工具的主界面，而是导入一个文件之后，显示OverView的界面。</p>
<ul>
<li>打开经过转换的hprof文件：<br>  <img src="/images/MAT/MAT_OpenFile.png" alt="image"></li>
</ul>
<p>如果选择了第一个，则会生成一个报告。这个无大碍。  </p>
<p><img src="/images/MAT/MAT_Report.png" alt="image"></p>
<ul>
<li><p>选择OverView界面：  </p>
<p><img src="/images/MAT/MAT_Overview.png" alt="Image"></p>
</li>
</ul>
<p>我们需要关注的是下面的Actions区域</p>
<ul>
<li><p>Histogram：列出内存中的对象，对象的个数以及大小  </p>
<p><img src="/images/MAT/MAT_Histogram.png" alt="image"></p>
</li>
<li><p>Dominator Tree：列出最大的对象以及其依赖存活的Object （大小是以Retained Heap为标准排序的）  </p>
<p><img src="/images/MAT/MAT_DominatorTree.png" alt="image"></p>
</li>
<li><p>Top Consumers ： 通过图形列出最大的object  </p>
<p><img src="/images/MAT/MAT_TopConsumers.png" alt="image"></p>
</li>
<li><p>Duplicate Class：通过MAT自动分析泄漏的原因</p>
</li>
</ul>
<p>一般Histogram和 Dominator Tree是最常用的。  </p>
<h3 id="MAT中一些概念介绍">MAT中一些概念介绍</h3><p>要看懂MAT的列表信息，Shallow heap、Retained Heap、GC Root这几个概念一定要弄懂。</p>
<h4 id="3-3-1_Shallow_heap">3.3.1 Shallow heap</h4><p>Shallow size就是对象本身占用内存的大小，不包含其引用的对象。  </p>
<ul>
<li>常规对象（非数组）的Shallow size有其成员变量的数量和类型决定。</li>
<li>数组的shallow size有数组元素的类型（对象类型、基本类型）和数组长度决定</li>
</ul>
<p>因为不像c++的对象本身可以存放大量内存，java的对象成员都是些引用。真正的内存都在堆上，看起来是一堆原生的byte[], char[], int[]，所以我们如果只看对象本身的内存，那么数量都很小。所以我们看到Histogram图是以Shallow size进行排序的，排在第一位第二位的是byte，char 。</p>
<h4 id="3-3-2_Retained_Heap">3.3.2 Retained Heap</h4><p>Retained Heap的概念，它表示如果一个对象被释放掉，那会因为该对象的释放而减少引用进而被释放的所有的对象（包括被递归释放的）所占用的heap大小。于是，如果一个对象的某个成员new了一大块int数组，那这个int数组也可以计算到这个对象中。相对于shallow heap，Retained heap可以更精确的反映一个对象实际占用的大小（因为如果该对象释放，retained heap都可以被释放）。</p>
<p>这里要说一下的是，Retained Heap并不总是那么有效。例如我在A里new了一块内存，赋值给A的一个成员变量。此时我让B也指向这块内存。此时，因为A和B都引用到这块内存，所以A释放时，该内存不会被释放。所以这块内存不会被计算到A或者B的Retained Heap中。为了纠正这点，MAT中的Leading Object（例如A或者B）不一定只是一个对象，也可以是多个对象。此时，(A, B)这个组合的Retained Set就包含那块大内存了。对应到MAT的UI中，在Histogram中，可以选择Group By class, superclass or package来选择这个组。</p>
<p>为了计算Retained Memory，MAT引入了Dominator Tree。加入对象A引用B和C，B和C又都引用到D（一个菱形）。此时要计算Retained Memory，A的包括A本身和B，C，D。B和C因为共同引用D，所以他俩的Retained Memory都只是他们本身。D当然也只是自己。我觉得是为了加快计算的速度，MAT改变了对象引用图，而转换成一个对象引用树。在这里例子中，树根是A，而B，C，D是他的三个儿子。B，C，D不再有相互关系。把引用图变成引用树，计算Retained Heap就会非常方便，显示也非常方便。对应到MAT UI上，在dominator tree这个view中，显示了每个对象的shallow heap和retained heap。然后可以以该节点位树根，一步步的细化看看retained heap到底是用在什么地方了。要说一下的是，这种从图到树的转换确实方便了内存分析，但有时候会让人有些疑惑。本来对象B是对象A的一个成员，但因为B还被C引用，所以B在树中并不在A下面，而很可能是平级。</p>
<p>为了纠正这点，MAT中点击右键，可以List objects中选择with outgoing references和with incoming references。这是个真正的引用图的概念，</p>
<ul>
<li>outgoing references ：表示该对象的出节点（被该对象引用的对象）。</li>
<li>incoming references ：表示该对象的入节点（引用到该对象的对象）。</li>
</ul>
<p>为了更好地理解Retained Heap，下面引用一个例子来说明：  </p>
<p>把内存中的对象看成下图中的节点，并且对象和对象之间互相引用。这里有一个特殊的节点GC Roots，这就是reference chain(引用链)的起点:<br><img src="/images/MAT/MAT_Retained_objects.gif" alt="image"> <img src="../images/MAT/MAT_Retained_objects_2.gif" alt="image"></p>
<p>从obj1入手，上图中蓝色节点代表仅仅只有通过obj1才能直接或间接访问的对象。因为可以通过GC Roots访问，所以左图的obj3不是蓝色节点；而在右图却是蓝色，因为它已经被包含在retained集合内。<br>所以对于左图，obj1的retained size是obj1、obj2、obj4的shallow size总和；<br>右图的retained size是obj1、obj2、obj3、obj4的shallow size总和。<br>obj2的retained size可以通过相同的方式计算。</p>
<h4 id="GC_Root">GC Root</h4><p>GC发现通过任何reference chain(引用链)无法访问某个对象的时候，该对象即被回收。名词GC Roots正是分析这一过程的起点，例如JVM自己确保了对象的可到达性(那么JVM就是GC Roots)，所以GC Roots就是这样在内存中保持对象可到达性的，一旦不可到达，即被回收。通常GC Roots是一个在current thread(当前线程)的call stack(调用栈)上的对象（例如方法参数和局部变量），或者是线程自身或者是system class loader(系统类加载器)加载的类以及native code(本地代码)保留的活动对象。所以GC Roots是分析对象为何还存活于内存中的利器。</p>
<h3 id="MAT中的一些有用的视图">MAT中的一些有用的视图</h3><h4 id="Thread_OvewView">Thread OvewView</h4><p>Thread OvewView可以查看这个应用的Thread信息：<br><img src="/images/MAT/MAT_ThreadOverView.png" alt="image"></p>
<h4 id="Group">Group</h4><p>在Histogram和Domiantor Tree界面，可以选择将结果用另一种Group的方式显示（默认是Group by Object），切换到Group by package，可以更好地查看具体是哪个包里的类占用内存大，也很容易定位到自己的应用程序。<br><img src="/images/MAT/MAT_Group.png" alt="image"></p>
<h4 id="Path_to_GC_Root">Path to GC Root</h4><p>在Histogram或者Domiantor Tree的某一个条目上，右键可以查看其GC Root Path：<br><img src="/images/MAT/MAT_PathToGCRoot.png" alt="image"></p>
<p>这里也要说明一下Java的引用规则：<br>从最强到最弱，不同的引用（可到达性）级别反映了对象的生命周期。  </p>
<ul>
<li>Strong Ref(强引用)：通常我们编写的代码都是Strong Ref，于此对应的是强可达性，只有去掉强可达，对象才被回收。</li>
<li>Soft Ref(软引用)：对应软可达性，只要有足够的内存，就一直保持对象，直到发现内存吃紧且没有Strong Ref时才回收对象。一般可用来实现缓存，通过java.lang.ref.SoftReference类实现。</li>
<li>Weak Ref(弱引用)：比Soft Ref更弱，当发现不存在Strong Ref时，立刻回收对象而不必等到内存吃紧的时候。通过java.lang.ref.WeakReference和java.util.WeakHashMap类实现。</li>
<li>Phantom Ref(虚引用)：根本不会在内存中保持任何对象，你只能使用Phantom Ref本身。一般用于在进入finalize()方法后进行特殊的清理过程，通过 java.lang.ref.PhantomReference实现。</li>
</ul>
<p>点击Path To GC Roots –> with all references<br><img src="/images/MAT/MAT_PathToGCRoot_Detail.png" alt="image"></p>
<h2 id="参考文档">参考文档</h2><ol>
<li><a href="http://www.yourkit.com/docs/java/help/sizes.jsp" target="_blank" rel="external">Shallow and retained sizes</a></li>
<li>MAT的wiki：<a href="http://wiki.eclipse.org/index.php/MemoryAnalyzer" target="_blank" rel="external">http://wiki.eclipse.org/index.php/MemoryAnalyzer</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="MAT简介">MAT简介</h2><h3 id="MAT介绍">MAT介绍</h3><p>MAT(Memory Analyzer Tool)，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的JAVA heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗。使用内存分析工具从众多的对象中进行分析，快速的计算出在内存中对象的占用大小，看看是谁阻止了垃圾收集器的回收工作，并可以通过报表直观的查看到可能造成这种结果的对象。  </p>
<p><img src="/images/MAT/MAT_Intro.png" alt="image"></p>
<p>当然MAT也有独立的不依赖Eclipse的版本，只不过这个版本在调试Android内存的时候，需要将DDMS生成的文件进行转换，才可以在独立版本的MAT上打开。不过Android SDK中已经提供了这个Tools，所以使用起来也是很方便的。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/tags/Android/"/>
    
      <category term="MAT" scheme="http://androidperformance.com/tags/MAT/"/>
    
      <category term="Menory" scheme="http://androidperformance.com/tags/Menory/"/>
    
      <category term="Performance" scheme="http://androidperformance.com/tags/Performance/"/>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
      <category term="Menory" scheme="http://androidperformance.com/categories/Android/Menory/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android性能优化后续]]></title>
    <link href="http://androidperformance.com/2015/03/31/android-performance-case-study-follow-up.html"/>
    <id>http://androidperformance.com/2015/03/31/android-performance-case-study-follow-up.html</id>
    <published>2015-03-31T01:29:00.000Z</published>
    <updated>2015-04-20T07:53:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>本文是一篇译文，原文<a href="http://www.curious-creature.com/2015/03/25/android-performance-case-study-follow-up/?utm_source=Android+Weekly&amp;utm_campaign=0692ef161b-Android_Weekly_146&amp;utm_medium=email&amp;utm_term=0_4eb677ad19-0692ef161b-337850757" target="_blank" rel="external">Android Performance Case Study Follow-up</a>的作者是大名鼎鼎的<a href="http://www.curious-creature.com/" target="_blank" rel="external">Romain Guy</a>。本文讲述了Android性能优化的一些技巧、方法和工具。</p>
<h1 id="译文正文">译文正文</h1><p>两年前，我发表了一篇名为<a href="http://www.curious-creature.com/2012/12/01/android-performance-case-study/" target="_blank" rel="external">Android Performance Case Study</a> 的文章，来帮助Android开发者了解需要使用什么工具和技术手段来确定、追踪和优化性能问题。</p>
<p>那篇文章以一个Twitter客户端 <a href="https://play.google.com/store/apps/details?id=com.jv.materialfalcon" target="_blank" rel="external">Falcon Pro</a>为典范，其开发人员为 Joaquim Vergès. Joaquim人不错，他允许我在我的文章中使用它的程序作为例子，并且快速处理了我发现的所有问题。一切都OK，直到Joaquim 从头开始开发Falcon Pro 3，前不久在他准备发布它的新应用的时候，他联系了我，因为他有一个和滚动相关的性能问题需要我来帮助他，这一次我依然没有源代码可以参考。</p>
<a id="more"></a>
<p>Joaquim使用了所有的工具来找出问题所在，他发现Overdraw不是问题的原因，他觉得是 <a href="http://developer.android.com/reference/android/support/v4/view/ViewPager.html" target="_blank" rel="external">ViewPager</a> 的用法导致了这个问题。他给我发来了下面的截图：</p>
<p><img src="/images/android-performance-case-study-follow-up/falconpro3.png" alt="Falcon Pro"></p>
<p>Joaquim使用了系统内置的GPU profiling工具来发现掉帧现象， 左边的截图是在没有ViewPager 的情况下滑动时间线，右边的截图是有ViewPager的情况下滑动（他使用的是2014年的Moto x来截的图），问题看起来很明显。</p>
<p>我最先想到的是查看ViewPager是不是由于滥用硬件加速导致，这个性能问题看起来像是在滑动的过程中每一帧都使用了硬件加速。系统的 <a href="http://www.curious-creature.com/2013/09/13/optimizing-hardware-layers/" target="_blank" rel="external">hardware layers updates debugging tool</a>没有显示什么有用的信息。我反复使用HierarchyViewer 查看布局情况，令我满意的是ViewPager的表现很正确（相反，不太可能会出问题）</p>
<p>之后我打开了另一个强大的工具却很少用到的工具：Tracer for OpenGL 。我之前的那篇<a href="http://www.curious-creature.com/2012/12/01/android-performance-case-study" target="_blank" rel="external">文章</a>解释了如何使用工具获得更多细节。你首先需要知道的是这个工具收集了所有UI界面发给GPU的绘制命令。</p>
<blockquote>
<p><strong>Android 4.3 and up</strong>: <em>Tracer</em> has unfortunately become a little more difficult to use since Android 4.3 when we introduced<a href="https://developers.google.com/events/io/sessions/325418001" target="_blank" rel="external">reordering and merging of drawing commands</a>. It’s an amazingly useful optimization but it prevents <em>Tracer</em> from grouping drawing commands by view. You can restore the old behavior by disabling display lists optimization using the following command (before you start your application)(意思是说Android4.3之后，这个工具不太好用了，因为有reordering and merging 机制的引进)</p>
<p><strong>Reading OpenGL traces</strong>: Commands shown in blue are GL operations that draw pixels on screen. All other commands are used to transfer data or set state and can easily be ignored. Every time you click on one of the blue commands, Tracer will update the Details tab and show you the content of the current render target right after the command you clicked is executed. You can thus reconstruct a frame by clicking on each blue command one after another. It’s pretty much how I analyze performance issues with Tracer. Seeing how a frame is rendered gives a lot of insight on what the application is doing.(意思是说只蓝色的行是真正进行绘制的命令，点击可以看到绘制的这一帧的图像，其他的命令都是一些数据的转换)</p>
</blockquote>
<p>滑动一段时间Falcon Pro应用后，我仔细查看Gl Trace收集到的数据，我很惊奇地发现很多SaveLayer/ComposeLayer阻塞命令。</p>
<p><img src="/images/android-performance-case-study-follow-up/glTrace.png" alt="Paste_Image.png"></p>
<p>这些命令表明应用在生成一个临时的Hardware Layer。这些临时的Layer被不同的 <a href="http://developer.android.com/reference/android/graphics/Canvas.html#saveLayer(float, float, float, float, android.graphics.Paint, int" target="_blank" rel="external">Canvas.saveLayer()</a>)所创建，这些UI控件在下面的情况下使用Canvas.saveLayer()方法去绘制 alpha &lt; 1 (see<a href="http://developer.android.com/reference/android/view/View.html#setAlpha(float" target="_blank" rel="external">View.setAlpha()</a>)的View(即半透明View)：</p>
<ul>
<li><a href="http://developer.android.com/reference/android/view/View.html#getAlpha(" target="_blank" rel="external">getAlpha()</a> returns a value &lt; 1</li>
<li><a href="http://developer.android.com/reference/android/view/View.html#onSetAlpha(int" target="_blank" rel="external">onSetAlpha()</a> returns false</li>
<li><a href="http://developer.android.com/reference/android/view/View.html#getLayerType(" target="_blank" rel="external">getLayerType()</a> returns LAYER_TYPE_NONE</li>
<li><a href="http://developer.android.com/reference/android/view/View.html#hasOverlappingRendering(" target="_blank" rel="external">hasOverlappingRendering()</a> returns true</li>
</ul>
<p>我和Chet 在很多演示中解释过为什么你应该 <a href="https://youtu.be/vQZFaec9NpA?t=29m51s" target="_blank" rel="external">use alpha with care</a>，每次UI控件使用一个临时的Layer，绘制命令会发送不同的渲染目标，对GPU来说，切换渲染目标是很昂贵的操作,这对于使用tiling/deferred架构的GPU（ImaginationTech’s SGX, Qualcomm’s Adreno, etc）等是硬伤，直接渲染架构的GPU，比如 Nvidia，则会好一点。因为我和Joaquim 使用的是搭载高通处理器的Moto X 2014版本，所以使用多个临时硬件层是最有可能的性能问题的根源。</p>
<p>那么问题来了，是什么创建了这些临时的Layer呢？<em>Tracer</em>告诉我们了答案，如果你看了刚刚上面那张<a href="http://www.curious-creature.com/blog/wp-content/uploads/2015/03/Screen-Shot-2015-03-25-at-11.00.53-AM-950x552.png" target="_blank" rel="external">图</a>,你可以看到只有SaveLayer这个组中OpenGl命令绘制了一个小圆圈（图被工具放大了），我们来看一下应用截图：</p>
<p><img src="/images/android-performance-case-study-follow-up/before.png" alt="Falcon Pro 3"></p>
<p>你看到最上面的小圆圈了么？那是ViewPager的指示器，来显示当前的位置。Joaquim 使用了一个第三方库来绘制这些指示器，有趣的是这些库如何绘制指示器的：当前的Page用一个白色的圈指示，其他的页用类似灰色的圆圈来指示。我说类似灰色因为这个圆圈其实是半透明的白色圆圈。这个库使用 setAlpha()方法来给每个圆圈设置颜色。</p>
<p>有下面几种方法来解决这个问题：</p>
<ul>
<li>Use a customizable “inactive” color instead of setting an opacity on the View（ 使用动态的“inactive”颜色(即根据状态来设置View的颜色)而不是设置透明度。）</li>
<li><p>Return false from hasOverlappingRendering() and the framework will set the proper alpha on the Paint<br>for you（使hasOverlappingRendering()返回false，这样系统会设置适当的alpha，关于这个的用法，这篇<a href="http://imid.me/blog/2014/01/17/best-practices-for-using-alpha/" target="_blank" rel="external">文章</a>中有提到：同时Android提供了hasOverlappingRendering()接口，通过重写该接口可以告知系统当前View是否存在内容重叠的情况，帮助系统优化绘制流程，原理是这样的：对于有重叠内容的View，系统简单粗暴的使用 offscreen buffer来协助处理。当告知系统该View无重叠内容时，系统会分别使用合适的alpha值绘制每一层。）</p>
 <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns whether this View has content which overlaps. This function, intended <span class="keyword">to</span> be</span><br><span class="line"> * overridden <span class="keyword">by</span> specific View types, <span class="keyword">is</span> an optimization when alpha <span class="keyword">is</span> <span class="keyword">set</span> <span class="function_start"><span class="keyword">on</span></span> a view. If</span><br><span class="line"> * rendering overlaps <span class="keyword">in</span> a view <span class="keyword">with</span> alpha &lt; <span class="number">1</span>, <span class="keyword">that</span> view <span class="keyword">is</span> drawn <span class="keyword">to</span> an offscreen buffer</span><br><span class="line"> * <span class="keyword">and</span> <span class="keyword">then</span> composited <span class="keyword">it</span> <span class="keyword">into</span> place, which can be expensive. If <span class="keyword">the</span> view has no overlapping</span><br><span class="line"> * rendering, <span class="keyword">the</span> view can draw each primitive <span class="keyword">with</span> <span class="keyword">the</span> appropriate alpha value directly.</span><br><span class="line"> * An example <span class="keyword">of</span> overlapping rendering <span class="keyword">is</span> a TextView <span class="keyword">with</span> a background image, such <span class="keyword">as</span> a</span><br><span class="line"> * Button. An example <span class="keyword">of</span> non-overlapping rendering <span class="keyword">is</span> a TextView <span class="keyword">with</span> no background, <span class="keyword">or</span></span><br><span class="line"> * an ImageView <span class="keyword">with</span> only <span class="keyword">the</span> foreground image. The default implementation returns <span class="constant">true</span>;</span><br><span class="line"> * subclasses should override <span class="keyword">if</span> they have cases which can be optimized.</span><br><span class="line"> *</span><br><span class="line"> * @<span class="constant">return</span> <span class="constant">true</span> <span class="keyword">if</span> <span class="keyword">the</span> content <span class="keyword">in</span> this view might overlap, <span class="constant">false</span> otherwise.</span><br><span class="line"> */</span><br><span class="line">public <span class="type">boolean</span> hasOverlappingRendering() &#123;</span><br><span class="line"><span class="command">    return</span> <span class="constant">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Return true from onSetAlpha() and set an alpha on the Paint used to draw the “gray” circles（使onSetAlpha() 返回True并对Paint设置alpha来绘制“gray”圆圈）</p>
 <figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">paint.setAlpha((<span class="built_in">int</span>) <span class="built_in">alpha</span> * <span class="number">255</span>);</span><br><span class="line">canvas.<span class="title">draw</span>*(..., paint);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>最简单的方法是使用第二种，但是他只能在API16以上使用，如果你要支持旧版本的Android，使用其他两个方法，我相信Joaquim 已经丢弃那个第三方库并使用自己的指示器了。</p>
<p>我希望这篇文章能让大家清楚如何从看似无辜的和无害的操作中寻找可能会出现性能问题。所以请记住:不要仅仅做出假设,要实际去验证、测量。</p>
<h1 id="附录">附录</h1><p>更多关于Alpha的使用，可以参考这篇文章：<br><a href="http://imid.me/blog/2014/01/17/best-practices-for-using-alpha/" target="_blank" rel="external">Android Tips: Best Practices for Using Alpha</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="前言">前言</h1><p>本文是一篇译文，原文<a href="http://www.curious-creature.com/2015/03/25/android-performance-case-study-follow-up/?utm_source=Android+Weekly&amp;utm_campaign=0692ef161b-Android_Weekly_146&amp;utm_medium=email&amp;utm_term=0_4eb677ad19-0692ef161b-337850757">Android Performance Case Study Follow-up</a>的作者是大名鼎鼎的<a href="http://www.curious-creature.com/">Romain Guy</a>。本文讲述了Android性能优化的一些技巧、方法和工具。</p>
<h1 id="译文正文">译文正文</h1><p>两年前，我发表了一篇名为<a href="http://www.curious-creature.com/2012/12/01/android-performance-case-study/">Android Performance Case Study</a> 的文章，来帮助Android开发者了解需要使用什么工具和技术手段来确定、追踪和优化性能问题。</p>
<p>那篇文章以一个Twitter客户端 <a href="https://play.google.com/store/apps/details?id=com.jv.materialfalcon">Falcon Pro</a>为典范，其开发人员为 Joaquim Vergès. Joaquim人不错，他允许我在我的文章中使用它的程序作为例子，并且快速处理了我发现的所有问题。一切都OK，直到Joaquim 从头开始开发Falcon Pro 3，前不久在他准备发布它的新应用的时候，他联系了我，因为他有一个和滚动相关的性能问题需要我来帮助他，这一次我依然没有源代码可以参考。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/tags/Android/"/>
    
      <category term="MAT" scheme="http://androidperformance.com/tags/MAT/"/>
    
      <category term="Menory" scheme="http://androidperformance.com/tags/Menory/"/>
    
      <category term="Performance" scheme="http://androidperformance.com/tags/Performance/"/>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
      <category term="Menory" scheme="http://androidperformance.com/categories/Android/Menory/"/>
    
      <category term="Performance" scheme="http://androidperformance.com/categories/Android/Menory/Performance/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Android小技巧(5)]]></title>
    <link href="http://androidperformance.com/2015/03/15/android-tips-round-up-5.html"/>
    <id>http://androidperformance.com/2015/03/15/android-tips-round-up-5.html</id>
    <published>2015-03-14T16:32:11.000Z</published>
    <updated>2015-07-20T08:23:10.000Z</updated>
    <content type="html"><![CDATA[<p>本文是一篇译文,这篇是这个系列的第五篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<a id="more"></a>
<h2 id="正文">正文</h2><p><a href="https://developer.android.com/reference/android/support/v4/widget/ViewDragHelper.html" target="_blank" rel="external">ViewDragHelper</a> ——视图拖动是一个比较复杂的问题。这个类可以帮助解决不少问题。如果你需要一个例子，<a href="https://developer.android.com/reference/android/support/v4/widget/DrawerLayout.html" target="_blank" rel="external">DrawerLayout</a>就是利用它实现扫滑。Flavient Laurent 还写了一些关于这方面的<a href="http://flavienlaurent.com/blog/2013/08/28/each-navigation-drawer-hides-a-viewdraghelper/" target="_blank" rel="external">优秀文章</a>。</p>
<p><a href="https://developer.android.com/reference/android/widget/PopupWindow.html" target="_blank" rel="external">PopupWindow</a>——Android到处都在使用PopupWindow ，甚至你都没有意识到（标题导航条ActionBar，自动补全AutoComplete，编辑框错误提醒Edittext Errors）。这个类是创建浮层内容的主要方法。</p>
<p><a href="https://developer.android.com/reference/android/app/ActionBar.htmlgetThemedContext%28%29" target="_blank" rel="external">Actionbar.getThemrContext()</a>——导航栏的主题化是很复杂的（不同于Activity其他部分的主题化）。你可以得到一个上下文（Context），用这个上下文创建的自定义组件可以得到正确的主题。</p>
<p><a href="https://developer.android.com/reference/android/media/ThumbnailUtils.html" target="_blank" rel="external">ThumbnailUtils</a>——帮助创建缩略图。通常我都是用现有的图片加载库（比如，Picasso 或者 Volley），不过这个ThumbnaiUtils可以创建视频缩略图。<strong>译者注：</strong>该API从V8才开始支持。</p>
<p><a href="https://developer.android.com/reference/android/content/Context.htmlgetExternalFilesDir%28java.lang.String%29" target="_blank" rel="external">Context.getExternalFilesDir()</a>———— 申请了SD卡写权限后，你可以在SD的任何地方写数据，把你的数据写在设计好的合适位置会更加有礼貌。这样数据可以及时被清理，也会有更好的用户体验。此外，Android 4.0 Kitkat中在这个文件夹下写数据是不需要权限的，每个用户有自己的独立的数据存储路径。<strong>译者注：</strong>该API从V8才开始支持。</p>
<p><a href="https://developer.android.com/reference/android/util/SparseArray.html" target="_blank" rel="external">SparseArray</a>——Map的高效优化版本。推荐了解姐妹类SparseBooleanArray、SparseIntArray和SparseLongArray。</p>
<p><a href="https://developer.android.com/reference/android/content/pm/PackageManager.htmlsetComponentEnabledSetting%28android.content.ComponentName,%20int,%20int%29" target="_blank" rel="external">PackageManager.setComponentEnabledSetting()</a>——可以用来启动或者禁用程序清单中的组件。对于关闭不需要的功能组件是非常赞的，比如关掉一个当前不用的广播接收器。</p>
<p><a href="https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.htmlyieldIfContendedSafely%28%29" target="_blank" rel="external">SQLiteDatabase.yieldIfContendedSafely()</a>——让你暂时停止一个数据库事务， 这样你可以就不会占用太多的系统资源。</p>
<p><a href="https://developer.android.com/reference/android/os/Environment.html#getExternalStoragePublicDirectory%28java.lang.String%29" target="_blank" rel="external">Environment.getExternalStoragePublicDirectory()</a>——还是那句话，用户期望在SD卡上得到统一的用户体验。用这个方法可以获得在用户设备上放置指定类型文件（音乐、图片等）的正确目录。</p>
<p><a href="https://developer.android.com/reference/android/view/View.htmlgenerateViewId%28%29" target="_blank" rel="external">View.generateViewId()</a>——每次我都想要推荐动态生成控件的ID。需要注意的是，不要和已经存在的控件ID或者其他已经生成的控件ID重复。</p>
<p><a href="https://developer.android.com/reference/android/app/ActivityManager.htmlclearApplicationUserData%28%29" target="_blank" rel="external">ActivityManager.clearApplicationUserData()</a>—— 一键清理你的app产生的用户数据，可能是做用户退出登录功能，有史以来最简单的方式了。</p>
<p><a href="http://developer.android.com/reference/android/content/Context.htmlcreateConfigurationContext%28android.%E2%80%94%E2%80%94ontent.res.Configuration%29" target="_blank" rel="external">Context.createConfigurationContext()</a> ——自定义你的配置环境信息。我通常会遇到这样的问题：强制让一部分显示在某个特定的环境下（倒不是我一直这样瞎整，说来话长，你很难理解）。用这个实现起来可以稍微简单一点。</p>
<p><a href="http://developer.android.com/reference/android/app/ActivityOptions.html" target="_blank" rel="external">ActivityOptions</a> ——方便的定义两个Activity切换的动画。 使用<a href="http://developer.android.com/reference/android/support/v4/app/ActivityOptionsCompat.html" target="_blank" rel="external">ActivityOptionsCompat</a> 可以很好解决旧版本的兼容问题。</p>
<p><a href="http://developer.android.com/reference/android/widget/AdapterViewFlipper.htmlfyiWillBeAdvancedByHostKThx%28%29" target="_blank" rel="external">AdapterViewFlipper.fyiWillBeAdvancedByHostKThx()</a>——仅仅因为很好玩，没有其他原因。在整个安卓开源项目中（AOSP the Android ——pen Source Project Android开放源代码项目）中还有其他很有意思的东西（比如<br><a href="http://developer.android.com/reference/android/hardware/SensorManager.htmlGRAVITY_DEATH_STAR_I" target="_blank" rel="external">GRAVITY_DEATH_STAR_I</a>）。不过，都不像这个这样，这个确实有用</p>
<p><a href="http://developer.android.com/reference/android/view/ViewParent.htmlrequestDisallowInterceptTouchEvent%28boolean%29" target="_blank" rel="external">ViewParent.requestDisallowInterceptTouchEvent()</a> ——Android系统触摸事件机制大多时候能够默认处理，不过有时候你需要使用这个方法来剥夺父级控件的控制权（顺便说一下，如果你想对Android触摸机制了解更多，<a href="https://www.youtube.com/watch?v=EZAoJU-nUyI" target="_blank" rel="external">这个演讲</a>会令你惊叹不已。）</p>
<h2 id="备忘">备忘</h2><p>More: <a href="http://www.androidperformance.com/android-tips-round-up.html" target="_blank" rel="external">Part1</a> , <a href="http://www.androidperformance.com/android-tips-round-up-2.html" target="_blank" rel="external">Part2</a> , <a href="http://www.androidperformance.com/android-tips-round-up-3.html" target="_blank" rel="external">Part3</a> , <a href="http://www.androidperformance.com/android-tips-round-up-4.html" target="_blank" rel="external">Part4</a>, <a href="http://www.androidperformance.com/android-tips-round-up-5.html" target="_blank" rel="external">Part5</a><br>原文地址:<a href="http://blog.danlew.net/2014/03/30/android-tips-round-up-part-5/" target="_blank" rel="external">http://blog.danlew.net/2014/03/30/android-tips-round-up-part-5/</a><br>原文作者:<a href="http://blog.danlew.net/about/" target="_blank" rel="external">http://blog.danlew.net/about/</a><br>本文地址:<a href="http://www.androidperformance.com/android-tips-round-up-5.html" target="_blank" rel="external">http://www.androidperformance.com/android-tips-round-up-5.html</a> 转载请注明.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文是一篇译文,这篇是这个系列的第五篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Android小技巧(4)]]></title>
    <link href="http://androidperformance.com/2015/03/15/android-tips-round-up-4.html"/>
    <id>http://androidperformance.com/2015/03/15/android-tips-round-up-4.html</id>
    <published>2015-03-14T16:31:02.000Z</published>
    <updated>2015-07-20T08:22:21.000Z</updated>
    <content type="html"><![CDATA[<p>本文是一篇译文,这篇是这个系列的第四篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<a id="more"></a>
<h2 id="正文">正文</h2><p><a href="http://developer.android.com/reference/android/app/Activity.html#isChangingConfigurations%28%29" target="_blank" rel="external">Activity.isChangingConfigurations ()</a>——如果在 Activity 中 configuration 会经常改变的话，使用这个方法就可以不用手动做保存状态的工作了。</p>
<p><a href="http://developer.android.com/reference/android/content/SearchRecentSuggestionsProvider.html" target="_blank" rel="external">SearchRecentSuggestionsProvider</a>——可以创建最近提示效果的 provider，是一个简单快速的方法。</p>
<p><a href="http://developer.android.com/reference/android/view/ViewTreeObserver.html" target="_blank" rel="external">ViewTreeObserver</a>——这是一个很棒的工具。可以进入到 VIew 里面，并监控 View 结构的各种状态，通常我都用来做 View 的测量操作（自定义视图中经常用到）。</p>
<p><a href="https://www.timroes.de/2013/09/12/speed-up-gradle/" target="_blank" rel="external">org.gradle.daemon=true</a>——这句话可以帮助减少 Gradle 构建的时间，仅在命令行编译的时候用到，因为 Android Studio 已经这样使用了。</p>
<p><a href="http://developer.android.com/reference/android/database/DatabaseUtils.html" target="_blank" rel="external">DatabaseUtils</a>——一个包含各种数据库操作的使用工具。</p>
<p><a href="http://developer.android.com/reference/android/widget/LinearLayout.html#attr_android:weightSum" target="_blank" rel="external">android:weightSum (LinearLayout)</a>——如果想使用 layout weights，但是却不想填充整个 LinearLayout 的话，就可以用 weightSum 来定义总的 weight 大小。</p>
<p><a href="http://developer.android.com/reference/android/view/View.html#attr_android:duplicateParentState" target="_blank" rel="external">android:duplicateParentState (View)</a>——此方法可以使得子 View 可以复制父 View 的状态。比如如果一个 ViewGroup 是可点击的，那么可以用这个方法在它被点击的时候让它的子 View 都改变状态。</p>
<p><a href="http://developer.android.com/reference/android/view/ViewGroup.html#attr_android:clipChildren" target="_blank" rel="external">android:clipChildren (ViewGroup)</a>——如果此属性设置为不可用，那么 ViewGroup 的子 View 在绘制的时候会超出它的范围，在做动画的时候需要用到。</p>
<p><a href="http://developer.android.com/reference/android/widget/ScrollView.html#attr_android:fillViewport" target="_blank" rel="external">android:fillViewport (ScrollView)</a>——在这片文章中有详细介绍<a href="http://www.curious-creature.org/2010/08/15/scrollviews-handy-trick/" target="_blank" rel="external">文章链接</a>，可以解决在 ScrollView 中当内容不足的时候填不满屏幕的问题。</p>
<p><a href="http://developer.android.com/guide/topics/resources/drawable-resource.html#Bitmap" target="_blank" rel="external">android:tileMode (BitmapDrawable)</a>——可以指定图片使用重复填充的模式。</p>
<p><a href="http://developer.android.com/reference/android/R.attr.html#exitFadeDuration" target="_blank" rel="external">android:enterFadeDuration/android:exitFadeDuration (Drawables)</a>——此属性在 Drawable 具有多种状态的时候，可以定义它展示前的淡入淡出效果。</p>
<p><a href="http://developer.android.com/reference/android/widget/ImageView.html#attr_android:scaleType" target="_blank" rel="external">android:scaleType (ImageView)</a>——定义在 ImageView 中怎么缩放/剪裁图片，一般用的比较多的是“centerCrop”和“centerInside”。</p>
<p><a href="http://developer.android.com/training/improving-layouts/reusing-layouts.html#Merge" target="_blank" rel="external">Merge</a>——此标签可以在另一个布局文件中包含别的布局文件，而不用再新建一个 ViewGroup，对于自定义 ViewGroup 的时候也需要用到；可以通过载入一个带有标签的布局文件来自动定义它的子部件。</p>
<p><a href="http://developer.android.com/reference/android/util/AtomicFile.html" target="_blank" rel="external">AtomicFile</a>——通过使用备份文件进行文件的原子化操作。这个知识点之前我也写过，不过最好还是有出一个官方的版本比较好。</p>
<h2 id="备忘">备忘</h2><p>More: <a href="http://www.androidperformance.com/android-tips-round-up.html" target="_blank" rel="external">Part1</a> , <a href="http://www.androidperformance.com/android-tips-round-up-2.html" target="_blank" rel="external">Part2</a> , <a href="http://www.androidperformance.com/android-tips-round-up-3.html" target="_blank" rel="external">Part3</a> , <a href="http://www.androidperformance.com/android-tips-round-up-4.html" target="_blank" rel="external">Part4</a>, <a href="http://www.androidperformance.com/android-tips-round-up-5.html" target="_blank" rel="external">Part5</a><br>原文地址:<a href="http://blog.danlew.net/2014/03/30/android-tips-round-up-part-4/" target="_blank" rel="external">http://blog.danlew.net/2014/03/30/android-tips-round-up-part-4/</a><br>原文作者:<a href="http://blog.danlew.net/about/" target="_blank" rel="external">http://blog.danlew.net/about/</a><br>本文地址:<a href="http://www.androidperformance.com/android-tips-round-up-4.html" target="_blank" rel="external">http://www.androidperformance.com/android-tips-round-up-4.html</a> 转载请注明.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文是一篇译文,这篇是这个系列的第四篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Android小技巧(3)]]></title>
    <link href="http://androidperformance.com/2015/03/15/android-tips-round-up-3.html"/>
    <id>http://androidperformance.com/2015/03/15/android-tips-round-up-3.html</id>
    <published>2015-03-14T16:29:57.000Z</published>
    <updated>2015-07-20T08:22:10.000Z</updated>
    <content type="html"><![CDATA[<p>本文是一篇译文,这篇是这个系列的第三篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<a id="more"></a>
<h2 id="正文">正文</h2><p><a href="http://developer.android.com/reference/android/net/UrlQuerySanitizer.html" target="_blank" rel="external">UrlQuerySanitizer</a>——使用这个工具可以方便对 URL 进行检查。</p>
<p><a href="http://developer.android.com/reference/android/app/Fragment.html#setArguments%28android.os.Bundle%29" target="_blank" rel="external">Fragment.setArguments</a>——因为在构建 Fragment 的时候不能加参数，所以这是个很好的东西，可以在创建 Fragment 之前设置参数（即使在 configuration 改变的时候仍然会导致销毁/重建）。</p>
<p><a href="http://developer.android.com/reference/android/app/DialogFragment.html#setShowsDialog%28boolean%29" target="_blank" rel="external">DialogFragment.setShowsDialog ()</a>—— 这是一个很巧妙的方式，DialogFragment 可以作为正常的 Fragment 显示！这里可以让 Fragment 承担双重任务。我通常在创建 Fragment 的时候把 onCreateView ()和 onCreateDialog ()都加上，就可以创建一个具有双重目的的 Fragment。</p>
<p><a href="http://developer.android.com/reference/android/app/FragmentManager.html#enableDebugLogging%28boolean%29" target="_blank" rel="external">FragmentManager.enableDebugLogging ()</a>——在需要观察 Fragment 状态的时候会有帮助。</p>
<p><a href="http://developer.android.com/reference/android/support/v4/content/LocalBroadcastManager.html" target="_blank" rel="external">LocalBroadcastManager</a>——这个会比全局的 broadcast 更加安全，简单，快速。像 <a href="http://square.github.io/otto/" target="_blank" rel="external">otto</a> 这样的 Event buses 机制对你的应用场景更加有用。</p>
<p><a href="http://developer.android.com/reference/android/telephony/PhoneNumberUtils.html#formatNumber%28java.lang.String%29" target="_blank" rel="external">PhoneNumberUtils.formatNumber ()</a>——顾名思义，这是对数字进行格式化操作的时候用的。</p>
<p><a href="http://developer.android.com/reference/android/graphics/Region.html#op%28android.graphics.Region,%20android.graphics.Region,%20android.graphics.Region.Op%29" target="_blank" rel="external">Region.op()</a>——我发现在对比两个渲染之前的区域的时候很实用，如果你有两条路径，那么怎么知道它们是不是会重叠呢？使用这个方法就可以做到。</p>
<p><a href="http://developer.android.com/reference/android/app/Application.html#registerActivityLifecycleCallbacks%28android.app.Application.ActivityLifecycleCallbacks%29" target="_blank" rel="external">Application.registerActivityLifecycleCallbacks</a>——虽然缺少官方文档解释，不过我想它就是注册 Activity 的生命周期的一些回调方法（顾名思义），就是一个方便的工具。</p>
<p><a href="http://tools.android.com/tech-docs/new-build-system/user-guide#TOC-Build-Types" target="_blank" rel="external">versionNameSuffix</a>——这个 gradle 设置可以让你在基于不同构建类型的 manifest 中修改版本名这个属性，例如，如果需要在在 debug 版本中以”-SNAPSHOT”结尾，那么就可以轻松的看出当前是 debug 版还是 release 版。</p>
<p><a href="http://developer.android.com/reference/android/database/CursorJoiner.html" target="_blank" rel="external">CursorJoiner</a>——如果你是只使用一个数据库的话，使用 SQL 中的 join 就可以了，但是如果收到的数据是来自两个独立的 ContentProvider，那么 CursorJoiner 就很实用了。</p>
<p><a href="http://www.genymotion.com/" target="_blank" rel="external">Genymotion</a>——一个非常快的 Android 模拟器，本人一直在用。</p>
<p><a href="http://developer.android.com/guide/practices/screens_support.html#qualifiers" target="_blank" rel="external">-nodpi</a>——在没有特别定义的情况下，很多修饰符(-mdpi,-hdpi,-xdpi等等)都会默认自动缩放 assets/dimensions，有时候我们需要保持显示一致，这种情况下就可以使用 -nodpi。</p>
<p><a href="http://developer.android.com/reference/android/content/BroadcastReceiver.html#setDebugUnregister%28boolean%29" target="_blank" rel="external">BroadcastRecevier.setDebugUnregister ()</a>——又一个方便的调试工具。</p>
<p><a href="http://developer.android.com/reference/android/app/Activity.html#recreate%28%29" target="_blank" rel="external">Activity.recreate ()</a>——强制让 Activity 重建。</p>
<p><a href="http://developer.android.com/reference/android/content/pm/PackageManager.html#checkSignatures%28java.lang.String,%20java.lang.String%29" target="_blank" rel="external">PackageManager.checkSignatures ()</a>——如果同时安装了两个 app 的话，可以用这个方法检查。如果不进行签名检查的话，其他人可以轻易通过使用一样的包名来模仿你的 app。</p>
<h2 id="备忘">备忘</h2><p>More: <a href="http://www.androidperformance.com/android-tips-round-up.html" target="_blank" rel="external">Part1</a> , <a href="http://www.androidperformance.com/android-tips-round-up-2.html" target="_blank" rel="external">Part2</a> , <a href="http://www.androidperformance.com/android-tips-round-up-3.html" target="_blank" rel="external">Part3</a> , <a href="http://www.androidperformance.com/android-tips-round-up-4.html" target="_blank" rel="external">Part4</a>, <a href="http://www.androidperformance.com/android-tips-round-up-5.html" target="_blank" rel="external">Part5</a><br>原文地址:<a href="http://blog.danlew.net/2014/03/30/android-tips-round-up-part-3/" target="_blank" rel="external">http://blog.danlew.net/2014/03/30/android-tips-round-up-part-3/</a><br>原文作者:<a href="http://blog.danlew.net/about/" target="_blank" rel="external">http://blog.danlew.net/about/</a><br>本文地址:<a href="http://www.androidperformance.com/android-tips-round-up-3.html" target="_blank" rel="external">http://www.androidperformance.com/android-tips-round-up-3.html</a> 转载请注明.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文是一篇译文,这篇是这个系列的第三篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为Nexus5编译AndroidL固件]]></title>
    <link href="http://androidperformance.com/2015/02/04/build-rom-for-nexus5.html"/>
    <id>http://androidperformance.com/2015/02/04/build-rom-for-nexus5.html</id>
    <published>2015-02-04T12:51:19.000Z</published>
    <updated>2015-04-01T13:11:05.000Z</updated>
    <content type="html"><![CDATA[<p>接前一篇文章<a href="http://www.androidperformance.com/view-android-source-code-with-androidstudio.html" target="_blank" rel="external">使用Android Studio查看Android Lollipop源码</a>, 我们知道,仅仅看代码,提高是比较有限的,而且理解起来也比较肤浅,往往过目就忘. 而自己写过的代码,往往会印象比较深刻,在写的时候也会比较容易理解流程. 所以我们在看代码的同时, 如果能修改代码, 在手机上跑起来并看到修改的效果,这无疑会加快看代码的效率和积极性. 所以这篇文章,就讲解一下如何自己编译AndroidL的源码,并且在Nexus5上跑起来. 至于为何需要自己编译固件,而不是直接安装Google给出的工厂固件?原因是Google给出的工厂固件是User版本,是没法随心所欲Push东西进去的. 所以我们需要编译自己的Userdebug版本.</p>
<p>本文假设你已经下载了AndroidL的源码,并且有一台Nexus5手机(手机系统开发人员必备), 如果你还没有AndroidL的源码,或者你有源码但是没有配置编译的环境,那么 <a href="https://source.android.com/source/initializing.html" target="_blank" rel="external">Initializing a Build Environment</a> 和<a href="https://source.android.com/source/downloading.html" target="_blank" rel="external">Downloading the Source</a>这两篇文章你应该先去看一下(我又一次假设你会翻墙,如果你不会翻墙,那么下代码也是一个痛苦的事情). 这后面的教程Google官网也有教程.所以我只针对Nexus5进行讲解.</p>
<p>另外你需要知道AOSP,AOSP即Android Open Source Project 汉语意思是：谷歌开放源代码项目.我们通过Google官方下载的源代码,就是AOSP的代码, 其中是不包含Google开发的那些个应用的,各个厂商拿到的也是这个版本,在这个版本的基础上进行修改. 而Google发布的工厂固件则是包含全套Google服务的. 厂商如果想安装Google服务,就需要过Google的那一套认证,比较麻烦,而且价格不菲,鉴于Google在国内的尴尬地位,国内很多厂商都没有过这个认证.</p>
<a id="more"></a>
<h3 id="1-_初始化编译环境">1. 初始化编译环境</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">. </span>build/envsetup.sh</span><br></pre></td></tr></table></figure>
<h3 id="2-_加载机型">2. 加载机型</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lunch</span><br></pre></td></tr></table></figure>
<h3 id="3-_选择要编译的机器">3. 选择要编译的机器</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">You're building <span class="function_start"><span class="keyword">on</span></span> Linux</span><br><span class="line"></span><br><span class="line">Lunch menu... pick a combo:</span><br><span class="line">     <span class="number">1.</span> aosp_arm-eng</span><br><span class="line">     <span class="number">2.</span> aosp_arm64-eng</span><br><span class="line">     <span class="number">3.</span> aosp_mips-eng</span><br><span class="line">     <span class="number">4.</span> aosp_mips64-eng</span><br><span class="line">     <span class="number">5.</span> aosp_x86-eng</span><br><span class="line">     <span class="number">6.</span> aosp_x86_64-eng</span><br><span class="line">     <span class="number">7.</span> aosp_shamu-userdebug</span><br><span class="line">     <span class="number">8.</span> aosp_manta-userdebug</span><br><span class="line">     <span class="number">9.</span> full_fugu-userdebug</span><br><span class="line">     <span class="number">10.</span> aosp_fugu-userdebug</span><br><span class="line">     <span class="number">11.</span> aosp_grouper-userdebug</span><br><span class="line">     <span class="number">12.</span> aosp_tilapia-userdebug</span><br><span class="line">     <span class="number">13.</span> aosp_deb-userdebug</span><br><span class="line">     <span class="number">14.</span> aosp_flo-userdebug</span><br><span class="line">     <span class="number">15.</span> aosp_mako-userdebug</span><br><span class="line">     <span class="number">16.</span> aosp_hammerhead-userdebug</span><br><span class="line">     <span class="number">17.</span> aosp_flounder-userdebug</span><br><span class="line">     <span class="number">18.</span> mini_emulator_x86_64-userdebug</span><br><span class="line">     <span class="number">19.</span> mini_emulator_arm-userdebug</span><br><span class="line">     <span class="number">20.</span> mini_emulator_x86-userdebug</span><br><span class="line">     <span class="number">21.</span> mini_emulator_mips-userdebug</span><br><span class="line">     <span class="number">22.</span> mini_emulator_arm64-userdebug</span><br></pre></td></tr></table></figure>
<h4 id="3-1_机型对照表">3.1 机型对照表</h4><table>
<thead>
<tr>
<th>DEVICE</th>
<th>CODE NAME</th>
<th>BUILD CONFIGURATION</th>
</tr>
</thead>
<tbody>
<tr>
<td>Nexus 6</td>
<td>shamu</td>
<td>aosp_shamu-userdebug</td>
</tr>
<tr>
<td>Nexus Player</td>
<td>fugu</td>
<td>aosp_fugu-userdebug</td>
</tr>
<tr>
<td>Nexus 9</td>
<td>volantis (flounder)</td>
<td>aosp_flounder-userdebug</td>
</tr>
<tr>
<td>Nexus 5 (GSM/LTE)</td>
<td>hammerhead</td>
<td>aosp_hammerhead-userdebug</td>
</tr>
<tr>
<td>Nexus 7 (Wi-Fi)</td>
<td>razor (flo)</td>
<td>aosp_flo-userdebug</td>
</tr>
<tr>
<td>Nexus 7 (Mobile)</td>
<td>razorg (deb)</td>
<td>aosp_deb-userdebug</td>
</tr>
<tr>
<td>Nexus 10</td>
<td>mantaray (manta)</td>
<td>full_manta-userdebug</td>
</tr>
<tr>
<td>Nexus 4</td>
<td>occam (mako)</td>
<td>full_mako-userdebug</td>
</tr>
<tr>
<td>Nexus 7 (Wi-Fi)</td>
<td>nakasi (grouper)</td>
<td>full_grouper-userdebug</td>
</tr>
<tr>
<td>Nexus 7 (Mobile)</td>
<td>nakasig (tilapia)</td>
<td>full_tilapia-userdebug</td>
</tr>
<tr>
<td>Galaxy Nexus (GSM/HSPA+)</td>
<td>yakju (maguro)</td>
<td>full_maguro-userdebug</td>
</tr>
<tr>
<td>Galaxy Nexus (Verizon)</td>
<td>mysid (toro)</td>
<td>aosp_toro-userdebug</td>
</tr>
<tr>
<td>Galaxy Nexus (Experimental)</td>
<td>mysidspr (toroplus)</td>
<td>aosp_toroplus-userdebug</td>
</tr>
<tr>
<td>PandaBoard (Archived)</td>
<td>panda</td>
<td>aosp_panda-userdebug</td>
</tr>
<tr>
<td>Motorola Xoom (U.S. Wi-Fi)</td>
<td>wingray</td>
<td>full_wingray-userdebug</td>
</tr>
<tr>
<td>Nexus S</td>
<td>soju (crespo)</td>
<td>full_crespo-userdebug</td>
</tr>
<tr>
<td>Nexus S 4G</td>
<td>sojus (crespo4g)</td>
<td>full_crespo4g-userdebug3.2</td>
</tr>
</tbody>
</table>
<h4 id="3-2_三个版本说明版本">3.2 三个版本说明版本</h4><table>
<thead>
<tr>
<th>BUILDTYPE</th>
<th>USE</th>
</tr>
</thead>
<tbody>
<tr>
<td>user</td>
<td>limited access; suited for production</td>
</tr>
<tr>
<td>userdebug</td>
<td>like “user” but with root access and debuggability; preferred for debugging</td>
</tr>
<tr>
<td>eng</td>
<td>development configuration with additional debugging tools</td>
</tr>
</tbody>
</table>
<p>选择aosp_hammerhead-userdebug之后,会有下面的确认信息:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">============================================</span><br><span class="line"><span class="constant">PLATFORM_VERSION_CODENAME</span>=REL</span><br><span class="line"><span class="constant">PLATFORM_VERSION</span>=5.0.50.50.50.50</span><br><span class="line"><span class="constant">TARGET_PRODUCT</span>=aosp_hammerhead</span><br><span class="line"><span class="constant">TARGET_BUILD_VARIANT</span>=userdebug</span><br><span class="line"><span class="constant">TARGET_BUILD_TYPE</span>=release</span><br><span class="line"><span class="constant">TARGET_BUILD_APPS</span>=</span><br><span class="line"><span class="constant">TARGET_ARCH</span>=arm</span><br><span class="line"><span class="constant">TARGET_ARCH_VARIANT</span>=armv7-a-neon</span><br><span class="line"><span class="constant">TARGET_CPU_VARIANT</span>=krait</span><br><span class="line"><span class="constant">TARGET_2ND_ARCH</span>=</span><br><span class="line"><span class="constant">TARGET_2ND_ARCH_VARIANT</span>=</span><br><span class="line"><span class="constant">TARGET_2ND_CPU_VARIANT</span>=</span><br><span class="line"><span class="constant">HOST_ARCH</span>=x86_64</span><br><span class="line"><span class="constant">HOST_OS</span>=linux</span><br><span class="line"><span class="constant">HOST_OS_EXTRA</span>=Linux-3.13.0-37-generic-x86_64-with-Ubuntu-14.10-utopic</span><br><span class="line"><span class="constant">HOST_BUILD_TYPE</span>=release</span><br><span class="line"><span class="constant">BUILD_ID</span>=AOSP</span><br><span class="line"><span class="constant">OUT_DIR</span>=out</span><br><span class="line">============================================</span><br></pre></td></tr></table></figure>
<h3 id="4-_生成驱动目录">4. 生成驱动目录</h3><p>接下来需要在<a href="https://developers.google.com/android/nexus/drivers#hammerheadlrx22c" target="_blank" rel="external">Android官网</a>下载 Nexus5所需要的驱动:</p>
<table>
<thead>
<tr>
<th>HARDWARE COMPONENT</th>
<th>COMPANY</th>
<th>DOWNLOAD</th>
<th>MD5 CHECKSUM</th>
<th>SHA-1 CHECKSUM</th>
</tr>
</thead>
<tbody>
<tr>
<td>NFC, Bluetooth, Wi-Fi</td>
<td>Broadcom</td>
<td><a href="https://dl.google.com/dl/android/aosp/broadcom-hammerhead-lrx22c-964d941e.tgz" target="_blank" rel="external">Link</a></td>
<td>2c398994e37093df51b105d63f0eb611</td>
<td>991346159c95ae75f760014a6822b8b3e8667700</td>
</tr>
<tr>
<td>Camera, Sensors, Audio</td>
<td>LG</td>
<td><a href="https://dl.google.com/dl/android/aosp/lge-hammerhead-lrx22c-95a9d465.tgz" target="_blank" rel="external">Link</a></td>
<td>74cf8235e6bb04da28b2ff738b13eee9</td>
<td>175dd5bae81bb54030d072cb0f0b4ec81eb3f71f</td>
</tr>
<tr>
<td>Graphics, GSM, Camera, GPS, Sensors, Media, DSP, USB</td>
<td>Qualcomm</td>
<td><a href="https://dl.google.com/dl/android/aosp/lge-hammerhead-lrx22c-95a9d465.tgz" target="_blank" rel="external">Link</a></td>
<td>0a43395e175d3de3dc312d8abdcb4f20</td>
<td>007cf9d49f0409d5c703e7f2811fd153fee22353</td>
</tr>
</tbody>
</table>
<p>下载完成后,解压出来是三个.sh文件,放到Android源码目录下面,然后执行.会将相关驱动放到vender目录下面.</p>
<h3 id="5-_执行编译命令">5. 执行编译命令</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span> -j8</span><br></pre></td></tr></table></figure>
<p>如果没有出错的话,在经过漫长的时间之后,编译成功:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Installed file <span class="string">list:</span> out<span class="regexp">/target/</span>product<span class="regexp">/hammerhead/</span>installed-files.txt</span><br><span class="line">Target system fs <span class="string">image:</span> out<span class="regexp">/target/</span>product<span class="regexp">/hammerhead/</span>obj<span class="regexp">/PACKAGING/</span>systemimage_intermediates/system.img</span><br><span class="line"><span class="string">Running:</span>  mkuserimg.sh -s out<span class="regexp">/target/</span>product<span class="regexp">/hammerhead/</span>system out<span class="regexp">/target/</span>product<span class="regexp">/hammerhead/</span>obj<span class="regexp">/PACKAGING/</span>systemimage_intermediates<span class="regexp">/system.img ext4 system 1073741824 -L system out/</span>target<span class="regexp">/product/</span>hammerhead<span class="regexp">/root/</span>file_contexts</span><br><span class="line">make_ext4fs -s -T -<span class="number">1</span> -S out<span class="regexp">/target/</span>product<span class="regexp">/hammerhead/</span>root<span class="regexp">/file_contexts -L system -l 1073741824 -a system out/</span>target<span class="regexp">/product/</span>hammerhead<span class="regexp">/obj/</span>PACKAGING<span class="regexp">/systemimage_intermediates/</span>system.img out<span class="regexp">/target/</span>product<span class="regexp">/hammerhead/</span>system</span><br><span class="line">Creating filesystem with <span class="string">parameters:</span></span><br><span class="line"><span class="label">    Size:</span> <span class="number">1073741824</span></span><br><span class="line">    Block <span class="string">size:</span> <span class="number">4096</span></span><br><span class="line">    Blocks per <span class="string">group:</span> <span class="number">32768</span></span><br><span class="line">    Inodes per <span class="string">group:</span> <span class="number">8192</span></span><br><span class="line">    Inode <span class="string">size:</span> <span class="number">256</span></span><br><span class="line">    Journal <span class="string">blocks:</span> <span class="number">4096</span></span><br><span class="line"><span class="label">    Label:</span> system</span><br><span class="line"><span class="label">    Blocks:</span> <span class="number">262144</span></span><br><span class="line">    Block <span class="string">groups:</span> <span class="number">8</span></span><br><span class="line">    Reserved block group <span class="string">size:</span> <span class="number">63</span></span><br><span class="line">Created filesystem with <span class="number">1445</span><span class="regexp">/65536 inodes and 85879/</span><span class="number">262144</span> blocks</span><br><span class="line">Install system fs <span class="string">image:</span> out<span class="regexp">/target/</span>product<span class="regexp">/hammerhead/</span>system.img</span><br><span class="line">out<span class="regexp">/target/</span>product<span class="regexp">/hammerhead/</span>system.img+out<span class="regexp">/target/</span>product<span class="regexp">/hammerhead/</span>obj<span class="regexp">/PACKAGING/</span>recovery_patch_intermediates/recovery_from_boot.p maxsize=<span class="number">1096212480</span> blocksize=<span class="number">135168</span> total=<span class="number">336629666</span> reserve=<span class="number">11083776</span></span><br></pre></td></tr></table></figure>
<h3 id="6-_刷机命令">6. 刷机命令</h3><p>Nexus5关机状态下,长按音量下+电源,即可进入recovery模式, 然后在源码根目录下执行下面命令:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fastboot</span> -w flashall</span><br></pre></td></tr></table></figure>
<p>刷机成功后会自动重启</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">~/<span class="name">Android</span>-<span class="name">SourceCode</span> <span class="atom">fastboot</span> -<span class="atom">w</span> <span class="atom">flashall</span></span><br><span class="line"><span class="atom">target</span> <span class="atom">reported</span> <span class="atom">max</span> <span class="atom">download</span> <span class="atom">size</span> <span class="atom">of</span> <span class="number">1073741824</span> <span class="atom">bytes</span></span><br><span class="line"><span class="name">Creating</span> <span class="atom">filesystem</span> <span class="atom">with</span> <span class="atom">parameters</span>:</span><br><span class="line">    <span class="name">Size</span>: <span class="number">13725835264</span></span><br><span class="line">    <span class="name">Block</span> <span class="atom">size</span>: <span class="number">4096</span></span><br><span class="line">    <span class="name">Blocks</span> <span class="atom">per</span> <span class="atom">group</span>: <span class="number">32768</span></span><br><span class="line">    <span class="name">Inodes</span> <span class="atom">per</span> <span class="atom">group</span>: <span class="number">8144</span></span><br><span class="line">    <span class="name">Inode</span> <span class="atom">size</span>: <span class="number">256</span></span><br><span class="line">    <span class="name">Journal</span> <span class="atom">blocks</span>: <span class="number">32768</span></span><br><span class="line">    <span class="name">Label</span>: </span><br><span class="line">    <span class="name">Blocks</span>: <span class="number">3351034</span></span><br><span class="line">    <span class="name">Block</span> <span class="atom">groups</span>: <span class="number">103</span></span><br><span class="line">    <span class="name">Reserved</span> <span class="atom">block</span> <span class="atom">group</span> <span class="atom">size</span>: <span class="number">823</span></span><br><span class="line"><span class="name">Created</span> <span class="atom">filesystem</span> <span class="atom">with</span> <span class="number">11</span>/<span class="number">838832</span> <span class="atom">inodes</span> <span class="atom">and</span> <span class="number">93654</span>/<span class="number">3351034</span> <span class="atom">blocks</span></span><br><span class="line"><span class="name">Creating</span> <span class="atom">filesystem</span> <span class="atom">with</span> <span class="atom">parameters</span>:</span><br><span class="line">    <span class="name">Size</span>: <span class="number">734003200</span></span><br><span class="line">    <span class="name">Block</span> <span class="atom">size</span>: <span class="number">4096</span></span><br><span class="line">    <span class="name">Blocks</span> <span class="atom">per</span> <span class="atom">group</span>: <span class="number">32768</span></span><br><span class="line">    <span class="name">Inodes</span> <span class="atom">per</span> <span class="atom">group</span>: <span class="number">7472</span></span><br><span class="line">    <span class="name">Inode</span> <span class="atom">size</span>: <span class="number">256</span></span><br><span class="line">    <span class="name">Journal</span> <span class="atom">blocks</span>: <span class="number">2800</span></span><br><span class="line">    <span class="name">Label</span>: </span><br><span class="line">    <span class="name">Blocks</span>: <span class="number">179200</span></span><br><span class="line">    <span class="name">Block</span> <span class="atom">groups</span>: <span class="number">6</span></span><br><span class="line">    <span class="name">Reserved</span> <span class="atom">block</span> <span class="atom">group</span> <span class="atom">size</span>: <span class="number">47</span></span><br><span class="line"><span class="name">Created</span> <span class="atom">filesystem</span> <span class="atom">with</span> <span class="number">11</span>/<span class="number">44832</span> <span class="atom">inodes</span> <span class="atom">and</span> <span class="number">5813</span>/<span class="number">179200</span> <span class="atom">blocks</span></span><br><span class="line">--------------------------------------------</span><br><span class="line"><span class="name">Bootloader</span> <span class="name">Version</span>...: <span class="name">HHZ12d</span></span><br><span class="line"><span class="name">Baseband</span> <span class="name">Version</span>.....: <span class="name">M8974A</span>-<span class="number">2.0</span><span class="number">.50</span><span class="number">.2</span><span class="number">.22</span></span><br><span class="line"><span class="name">Serial</span> <span class="name">Number</span>........: <span class="number">08</span><span class="atom">ade1a513dc087b</span></span><br><span class="line">--------------------------------------------</span><br><span class="line"><span class="atom">checking</span> <span class="atom">product</span>...</span><br><span class="line"><span class="name">OKAY</span> [  <span class="number">0.100</span><span class="atom">s</span>]</span><br><span class="line"><span class="atom">sending</span> <span class="string">'boot'</span> (<span class="number">8950</span> <span class="name">KB</span>)...</span><br><span class="line"><span class="name">OKAY</span> [  <span class="number">0.500</span><span class="atom">s</span>]</span><br><span class="line"><span class="atom">writing</span> <span class="string">'boot'</span>...</span><br><span class="line"><span class="name">OKAY</span> [  <span class="number">0.784</span><span class="atom">s</span>]</span><br><span class="line"><span class="atom">sending</span> <span class="string">'recovery'</span> (<span class="number">9672</span> <span class="name">KB</span>)...</span><br><span class="line"><span class="name">OKAY</span> [  <span class="number">0.556</span><span class="atom">s</span>]</span><br><span class="line"><span class="atom">writing</span> <span class="string">'recovery'</span>...</span><br><span class="line"><span class="name">OKAY</span> [  <span class="number">0.814</span><span class="atom">s</span>]</span><br><span class="line"><span class="atom">erasing</span> <span class="string">'system'</span>...</span><br><span class="line"><span class="name">OKAY</span> [  <span class="number">1.166</span><span class="atom">s</span>]</span><br><span class="line"><span class="atom">sending</span> <span class="string">'system'</span> (<span class="number">328187</span> <span class="name">KB</span>)...</span><br><span class="line"><span class="name">OKAY</span> [ <span class="number">10.501</span><span class="atom">s</span>]</span><br><span class="line"><span class="atom">writing</span> <span class="string">'system'</span>...</span><br><span class="line"><span class="name">OKAY</span> [ <span class="number">23.623</span><span class="atom">s</span>]</span><br><span class="line"><span class="atom">erasing</span> <span class="string">'userdata'</span>...</span><br><span class="line"><span class="name">OKAY</span> [ <span class="number">14.657</span><span class="atom">s</span>]</span><br><span class="line"><span class="atom">sending</span> <span class="string">'userdata'</span> (<span class="number">137318</span> <span class="name">KB</span>)...</span><br><span class="line"><span class="name">OKAY</span> [  <span class="number">4.520</span><span class="atom">s</span>]</span><br><span class="line"><span class="atom">writing</span> <span class="string">'userdata'</span>...</span><br><span class="line"><span class="name">OKAY</span> [  <span class="number">9.776</span><span class="atom">s</span>]</span><br><span class="line"><span class="atom">erasing</span> <span class="string">'cache'</span>...</span><br><span class="line"><span class="name">OKAY</span> [  <span class="number">0.618</span><span class="atom">s</span>]</span><br><span class="line"><span class="atom">sending</span> <span class="string">'cache'</span> (<span class="number">13348</span> <span class="name">KB</span>)...</span><br><span class="line"><span class="name">OKAY</span> [  <span class="number">0.630</span><span class="atom">s</span>]</span><br><span class="line"><span class="atom">writing</span> <span class="string">'cache'</span>...</span><br><span class="line"><span class="name">OKAY</span> [  <span class="number">1.070</span><span class="atom">s</span>]</span><br><span class="line"><span class="atom">rebooting</span>...</span><br><span class="line"></span><br><span class="line"><span class="atom">finished</span>. <span class="atom">total</span> <span class="atom">time</span>: <span class="number">70.095</span><span class="atom">s</span></span><br></pre></td></tr></table></figure>
<h3 id="7-秀桌面">7.秀桌面</h3><p><img src="/images/build-image-for-nexus-5/Nexus5.png" alt="image"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>接前一篇文章<a href="http://www.androidperformance.com/view-android-source-code-with-androidstudio.html">使用Android Studio查看Android Lollipop源码</a>, 我们知道,仅仅看代码,提高是比较有限的,而且理解起来也比较肤浅,往往过目就忘. 而自己写过的代码,往往会印象比较深刻,在写的时候也会比较容易理解流程. 所以我们在看代码的同时, 如果能修改代码, 在手机上跑起来并看到修改的效果,这无疑会加快看代码的效率和积极性. 所以这篇文章,就讲解一下如何自己编译AndroidL的源码,并且在Nexus5上跑起来. 至于为何需要自己编译固件,而不是直接安装Google给出的工厂固件?原因是Google给出的工厂固件是User版本,是没法随心所欲Push东西进去的. 所以我们需要编译自己的Userdebug版本.</p>
<p>本文假设你已经下载了AndroidL的源码,并且有一台Nexus5手机(手机系统开发人员必备), 如果你还没有AndroidL的源码,或者你有源码但是没有配置编译的环境,那么 <a href="https://source.android.com/source/initializing.html">Initializing a Build Environment</a> 和<a href="https://source.android.com/source/downloading.html">Downloading the Source</a>这两篇文章你应该先去看一下(我又一次假设你会翻墙,如果你不会翻墙,那么下代码也是一个痛苦的事情). 这后面的教程Google官网也有教程.所以我只针对Nexus5进行讲解.</p>
<p>另外你需要知道AOSP,AOSP即Android Open Source Project 汉语意思是：谷歌开放源代码项目.我们通过Google官方下载的源代码,就是AOSP的代码, 其中是不包含Google开发的那些个应用的,各个厂商拿到的也是这个版本,在这个版本的基础上进行修改. 而Google发布的工厂固件则是包含全套Google服务的. 厂商如果想安装Google服务,就需要过Google的那一套认证,比较麻烦,而且价格不菲,鉴于Google在国内的尴尬地位,国内很多厂商都没有过这个认证.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android性能优化之Systrace工具介绍(一)]]></title>
    <link href="http://androidperformance.com/2015/01/30/android-performance-tools-systrace-1.html"/>
    <id>http://androidperformance.com/2015/01/30/android-performance-tools-systrace-1.html</id>
    <published>2015-01-30T12:24:31.000Z</published>
    <updated>2015-04-01T13:17:14.000Z</updated>
    <content type="html"><![CDATA[<p> 本文是Android性能优化工具系列的第一篇，这个系列主要介绍Android性能优化过程中会使用到的一些工具，以及如何用这些工具来发现问题和解决问题。在性能优化方面，Android有不少性能工具供大家来使用，按照我们一贯地 “发现问题-解决问题”的思路来看，发现问题才是最主要的，一上来就想着如何去解决问题，反而会事倍功半。</p>
<p>这一篇先来简单介绍一下Systrace这个工具。</p>
<h2 id="Systrace简单介绍">Systrace简单介绍</h2><p>Systrace是Android4.1中新增的性能数据采样和分析工具。它可帮助开发者收集Android关键子系统（如surfaceflinger、WindowManagerService等Framework部分关键模块、服务，View系统等）的运行信息，从而帮助开发者更直观的分析系统瓶颈，改进性能。</p>
<p>Systrace的功能包括跟踪系统的I/O操作、内核工作队列、CPU负载以及Android各个子系统的运行状况等。在Android平台中，它主要由3部分组成：</p>
<ul>
<li>内核部分：Systrace利用了Linux Kernel中的ftrace功能。所以，如果要使用Systrace的话，必须开启kernel中和ftrace相关的模块。</li>
<li>数据采集部分：Android定义了一个Trace类。应用程序可利用该类把统计信息输出给ftrace。同时，Android还有一个atrace程序，它可以从ftrace中读取统计信息然后交给数据分析工具来处理。</li>
<li>数据分析工具：Android提供一个systrace.py（python脚本文件，位于Android SDK目录/tools/systrace中，其内部将调用atrace程序）用来配置数据采集的方式（如采集数据的标签、输出文件名等）和收集ftrace统计数据并生成一个结果网页文件供用户查看。 从本质上说，Systrace是对Linux Kernel中ftrace的封装。应用进程需要利用Android提供的Trace类来使用Systrace.<br>关于Systrace的官方介绍和使用可以看这里：<a href="http://developer.android.com/tools/help/systrace.html" title="SysTrace官方介绍" target="_blank" rel="external">Systrace</a></li>
</ul>
<a id="more"></a>
<h2 id="Systrace简单使用">Systrace简单使用</h2><p>使用Systrace前，要先了解一下Systrace在各个平台上的使用方法，鉴于大家使用Eclipse和Android Studio的居多，所以直接摘抄官网关于这个的使用方法，不过不管是什么工具，流程是一样的：</p>
<ul>
<li>手机准备好你要进行抓取的界面</li>
<li>点击开始抓取（命令行的话就是开始执行命令）</li>
<li>手机上开始操作</li>
<li>设定好的时间到了之后，会将生成Trace文件，使用Chrome将这个文件打开进行分析</li>
</ul>
<h4 id="Using_Eclipse">Using <strong>Eclipse</strong></h4><ol>
<li><p>In Eclipse, open an Android application project.</p>
<ol>
<li>Switch to the DDMS perspective, by selecting Window &gt; Perspectives &gt; DDMS.</li>
<li>In the Devices tab, select the device on which to run a trace. If no devices are listed, make sure your device is connected via USB cable and that debugging is enabled on the device.</li>
<li>Click the Systrace icon at the top of the Devices panel to configure tracing.</li>
<li>Set the tracing options and click OK to start the trace.</li>
</ol>
</li>
</ol>
<h4 id="Using_Android_Studio">Using <strong> Android Studio</strong></h4><ol>
<li><p>In Android Studio, open an Android application project.</p>
<ol>
<li>Open the Device Monitor by selecting Tools &gt; Android &gt; Monitor.</li>
<li>In the Devices tab, select the device on which to run a trace. If no devices are listed, make sure your device is connected via USB cable and that debugging is enabled on the device.</li>
<li>Click the Systrace icon at the top of the Devices panel to configure tracing.</li>
<li>Set the tracing options and click OK to start the trace.</li>
</ol>
</li>
</ol>
<h4 id="Using_Device_Monitor">Using <strong>Device Monitor</strong></h4><ol>
<li><p>Navigate to your SDK tools/ directory.</p>
<ol>
<li>Run the monitor program.</li>
<li>In the Devices tab, select the device on which to run a trace. If no devices are listed, make sure your device is connected via USB cable and that debugging is enabled on the device.</li>
<li>Click the Systrace icon at the top of the Devices panel to configure tracing.</li>
<li>Set the tracing options and click OK to start the trace.</li>
</ol>
</li>
</ol>
<h4 id="Command_Line_Usage">Command Line Usage</h4><p>命令行形式比较灵活，速度也比较快，一次性配置好之后，以后再使用的时候就会很快就出结果（<strong>强烈推荐</strong>）</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd android-sdk/platform-tools/systrace</span><br><span class="line">$ python systrace<span class="class">.py</span> --time=<span class="number">10</span> -o mynewtrace<span class="class">.html</span> sched gfx view wm</span><br></pre></td></tr></table></figure>
<p>从上面的命令可以看到Systrace工具的位置，只需要在Bash中配置好对应的路径和Alias，使用起来还是很快速的。另外User版本是不可以抓Trace的，只有ENG版本或者Userdebug版本才可以。</p>
<p>抓取结束后，会生成对应的Trace文件，注意这个文件只能被Chrome打开。关于如何分析Trace文件，我们下面的章节会讲。不论使用那种工具，在抓取之前都会让选择参数，下面说一下这些参数的意思：</p>
<ul>
<li>-h, –help Show the help message.（帮助）</li>
<li>-o  Write the HTML trace report to the specified file.（即输出文件名，）</li>
<li>-t N, –time=N Trace activity for N seconds. The default value is 5 seconds. （Trace抓取的时间，一般是 ： -t 8）</li>
<li>-b N, –buf-size=N Use a trace buffer size of N kilobytes. This option lets you limit the total size of the data collected during a trace.</li>
<li>-k</li>
<li>—ktrace= Trace the activity of specific kernel functions, specified in a comma-separated list.</li>
<li><p>-l, –list-categories List the available tracing category tags. The available tags are(下面的参数不用翻译了估计大家也看得懂，贴官方的解释也会比较权威，后面分析的时候我们会看到这些参数的作业的):</p>
<ul>
<li><strong>gfx</strong> - Graphics</li>
<li><strong>input</strong> - Input</li>
<li><strong>view</strong> - View</li>
<li>webview - WebView</li>
<li><strong>wm</strong> - Window Manager</li>
<li><strong>am</strong> - Activity Manager</li>
<li>audio - Audio</li>
<li>video - Video</li>
<li>camera - Camera</li>
<li>hal - Hardware Modules</li>
<li>res - Resource Loading</li>
<li><strong>dalvik</strong> - Dalvik VM</li>
<li>rs - RenderScript</li>
<li><strong>sched</strong> - CPU Scheduling</li>
<li><strong>freq</strong> - CPU Frequency</li>
<li><strong>membus</strong> - Memory Bus Utilization</li>
<li><strong>idle</strong> - CPU Idle</li>
<li><strong>disk</strong> - Disk input and output</li>
<li><strong>load</strong> - CPU Load</li>
<li><strong>sync</strong> - Synchronization Manager</li>
<li><strong>workq</strong> - Kernel Workqueues Note: Some trace categories are not supported on all devices. Tip: If you want to see the names of tasks in the trace output, you must include the sched category in your command parameters.</li>
</ul>
</li>
<li><p>-a</p>
</li>
<li>—app= Enable tracing for applications, specified as a comma-separated list of package names. The apps must contain tracing instrumentation calls from the Trace class. For more information, see Analyzing Display and Performance.</li>
<li>—link-assets Link to the original CSS or JavaScript resources instead of embedding them in the HTML trace report.</li>
<li>—from-file= Create the interactive Systrace report from a file, instead of running a live trace.</li>
<li>—asset-dir= Specify a directory for the trace report assets. This option is useful for maintaining a single set of assets for multiple Systrace reports.</li>
<li>-e</li>
<li>—serial= Conduct the trace on a specific connected device, identified by its device serial number.<br>上面的参数虽然比较多，但使用工具的时候不需考虑这么多，在对应的项目前打钩即可，命令行的时候才会去手动加参数：</li>
</ul>
<p>我们一般会把这个命令配置成Alias，配置如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias st-<span class="operator"><span class="keyword">start</span>=<span class="string">'python /home/gaojianwu/Software/android-studio/sdk/platform-tools/systrace/systrace.py'</span>  </span><br><span class="line"><span class="keyword">alias</span> st-<span class="keyword">start</span>-gfx-<span class="keyword">trace</span> = ‘st-<span class="keyword">start</span> -<span class="keyword">t</span> <span class="number">8</span> gfx <span class="keyword">input</span> <span class="keyword">view</span> sched freq wm am hwui workq res dalvik <span class="keyword">sync</span> disk <span class="keyword">load</span> perf hal rs idle mmc’</span></span><br></pre></td></tr></table></figure>
<p>这样在使用的时候，可以直接敲 <strong>st-start-gfx-mx4</strong> 即可，当然为了区分和保持各个文件，还需要加上 <strong>-o xxx.Trace</strong> .上面的命令和参数不必一次就理解，只需要记住如何简单使用即可，在分析的过程中，这些东西都会慢慢熟悉的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p> 本文是Android性能优化工具系列的第一篇，这个系列主要介绍Android性能优化过程中会使用到的一些工具，以及如何用这些工具来发现问题和解决问题。在性能优化方面，Android有不少性能工具供大家来使用，按照我们一贯地 “发现问题-解决问题”的思路来看，发现问题才是最主要的，一上来就想着如何去解决问题，反而会事倍功半。</p>
<p>这一篇先来简单介绍一下Systrace这个工具。</p>
<h2 id="Systrace简单介绍">Systrace简单介绍</h2><p>Systrace是Android4.1中新增的性能数据采样和分析工具。它可帮助开发者收集Android关键子系统（如surfaceflinger、WindowManagerService等Framework部分关键模块、服务，View系统等）的运行信息，从而帮助开发者更直观的分析系统瓶颈，改进性能。</p>
<p>Systrace的功能包括跟踪系统的I/O操作、内核工作队列、CPU负载以及Android各个子系统的运行状况等。在Android平台中，它主要由3部分组成：</p>
<ul>
<li>内核部分：Systrace利用了Linux Kernel中的ftrace功能。所以，如果要使用Systrace的话，必须开启kernel中和ftrace相关的模块。</li>
<li>数据采集部分：Android定义了一个Trace类。应用程序可利用该类把统计信息输出给ftrace。同时，Android还有一个atrace程序，它可以从ftrace中读取统计信息然后交给数据分析工具来处理。</li>
<li>数据分析工具：Android提供一个systrace.py（python脚本文件，位于Android SDK目录/tools/systrace中，其内部将调用atrace程序）用来配置数据采集的方式（如采集数据的标签、输出文件名等）和收集ftrace统计数据并生成一个结果网页文件供用户查看。 从本质上说，Systrace是对Linux Kernel中ftrace的封装。应用进程需要利用Android提供的Trace类来使用Systrace.<br>关于Systrace的官方介绍和使用可以看这里：<a href="http://developer.android.com/tools/help/systrace.html" title="SysTrace官方介绍">Systrace</a></li>
</ul>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Android Studio查看Android Lollipop源码]]></title>
    <link href="http://androidperformance.com/2015/01/16/view-android-source-code-with-androidstudio.html"/>
    <id>http://androidperformance.com/2015/01/16/view-android-source-code-with-androidstudio.html</id>
    <published>2015-01-16T13:54:32.000Z</published>
    <updated>2015-07-20T08:21:15.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Android_Studio">Android Studio</h2><p>作为Google的亲儿子,Nexus手机系列所收到的待遇大家有目共睹.Android5.0出来之后,Nexus5第一时间就升级到了最新的系统.那么作为Google亲儿子的Android Studio同样备受Google的重视,我也是第一时间从Eclipse转投到了Android Studio的怀抱中,从最初的测试版本一路升级到现在的1.0正式版本(今天发布了1.1,果断已经升级了).</p>
<a id="more"></a>
<p>关于Android Studio的好处我就不用说了,下面两点就足矣让你转投Android Studio了:</p>
<ul>
<li>Android Studio是Google官方指定的,目前官网已经去掉了ADT, 大家可以在<a href="http://developer.android.com/sdk/installing/index.html" target="_blank" rel="external">Android开发者官网</a> 中进行查看,目前只有Android Studio提供下载了.</li>
<li>Google也表示ADT不再进行维护了.<br>转投Android Studio时大势所趋,网上关于如何使用Android Studio的帖子也是满天飞,所以我就不再啰嗦夸奖Android Studio了.看一下下面的图,估计你就会很有欲望了.想查看详细的内容,可以查看<a href="http://developer.android.com/tools/studio/index.html" target="_blank" rel="external">Android Studio官方文档</a></li>
</ul>
<p><img src="/images/view-android-source-code-with-androidstudio/androidstudio.png" alt="Android Studio Preview"></p>
<h2 id="Android_5-0_:_Lollipop">Android 5.0 : Lollipop</h2><p>Android Lollipop是Google在今年推出的,关于Lollipop的详细介绍可以查看<a href="\&quot;http://developer.android.com/about/versions/lollipop.html\&quot;">Lollipop官方介绍</a> ,我也就不多说了.作为一个开发者,我们不应该停留在表面(即Lollipop的绚丽的界面,和新奇的设计语言<a href="\&quot;http://developer.android.com/about/versions/lollipop.html#Material\&quot;">Material design</a>),我们更要了解其中的原理.</p>
<h2 id="准备工作">准备工作</h2><p>在使用Android Studio查看源码之前,你需要做下面几件事:</p>
<ul>
<li>下载Android Lollipop源码(当然不一定非要是Lollipop源码,其他的版本也是可以的)</li>
<li>进行过一次完整编译(不编译是无法进行源码导入工作的)<br>以上操作可以参考<a href="https://source.android.com/source/initializing.html" target="_blank" rel="external">Google 官方教程</a> 以确保万无一失(呵呵).上面的几个链接需要翻墙才可以访问,不过有兴趣看这篇文章的人,大部分应该都是知道VPN的.或者没有VPN不会翻墙的,速度去卖一个VPN,能花钱解决的事情,就不要花时间.</li>
</ul>
<h2 id="开始">开始</h2><ul>
<li>进入Android 源码根目录</li>
<li>执行<br><code>mmm development/tools/idegen/</code><br>这行命令的意思是编译idegen这个项目,生成idegen.jar文件.生成成功后,会显示这个jar包的位置,并显示<br><code>make completed successfully (43 seconds)</code> ,如果编译失败了,后面会讲到这种情况(比较少见)</li>
<li>执行<br><code>sh ./development/tools/idegen/idegen.sh</code><br>这行命令的意思是生成对应的文件:android.iws, android.ipr, android.iml .如果生成失败,后面也会讲到这种情况.</li>
<li>生成对应的文件后,打开Android Studio,选择打开一个现有的Android Studio项目,选择Android源码的根目录,导入即可(起作用的是android.irp文件).在配置sdk版本之后就可以查看Android 源码了.</li>
<li>已经完成了,没有下一步了.</li>
</ul>
<h2 id="问题">问题</h2><ul>
<li><p>执行第一个命令的时候编译不过,出现这种情况的原因有好几种:</p>
<ul>
<li>Android 源码没有下载完全</li>
<li>没有进行全部编译</li>
<li>环境变量配置有问题解决方法依问题而定,网上对应的帖子很多,可以自己去找. 推荐这种问题还是去<a href="\&quot;http://www.jianshu.com/p/www.google.com\&quot;">Google</a> 和<a href="\&quot;http://www.jianshu.com/p/www.stackoverflow.com\&quot;">StackOverFlow</a> 上去问.</li>
</ul>
</li>
<li><p>执行第二个命令的时候,碰到下面的问题:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread \<span class="string">"main\" java.io.FileNotFoundException: ./out/target/product/hammerhead/obj/GYP/shared_intermediates/res.java (Is a directory)</span><br><span class="line"></span>at java.io.FileInputStream.<span class="keyword">open</span>(Native Method)</span><br><span class="line">at java.io.FileInputStream.&amp;<span class="keyword">lt</span>;init&amp;gt;(FileInputStream.jav<span class="variable">a:138</span>)</span><br><span class="line">at java.io.FileReader.&amp;<span class="keyword">lt</span>;init&amp;gt;(FileReader.jav<span class="variable">a:72</span>)</span><br><span class="line">at Configuration.parsePackageName(Configuration.jav<span class="variable">a:204</span>)</span><br><span class="line">at Configuration.rootOf(Configuration.jav<span class="variable">a:180</span>)</span><br><span class="line">at Configuration.traverse(Configuration.jav<span class="variable">a:140</span>)</span><br><span class="line">at Configuration.traverse(Configuration.jav<span class="variable">a:167</span>)</span><br><span class="line">at Configuration.traverse(Configuration.jav<span class="variable">a:167</span>)</span><br><span class="line">at Configuration.traverse(Configuration.jav<span class="variable">a:167</span>)</span><br><span class="line">at Configuration.traverse(Configuration.jav<span class="variable">a:167</span>)</span><br><span class="line">at Configuration.traverse(Configuration.jav<span class="variable">a:167</span>)</span><br><span class="line">at Configuration.traverse(Configuration.jav<span class="variable">a:167</span>)</span><br><span class="line">at Configuration.traverse(Configuration.jav<span class="variable">a:167</span>)</span><br><span class="line">at Configuration.&amp;<span class="keyword">lt</span>;init&amp;gt;(Configuration.jav<span class="variable">a:72</span>)</span><br><span class="line">at Main.main(Main.jav<span class="variable">a:37</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>解决办法是将<br><code>./out/target/product/hammerhead/obj/GYP/shared_intermediates/res.java</code><br>修改为:<br><code>./out/target/product/hammerhead/obj/GYP/shared_intermediates/res.j</code><br>即可.</p>
<h2 id="后记">后记</h2><p>使用Android Studio看Android源码很爽，下面是他们的优缺点：</p>
<h4 id="优点">优点</h4><ul>
<li>和Android 完美结合</li>
<li>代码提示很全</li>
<li>代码跳转很强</li>
<li>IDE比Eclipse好看(我说的是黑色主题)</li>
<li>插件很强大(底层是IDEA你懂得)</li>
<li>免费(SourceInsight负分,啥?你用的破解版? 当我没说)</li>
</ul>
<h4 id="缺点">缺点</h4><ul>
<li>对C＋＋代码的支持不是很好</li>
<li>有一定的上手难度</li>
</ul>
<p>本文简书地址：<a href="http://www.jianshu.com/p/c85984cf99e2" target="_blank" rel="external">http://www.jianshu.com/p/c85984cf99e2 </a>欢迎大家点喜欢</p>
<blockquote>
<p>作者：<a href="http://weibo.com/1315612820/profile?topnav=1&amp;wvr=6" target="_blank" rel="external">Gracker</a></p>
<p>出处：<a href="http://androidperformance.com/2015/01/16/view-android-source-code-with-androidstudio/">androidperformance.com</a></p>
<p>本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
<p>打赏一下： <a href="http://weibo.com/p/1001603801588257955883?from=page_100505_profile&amp;wvr=6&amp;mod=wenzhangmod" target="_blank" rel="external">微博打赏</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Android_Studio">Android Studio</h2><p>作为Google的亲儿子,Nexus手机系列所收到的待遇大家有目共睹.Android5.0出来之后,Nexus5第一时间就升级到了最新的系统.那么作为Google亲儿子的Android Studio同样备受Google的重视,我也是第一时间从Eclipse转投到了Android Studio的怀抱中,从最初的测试版本一路升级到现在的1.0正式版本(今天发布了1.1,果断已经升级了).</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android性能优化之过渡绘制( 二)]]></title>
    <link href="http://androidperformance.com/2015/01/13/android-performance-optimization-overdraw-2.html"/>
    <id>http://androidperformance.com/2015/01/13/android-performance-optimization-overdraw-2.html</id>
    <published>2015-01-13T11:38:53.000Z</published>
    <updated>2015-12-17T07:35:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>上一篇<a href="http://www.androidperformance.com/android-performance-optimization-overdraw-1.html" target="_blank" rel="external">文章</a>从理论的角度讲解了一下什么是过渡绘制，以及可以用来查看和确认过渡绘制的工具，还提供了一些优化过渡绘制的方法。对代码和布局比较熟悉的人，看完上一篇其实就已经可以对自己的应用进行优化了。我记得有人说过，用iphone你只需要保证苹果有节操即可，用Android你就得保证所有的Android开发者都有节操。但现实是残酷的，现在Android市场上，有很多粗制滥造的应用，其中不乏大厂之作，各位打开过渡绘制按钮，就知道我所言非虚。作为一个Android开发人员，我肯定是更希望Android能一步一步好起来，超越iphone。</p>
<p>这篇文章从实战的角度，讲解了一个过渡绘制的优化过程。当然这里用到的只是很少的一部分，毕竟每个应用差别很大，优化方式也各不一样。所以这篇文章仅供参考，想把这块做好还是要下功夫的。</p>
<p>如果没有看过前一篇，可以点这里：<a href="http://androidperformance.com/2014/10/20/android-performance-optimization-overdraw-1.html">Android性能优化之过渡绘制(一)</a></p>
<hr>
<a id="more"></a>
<h2 id="定位过渡绘制区域">定位过渡绘制区域</h2><h3 id="打开GPU过渡绘制选项:">打开GPU过渡绘制选项:</h3><p>设置—辅助功能–开发人员工具–硬件加速渲染—调试GPU过渡绘制— 显示过渡绘制区域.</p>
<h3 id="清理后台">清理后台</h3><p>Kill掉(即清后台)要测试的应用,重新打开就可以看到效果.下面以文件管理器和设置为例子,如下图</p>
<p><img src="/images/overdraw-1/filemanager-1.png" alt="文件管理器"><img src="/images/overdraw-1/settings.png" alt="设置"></p>
<p>从图上可以看出,按照过渡绘制从好到坏(蓝-绿-粉红-红)来看,文件管理器的过渡绘制是非常严重的,而设置界面的过渡绘制则在可以接受的范围内.下面就以文件管理器为主要分析对象,来看看如何对文件管理器的过渡绘制进行优化.</p>
<h3 id="从文件管理器的图,分析出过渡绘制区域:-">从文件管理器的图,分析出过渡绘制区域:.</h3><ul>
<li>首先看最上面的ActionBar和最下面的SmartBar,对比设置界面的ActionBar就可以知道,整个文件管理器存在一个不透明的背景,导致每次绘制时,都要先绘制这个看不见且不透明的背景.这个背景一般是应用的主题自带的背景,所以GPU过渡绘制显示其位蓝色,这个背景是可以进行优化的.</li>
<li>中间的内容部分,最底层是绿色,说明进行了2x的过渡绘制,去掉第一条我们提的那个全局背景,还有一层背景,也就是1x的过渡绘制,对比setting可知,这个背景色也是可以去掉的.</li>
<li>最容易看出的是这两条,我们先分析和优化这两条,然后再进行其他的优化.</li>
</ul>
<h2 id="优化过渡绘制区域">优化过渡绘制区域</h2><p>在进行位置确认后，我们大概确定了过渡绘制的区域,让我们来使用工具来进行验证和View确认.</p>
<p>打开Monitor(Eclipse和Android Studio中都有快捷打开按钮,即DDMS,右上角选择 Hierarchy View,大概使用如图</p>
<p><img src="/images/overdraw-1/HierarchyView-1.png" alt="Hierarchy View"></p>
<p>其中根节点:PhoneWindos$DecorView是整个视图的根节点,唯一的子节点是ActionBarOverlayLayout,这个Layout包含了ActionBar,应用程序,以及SmartBar.</p>
<p>下面讲述如何从Hierarchy View结合代码分析出需要进行修改的区域</p>
<h3 id="去除默认背景">去除默认背景</h3><p>上面分析过渡绘制区域的第一条,整个window存在一个背景,所以进行了一次重绘,这个背景的重绘是系统级别的,和主题有关,即这个背景是属于ActionBarOverlayLayout的.这种类型的过渡绘制解决也比较方便,在文件管理器的主Activity的onCreate方法中,加入</p>
<p><code>this.getWindow().setBackgroundDrawableResource(android.R.color.transparent);</code></p>
<p>就可以将这个看不见的主题背景去掉.下面是去掉主题背景后的效果图(一张是划开,一张是没有划开):</p>
<p><img src="/images/overdraw-1/filemanager-2.png" alt="文件管理器"><img src="/images/overdraw-1/filemanager-3.png" alt="文件管理器"></p>
<p>对比优化前的图可以发现,背景被去掉之后,少了一层过渡绘制. ActionBar上的蓝色已经消失了.中间的内容由绿色变为蓝色</p>
<h3 id="消除子控件背景">消除子控件背景</h3><p>上面分析的第二条说”<strong>中间的内容部分,最底层是绿色,说明进行了2x的过渡绘制</strong>”,现在中间部分变成了蓝色,但是这是一个全局的背景,导致右边的view拉过来之后,还是存在大量的红色和绿色. 继续分析Hierarchy View,找到中间view对应的视图:DragRelativeLayout,查看源码可知,DragRelativeLayout继承自公共控件:SlidingMenu ，SlidingMenu 由CustomViewAbove和CustomViewBehind组成,前者是上面可以左右拉动的那部分,后者是底部不能拉动的那部分(这个从HierarchyView中也可以看出来:如下图所示:</p>
<p><img src="/images/overdraw-1/HierarchyView-2.png" alt="Hierarchy View"></p>
<p>点击CustomViewBehind,查看其所占的区域,就可以发现背景是这个View进行绘制的,打开CustomViewBehind的代码可以发现其构造函数中包含下面的代码:<br><code>setBackgroundColor(getResources().getColor(R.color.mz_slidingmenu_background_light));</code><br>这个背景是不需要的,查看源码可知,这个view会在SlidingMenu.setMenu的时候,被覆盖掉,还是看不到的.所以这一层view是可以去掉的.下面是去掉一层背景之后的预览图:</p>
<p><img src="/images/overdraw-1/filemanager-4.png" alt="文件管理器"><img src="/images/overdraw-1/filemanager-5.png" alt="文件管理器"></p>
<p>可以看到这一层背景去掉之后,过渡绘制减轻了很多.</p>
<h3 id="进一步优化">进一步优化</h3><p>接着进行分析,可以看到CustomViewAbove也是存在一个过渡绘制的背景的,查看Hierarchy View的CustomViewAbove的子节点,可以看到过渡绘制是由ListView导致的.其id为:FilesList,在代码中找到它,并对他进行分析.在我将PartitionItemLayout中onDraw()函数的setBounds去掉之后,过渡绘制进一步改善了(但是ListItem的View的颜色也比之前要浅了,这一步优化需要根据具体情况进行) 下面是优化后的效果图:</p>
<p><img src="/images/overdraw-1/filemanager-6.png" alt="文件管理器"><img src="/images/overdraw-1/filemanager-7.png" alt="文件管理器"></p>
<p>可以看到图中的过渡绘制已经非常少了.!点个赞!</p>
<hr>
<h2 id="优化代码">优化代码</h2><h3 id="Lint工具">Lint工具</h3><p>Lint工具的使用比较简单,根据给出的提示做对应的修改即可.有时候需要工具具体情况来确定是否需要修改. 下图是一个简单地例子.箭头处提示这个Layout或者它的父Layout是不必须的.具体修改方法即去掉FrameLayout,将RelativeLayout提升为根VIew即可.</p>
<p><img src="/images/overdraw-1/lint-1.png" alt="Lint"></p>
<p>Lint工具还会针对代码中潜在的不合理或者Bed Code做出修改意见.比较重要的提示包括</p>
<ul>
<li>声明但是没有使用的变量</li>
<li>可能会产生的空指针</li>
<li>没必要书写的return,continue</li>
<li>复杂代码的简化写法</li>
<li>for循环的简化写法:foreach</li>
<li>无效的判空</li>
<li>空if</li>
<li>无效或者未使用的import</li>
</ul>
<h3 id="使用Tracer_For_OpenGL_ES">使用Tracer For OpenGL ES</h3><p>Tracer工具也在Android Device Monitor中.点击右上角的Tracer for OpenGL ES按钮就可以进入(如果没有这个按钮,点击旁边的Open Perspective按钮,从选项中选择Tracer for OpenGL ES即可).初次打开Tracer工具,里面是没有内容的,点击右上角的两个按钮(一个是打开现有的GLTrace文件,另一个是新建GLTrace文件)。点击Trace按钮, 手机会自动启动应用程序并启动对应的Activity,当手机上的内容完全绘制出来之后,就可以点击Stop按钮,生成GlTrace文件.文件会自动打开.</p>
<p><img src="/images/overdraw-1/Tracer-1.png" alt="Tracer"></p>
<p>分析GLTrace文件，下图是优化过后的图,对比优化前的图可以发现,优化后不会去绘制默认的背景图和CustomViewBehind的背景图.</p>
<p><img src="/images/overdraw-1/Tracer-2.png" alt="Tracer"></p>
<p>这只是一帧的绘制,如果多操作几下生成多个帧的绘制trace文件,会发现这两个背景会被多次的重绘,去掉后不仅会减轻过渡绘制,也会加快GUP的绘制速度.</p>
<hr>
<h2 id="参考资料">参考资料</h2><ol>
<li><a href="http://www.curious-creature.org/2012/12/01/android-performance-case-study/" target="_blank" rel="external">优化过程</a></li>
<li><a href="http://blog.csdn.net/yihongyuelan/article/details/12169647" target="_blank" rel="external">反编译并添加gpu显示</a></li>
<li><a href="http://developer.android.com/training/improving-layouts/optimizing-layout.html#Inspect" target="_blank" rel="external">http://developer.android.com/training/improving-layouts/optimizing-layout.html#Inspect</a></li>
<li><a href="http://developer.android.com/training/improving-layouts/reusing-layouts.html" target="_blank" rel="external">http://developer.android.com/training/improving-layouts/reusing-layouts.html </a></li>
<li><a href="http://developer.android.com/training/improving-layouts/loading-ondemand.html" target="_blank" rel="external">http://developer.android.com/training/improving-layouts/loading-ondemand.html</a></li>
<li><a href="http://developer.android.com/training/improving-layouts/smooth-scrolling.html" target="_blank" rel="external">http://developer.android.com/training/improving-layouts/smooth-scrolling.html </a></li>
<li><a href="http://developer.android.com/tools/help/hierarchy-viewer.html" target="_blank" rel="external">http://developer.android.com/tools/help/hierarchy-viewer.html</a></li>
<li><a href="http://tools.android.com/tips/lint" target="_blank" rel="external">http://tools.android.com/tips/lint</a></li>
</ol>
<hr>
<blockquote>
<p>作者：<a href="http://weibo.com/1315612820/profile?topnav=1&amp;wvr=6" target="_blank" rel="external">Gracker</a></p>
<p>出处：<a href="http://androidperformance.com/2015/01/13/android-performance-optimization-overdraw-2/">androidperformance.com</a></p>
<p>本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
<p>打赏一下： <a href="http://weibo.com/p/1001603801588257955883?from=page_100505_profile&amp;wvr=6&amp;mod=wenzhangmod" target="_blank" rel="external">微博打赏</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>上一篇<a href="http://www.androidperformance.com/android-performance-optimization-overdraw-1.html">文章</a>从理论的角度讲解了一下什么是过渡绘制，以及可以用来查看和确认过渡绘制的工具，还提供了一些优化过渡绘制的方法。对代码和布局比较熟悉的人，看完上一篇其实就已经可以对自己的应用进行优化了。我记得有人说过，用iphone你只需要保证苹果有节操即可，用Android你就得保证所有的Android开发者都有节操。但现实是残酷的，现在Android市场上，有很多粗制滥造的应用，其中不乏大厂之作，各位打开过渡绘制按钮，就知道我所言非虚。作为一个Android开发人员，我肯定是更希望Android能一步一步好起来，超越iphone。</p>
<p>这篇文章从实战的角度，讲解了一个过渡绘制的优化过程。当然这里用到的只是很少的一部分，毕竟每个应用差别很大，优化方式也各不一样。所以这篇文章仅供参考，想把这块做好还是要下功夫的。</p>
<p>如果没有看过前一篇，可以点这里：<a href="http://androidperformance.com/2014/10/20/android-performance-optimization-overdraw-1.html">Android性能优化之过渡绘制(一)</a></p>
<hr>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android性能优化之过渡绘制(一)]]></title>
    <link href="http://androidperformance.com/2014/10/20/android-performance-optimization-overdraw-1.html"/>
    <id>http://androidperformance.com/2014/10/20/android-performance-optimization-overdraw-1.html</id>
    <published>2014-10-20T15:19:23.000Z</published>
    <updated>2015-07-14T01:06:38.000Z</updated>
    <content type="html"><![CDATA[<p>博客有一段时间没有更新了，到了新公司后，一直比较忙，博客也更新地不那么频繁了，倒是利用这个VPS搭建的VPN每天都在用，速度也蛮不错的。最近一直在看Android上和性能相关的部分，也就是所谓的Android性能优化，才发现Android性能这一块，自己懂得还是太少了，所以从上层开始看，也算是一点一点入门吧。这个系列将讲解学习过程中总结的和性能相关的内容。</p>
<p>首先将讲解一下GPU过渡绘制，也是开发者最直接接触的部分吧，这个内容将分为两个部分来将讲，第一部分初步讲解一下gpu过渡绘制的原理，和一些优化建议，第二部分将用实际例子来讲解优化GPU过渡绘制的一般步骤。</p>
<h2 id="过渡绘制概念">过渡绘制概念</h2><p>GPU过渡绘制的概念：GPU过度绘制指的是在屏幕一个像素上绘制多次(超过一次),比如一个TextView后有背景，那么显示文本的像素至少绘了两次，一次是背景，一次是文本。GPU过度绘制或多或少对性能有些影响,设备的内存带宽是有限的，当过度绘制导致应用需要更多的带宽(超过了可用带宽)的时候性能就会降低。带宽的限制每个设备都可能是不一样的。</p>
<a id="more"></a>
<h2 id="过渡绘制的原因">过渡绘制的原因</h2><ol>
<li>太多的View叠加</li>
<li>复杂的层级叠加</li>
<li>更长的inflation时间</li>
</ol>
<h2 id="过渡绘制和不合理的xml布局的影响">过渡绘制和不合理的xml布局的影响</h2><ol>
<li>布局文件是一个xml文件，inflate布局文件其实就是解析xml，根据标签信息创建相应的布局对象并做关联。xml中的标签和属性设置越多，节点树的深度越深，在解析时要执行的判断逻辑、函数的嵌套和递归就越多，所以时间消耗越多；</li>
<li>inflate操作只是布局影响的第一个环节，一个界面要显示出来，在requestLayout后还要执行一系列的measure、layout、draw的操作，每一步的执行时间都会受到布局本身的影响。而界面的最终显示是所有这些操作完成后才实现的，所以如果布局质量差，会增加每一步操作的时间成本，最终显示时间就会比较长。</li>
</ol>
<h2 id="过渡绘制的一些基本概念:">过渡绘制的一些基本概念:</h2><p>Android提供了三个工具来帮助辨别和解决重绘问题：Hierachy Viewer，Tracer for OpenGL和Show GPU overdraw。前两个可以在ADT工具或者独立的monitor工具中找到，最后一个是在开发者选项的一部分.</p>
<ol>
<li>GPU过渡绘制测试:对于过度绘制的测试主要通过人工进行测试，也是发现应用过渡绘制的首选途径 .通过打开开发者选项中的 显示GPU过度绘制(魅族手机:设置—辅助功能–开发人员工具–硬件加速渲染—调试GPU过渡绘制— 显示过渡绘制区域. (魅族手机需要打开开发者模式：需要在电话界面输入: <em>#</em>#6961#<em>#</em> )) 来进行测试（PS：只有android4.2及以上的版本才具备此功能)</li>
<li>颜色标识: GPU过渡绘制从好到差:蓝-绿-淡红-红<ul>
<li>蓝色1x过度绘制</li>
<li>绿色2x过度绘制</li>
<li>淡红色3x过度绘制</li>
<li>红色超过4x过度绘制</li>
</ul>
</li>
<li>验收标准:<ul>
<li>控制过度绘制为2x</li>
<li>不允许存在4x过度绘制</li>
<li>不允许存在面积超过屏幕1/4区域的3x过度绘制（淡红色区域）</li>
</ul>
</li>
</ol>
<h2 id="优化工具介绍">优化工具介绍</h2><ol>
<li>Lint工具:<ul>
<li>Eclipse中,点击即可,下面的窗口中会出现提示,根据提示和具体解决办法消除.</li>
<li>Android Studio自带Lint工具,不合理或者需要优化和注意的地方,会用黄色标记出来.</li>
<li>Lint工具不仅对布局有很好的优化建议,对代码中不合理的活着存在潜在风险的模块也会提出优化建议,所以一个好的建议是:多使用Lint工具检查自己的应用,尽量消除所有的建议.</li>
<li>Lint工具可以用命令行来运行,具体使用可以参考:<a href="tools.android.com">tools.android.com</a><br><img src="/images/overdraw-1/lint.png" alt="Lint"></li>
</ul>
</li>
<li><p>Lint工具的提升例子(摘自官方文档):</p>
<ul>
<li>Use compound drawables(使用compound drawables) - A LinearLayout which contains an ImageView and a TextView can be more efficiently handled as a compound drawable.</li>
<li>Merge root frame(使用Merge根框架) - If a FrameLayout is the root of a layout and does not provide background or padding etc, it can be replaced with a merge tag which is slightly more efficient.</li>
<li>Useless leaf(去除无用的分支) - A layout that has no children or no background can often be removed (since it is invisible) for a flatter and more efficient layout hierarchy.</li>
<li>Useless parent (去除无用的父控件)- A layout with children that has no siblings, is not a ScrollView or a root layout, and does not have a background, can be removed and have its children moved directly into the parent for a flatter and more efficient layout hierarchy.</li>
<li>Deep layouts (注意Layout的深度) - Layouts with too much nesting are bad for performance. Consider using flatter layouts such as RelativeLayout or GridLayout to improve performance. The default maximum depth is</li>
</ul>
</li>
<li><p>Hierarchy Viewer:此工具是一个ADT工具（或者monitor,最新版本的SDK建议不使用独立的HV工具,而是直接在monitor中进行操作.）的一部分，可以被用作对视图层级进行快速解读。在处理布局问题时特别有用，对于性能问题也很适用。Hierarchy Viewer默认只能在非加密设备使用，例如工程机，工程平板或者模拟器。为了能够在任何手机上使用Hierarchy Viewer，你得在你的应用中添加ViewServer，这是一个开源库,使用方法可以参考这里。连接上设备，打开Hierarchy Viewer(定位到tools/目录下，直接执行hierarchyviewer的命令，选定需要查看的Process，再点击Load View Hierarchy会显示出当前界面的布局Tree。在每个模块的Traffic light上有三个灯，分别代表了Measure, Layout and Draw三个步骤的性能。</p>
</li>
</ol>
<h2 id="布局优化建议">布局优化建议</h2><p>在Android UI布局过程中，通过遵守一些惯用、有效的布局原则，我们可以制作出高效且复用性高的UI，概括来说包括如下几点：</p>
<ul>
<li><p>尽量多使用RelativeLayout和LinearLayout, 不要使用绝对布局AbsoluteLayout，</p>
<ul>
<li>在布局层次一样的情况下， 建议使用LinearLayout代替RelativeLayout, 因为LinearLayout性能要稍高一点.</li>
<li>在完成相对较复杂的布局时,建议使用RelativeLayout,RelativeLayout可以简单实现LinearLayout嵌套才能实现的布局.</li>
</ul>
</li>
<li><p>将可复用的组件抽取出来并通过include标签使用；</p>
</li>
<li>使用ViewStub标签来加载一些不常用的布局；</li>
<li>动态地inflation view性能要比SetVisiblity性能要好.当然用VIewStub是最好的选择.</li>
<li>使用merge标签减少布局的嵌套层次</li>
<li><p>去掉多余的背景颜色(查看背景颜色是否多余,可以将HierarchyView中的图导出为psd文件,然后用Photoshop查看.具体可以参考这个<a href="https://www.youtube.com/watch?v=URyoiAt8098" target="_blank" rel="external">视频</a>)</p>
<ul>
<li>对于有多层背景颜色的Layout来说,留最上面一层的颜色即可,其他底层的颜色都可以去掉</li>
<li>对于使用Selector当背景的Layout(比如ListView的Item,会使用Selector来标记点击,选择等不同的状态),可以将normal状态的color设置为\”@android:color/transparent”,来解决对应的问题</li>
</ul>
</li>
<li><p>内嵌使用包含layout_weight属性的LinearLayout会在绘制时花费昂贵的系统资源，因为每一个子组件都需要被测量两次。在使用ListView与GridView的时候，这个问题显的尤其重要，因为子组件会重复被创建.所以要尽量避免使用Layout_weight</p>
</li>
<li>使得Layout宽而浅，而不是窄而深（在Hierarchy Viewer的Tree视图里面体现）</li>
</ul>
<h2 id="源码相关">源码相关</h2><p>另外有能力看源码的同学，下面是绘制OverDraw的源码位置：/frameworks/base/libs/hwui/OpenGLRenderer.cpp,有兴趣的可以去研究研究。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> OpenGLRenderer::renderOverdraw() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCaches.debugOverdraw &amp;amp;&amp;amp; getTargetFbo() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> Rect* clip = &amp;amp;mTilingClip;</span><br><span class="line"></span><br><span class="line">        mCaches.enableScissor();</span><br><span class="line">        mCaches.setScissor(clip-&amp;gt;left, mFirstSnapshot-&amp;gt;height - clip-&amp;gt;bottom,</span><br><span class="line">                clip-&amp;gt;right - clip-&amp;gt;left, clip-&amp;gt;bottom - clip-&amp;gt;top);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1x overdraw</span></span><br><span class="line">        mCaches.stencil.enableDebugTest(<span class="number">2</span>);</span><br><span class="line">        drawColor(mCaches.getOverdrawColor(<span class="number">1</span>), SkXfermode::kSrcOver_Mode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2x overdraw</span></span><br><span class="line">        mCaches.stencil.enableDebugTest(<span class="number">3</span>);</span><br><span class="line">        drawColor(mCaches.getOverdrawColor(<span class="number">2</span>), SkXfermode::kSrcOver_Mode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3x overdraw</span></span><br><span class="line">        mCaches.stencil.enableDebugTest(<span class="number">4</span>);</span><br><span class="line">        drawColor(mCaches.getOverdrawColor(<span class="number">3</span>), SkXfermode::kSrcOver_Mode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4x overdraw and higher</span></span><br><span class="line">        mCaches.stencil.enableDebugTest(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line">        drawColor(mCaches.getOverdrawColor(<span class="number">4</span>), SkXfermode::kSrcOver_Mode);</span><br><span class="line"></span><br><span class="line">        mCaches.stencil.disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> OpenGLRenderer::countOverdraw() &#123;</span><br><span class="line">    <span class="keyword">size_t</span> count = mWidth * mHeight;</span><br><span class="line">    <span class="keyword">uint32_t</span>* buffer = <span class="keyword">new</span> <span class="keyword">uint32_t</span>[count];</span><br><span class="line">    glReadPixels(<span class="number">0</span>, <span class="number">0</span>, mWidth, mHeight, GL_RGBA, GL_UNSIGNED_BYTE, &amp;amp;buffer[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &amp;lt; count; i++) &#123;</span><br><span class="line">        total += buffer[i] &amp;amp; <span class="number">0xff</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOverdraw = total / <span class="keyword">float</span>(count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有QA可能用得到的一个指标：OverDraw数值，这个的源码位置在Framework/base/core/java/android/view/HardwareRender.java中(5.0中去掉了这个数值的显示)</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> debugOverdraw(View.AttachInfo attachInfo, Rect dirty,</span><br><span class="line">                HardwareCanvas canvas, DisplayList displayList) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mDebugOverdraw == OVERDRAW_TYPE_COUNT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mDebugOverdrawLayer == <span class="literal">null</span>) &#123;</span><br><span class="line">                    mDebugOverdrawLayer = createHardwareLayer(mWidth, mHeight, <span class="literal">true</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mDebugOverdrawLayer.getWidth() != mWidth ||</span><br><span class="line">                        mDebugOverdrawLayer.getHeight() != mHeight) &#123;</span><br><span class="line">                    mDebugOverdrawLayer.resize(mWidth, mHeight);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!mDebugOverdrawLayer.isValid()) &#123;</span><br><span class="line">                    mDebugOverdraw = -<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                HardwareCanvas layerCanvas = mDebugOverdrawLayer.start(canvas, dirty);</span><br><span class="line">                countOverdraw(layerCanvas);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> restoreCount = layerCanvas.save();</span><br><span class="line">                layerCanvas.drawDisplayList(displayList, <span class="literal">null</span>, DisplayList.FLAG_CLIP_CHILDREN);</span><br><span class="line">                layerCanvas.restoreToCount(restoreCount);</span><br><span class="line">                mDebugOverdrawLayer.end(canvas);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">float</span> overdraw = getOverdraw(layerCanvas);</span><br><span class="line">                DisplayMetrics metrics = attachInfo.mRootView.getResources().getDisplayMetrics();</span><br><span class="line"></span><br><span class="line">                drawOverdrawCounter(canvas, overdraw, metrics.density);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> drawOverdrawCounter(HardwareCanvas canvas, <span class="built_in">float</span> overdraw, <span class="built_in">float</span> density) &#123;</span><br><span class="line">            <span class="keyword">final</span> String text = String.format(\<span class="string">"%.2fx\", overdraw);</span><br><span class="line">            final Paint paint = setupPaint(density);</span><br><span class="line">            // HSBtoColor will clamp the values in the 0..1 range</span><br><span class="line">            paint.setColor(Color.HSBtoColor(0.28f - 0.28f * overdraw / 3.5f, 0.8f, 1.0f));</span><br><span class="line"></span><br><span class="line">            canvas.drawText(text, density * 4.0f, mHeight - paint.getFontMetrics().bottom, paint);</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="参考文章">参考文章</h2><ol>
<li><a href="http://www.curious-creature.org/2012/12/01/android-performance-case-study/" target="_blank" rel="external">优化过程</a></li>
<li><a href="http://blog.csdn.net/yihongyuelan/article/details/12169647" target="_blank" rel="external">反编译并添加gpu显示</a></li>
<li><a href="http://developer.android.com/training/improving-layouts/optimizing-layout.html#Inspect" target="_blank" rel="external">http://developer.android.com/training/improving-layouts/optimizing-layout.html#Inspect</a></li>
<li><a href="http://developer.android.com/training/improving-layouts/reusing-layouts.html" target="_blank" rel="external">http://developer.android.com/training/improving-layouts/reusing-layouts.html </a></li>
<li><a href="http://developer.android.com/training/improving-layouts/loading-ondemand.html" target="_blank" rel="external">http://developer.android.com/training/improving-layouts/loading-ondemand.html</a></li>
<li><a href="http://developer.android.com/training/improving-layouts/smooth-scrolling.html" target="_blank" rel="external">http://developer.android.com/training/improving-layouts/smooth-scrolling.html </a></li>
<li><a href="http://developer.android.com/tools/help/hierarchy-viewer.html" target="_blank" rel="external">http://developer.android.com/tools/help/hierarchy-viewer.html</a></li>
<li><a href="http://tools.android.com/tips/lint" target="_blank" rel="external">http://tools.android.com/tips/lint</a></li>
</ol>
<hr>
<blockquote>
<p>作者：<a href="http://weibo.com/1315612820/profile?topnav=1&amp;wvr=6" target="_blank" rel="external">Gracker</a></p>
<p>出处：<a href="http://androidperformance.com/2014/10/20/android-performance-optimization-overdraw-1/">androidperformance.com</a></p>
<p>本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
<p>打赏一下： <a href="http://weibo.com/p/1001603801588257955883?from=page_100505_profile&amp;wvr=6&amp;mod=wenzhangmod" target="_blank" rel="external">微博打赏</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>博客有一段时间没有更新了，到了新公司后，一直比较忙，博客也更新地不那么频繁了，倒是利用这个VPS搭建的VPN每天都在用，速度也蛮不错的。最近一直在看Android上和性能相关的部分，也就是所谓的Android性能优化，才发现Android性能这一块，自己懂得还是太少了，所以从上层开始看，也算是一点一点入门吧。这个系列将讲解学习过程中总结的和性能相关的内容。</p>
<p>首先将讲解一下GPU过渡绘制，也是开发者最直接接触的部分吧，这个内容将分为两个部分来将讲，第一部分初步讲解一下gpu过渡绘制的原理，和一些优化建议，第二部分将用实际例子来讲解优化GPU过渡绘制的一般步骤。</p>
<h2 id="过渡绘制概念">过渡绘制概念</h2><p>GPU过渡绘制的概念：GPU过度绘制指的是在屏幕一个像素上绘制多次(超过一次),比如一个TextView后有背景，那么显示文本的像素至少绘了两次，一次是背景，一次是文本。GPU过度绘制或多或少对性能有些影响,设备的内存带宽是有限的，当过度绘制导致应用需要更多的带宽(超过了可用带宽)的时候性能就会降低。带宽的限制每个设备都可能是不一样的。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[Android小技巧]:如何让EditText不自动获取焦点]]></title>
    <link href="http://androidperformance.com/2014/06/03/android-edittext-do-not-auto-get-focus.html"/>
    <id>http://androidperformance.com/2014/06/03/android-edittext-do-not-auto-get-focus.html</id>
    <published>2014-06-02T16:31:49.000Z</published>
    <updated>2015-03-27T05:26:19.000Z</updated>
    <content type="html"><![CDATA[<p>Android中,使用EditText作为输入框很方便,但是有时候EditText会自动获取焦点,其行为:点击进入这个页面后,EditText自动获取焦点,导致软键盘直接跳出.有时候这么做很方便,但是大部分时候我们还是希望在点击EditText的时候,软键盘才弹出来.</p>
<p>这里有个很简单也很实用的技巧,即在EditText的父Layout中,加入下面的两个属性即可:</p>
<p><pre class="lang:java decode:true ">android:focusable=”true”<br>android:focusableInTouchMode=”true”</pre><br>这样做的原理是让用户进入到这个页面之后,EditText的父控件 获取焦点,这样的话EditText就获取不到焦点,软键盘也不会自动弹起.只有在点击EditText的时候,软键盘才会弹起.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Android中,使用EditText作为输入框很方便,但是有时候EditText会自动获取焦点,其行为:点击进入这个页面后,EditText自动获取焦点,导致软键盘直接跳出.有时候这么做很方便,但是大部分时候我们还是希望在点击EditText的时候,软键盘才弹出来.</p]]>
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Frame animation模拟脉搏跳动小动画]]></title>
    <link href="http://androidperformance.com/2014/06/01/android-frame-animation.html"/>
    <id>http://androidperformance.com/2014/06/01/android-frame-animation.html</id>
    <published>2014-06-01T10:07:18.000Z</published>
    <updated>2015-03-27T05:26:33.000Z</updated>
    <content type="html"><![CDATA[<p>逐帧动画是一种常见的动画形式（Frame By Frame），其原理是在“连续的关键帧”中分解动画动作，也就是在时间轴的每帧上逐帧绘制不同的内容，使其连续播放而成动画。 因为逐帧动画的帧序列内容不一样，不但给制作增加了负担而且最终输出的文件量也很大，但它的优势也很明显：逐帧动画具有非常大的灵活性，几乎可以表现任何想表现的内容，而它类似与电影的播放模式，很适合于表演细腻的动画。例如：人物或动物急剧转身、 头发及衣服的飘动、走路、说话以及精致的3D效果等等。</p>
<p>Android中的逐帧动画是Frame animation。<span style="\"color:" #000000;\"="">Frame animation可以被定义在XML文件中，也可以完全编码实现。3.0以前，android支持两种动画模式，tween animation,frame animation，在android3.0中又引入了一个新的动画系统：property animation，这三种动画模式在SDK中被称为property animation,view animation,drawable animation。 </span></p>
<a id="more"></a>
<p>本篇使用的方法是在xml中定义效果，以下是想达到的动画的效果。</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>1.首先准备所需图片（逐帧）。</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>2.在res/anim下或res/rawable下新建xml来编写动画效果。内容类似下图：</p>
<pre class="\"lang:java" decode:true\"="">&lt;animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\"
    android:oneshot=\"false\"&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00040\" android:duration=\"100\" /&gt;//duration是每帧图片的时长，单位ms
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00041\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00042\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00043\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00044\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00045\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00046\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00047\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00048\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00049\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00050\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00051\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00052\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00053\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00054\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00055\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00056\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00057\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00058\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00059\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00060\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00061\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00062\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00063\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00064\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00065\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00066\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00067\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00068\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00069\" android:duration=\"100\" /&gt;
&lt;/animation-list&gt;</pre>

<p>xml保存为scanning_anim.xml.其中,</p>
<pre class="\"lang:java" decode:true\"="">animation-list//最外层是animition-list控件，可以容纳item，每个item是一帧图片。</pre>

<pre class="\"lang:java" decode:true\"="">android:oneshot=\"false\"<span style="\"color:" #000000;\"="">//如果为true，表示动画只播放一次停止在最后一帧上，如果设置为false表示动画循环播放。</span></pre>

<p>3.以上xml中定义的动画要以一个imageView作为载体来显示。以下例子用一个类稍稍封装：</p>
<pre class="\"lang:java" decode:true\"="">public class ScanningAnimationView extends ImageView {
    AnimationDrawable scanningDrawable;
    public ScanningAnimationView(Context context) {
        super(context);
    }
    public ScanningAnimationView(Context context, AttributeSet attrs) {
        super(context, attrs);
        setBackgroundResource(R.anim.scanning_anim);
        scanningDrawable=(AnimationDrawable)this.getBackground();
    }

    public void start() {
        scanningDrawable.start();
    }
    public void stop() {
        scanningDrawable.stop();
    }
}</pre>

<p>4.用户直接使用这个封装好的ImageView调用start和stop即可。</p>
<p>调用动画：</p>
<pre class="\"lang:java" decode:true\"="">public class MainActivity extends ActionBarActivity {
    ScanningAnimationView image;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        image = (ScanningAnimationView)findViewById(R.id.imageView);
        Button startButton = (Button) findViewById(R.id.start);
        Button endButton = (Button)findViewById(R.id.end);
        startButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                image.start();
            }
        });

        endButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                image.stop();
            }
        });
    }
</pre>

<p>imageView的布局：</p>
<pre class="\"lang:java" decode:true\"="">&lt;com.example.nurse.app.util.ScanningAnimationView
    android:layout_width=\"wrap_content\"
    android:layout_height=\"wrap_content\"
    android:id=\"@+id/imageView\"
    android:layout_centerHorizontal=\"true\"
    android:layout_alignParentTop=\"true\"
    android:layout_alignParentStart=\"true\"/&gt;</pre>

<p>本篇完。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>逐帧动画是一种常见的动画形式（Frame By Frame），其原理是在“连续的关键帧”中分解动画动作，也就是在时间轴的每帧上逐帧绘制不同的内容，使其连续播放而成动画。 因为逐帧动画的帧序列内容不一样，不但给制作增加了负担而且最终输出的文件量也很大，但它的优势也很明显：逐帧动画具有非常大的灵活性，几乎可以表现任何想表现的内容，而它类似与电影的播放模式，很适合于表演细腻的动画。例如：人物或动物急剧转身、 头发及衣服的飘动、走路、说话以及精致的3D效果等等。</p>
<p>Android中的逐帧动画是Frame animation。<span style=\"color: #000000;\">Frame animation可以被定义在XML文件中，也可以完全编码实现。3.0以前，android支持两种动画模式，tween animation,frame animation，在android3.0中又引入了一个新的动画系统：property animation，这三种动画模式在SDK中被称为property animation,view animation,drawable animation。 </span></p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Android小技巧(2)]]></title>
    <link href="http://androidperformance.com/2014/05/31/android-tips-round-up-2.html"/>
    <id>http://androidperformance.com/2014/05/31/android-tips-round-up-2.html</id>
    <published>2014-05-31T10:20:47.000Z</published>
    <updated>2015-07-20T08:21:57.000Z</updated>
    <content type="html"><![CDATA[<p>本文是一篇译文,这篇是这个系列的第二篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<a id="more"></a>
<h2 id="正文">正文</h2><p><a href="http://developer.android.com/reference/android/text/format/DateUtils.html#formatDateTime%28android.content.Context,%20long,%20int%29" target="_blank" rel="external">DateUtils.formatDateTime()</a> 用来进行区域格式化工作,输出格式化和本地化的时间或者日期.</p>
<p><a href="http://developer.android.com/reference/android/app/AlarmManager.html#setInexactRepeating(int, long, long, android.app.PendingIntent" target="_blank" rel="external">AlarmManager.setInexactRepeating</a>) 通过闹铃分组的方式省电,即使你只调用了一个闹钟,这也是一个好的选择,（可以确保在使用完毕时自动调用 AlarmManager.cancel ()。原文说的比较抽象,这里详细说一下:setInexactRepeating指的是设置非准确闹钟,使用方法:alarmManager.setInexactRepeating(AlarmManager.RTC, startTime,intervalL, pendingIntent),非准确闹钟只能保证大致的时间间隔，但是不一定准确，可能出现设置间隔为30分钟，但是实际上一次间隔20分钟，另一次间隔40分钟。它的最大的好处是可以合并闹钟事件，比如间隔设置每30分钟一次，不唤醒休眠，在休眠8小时后已经积累了16个闹钟事件，而在手机被唤醒的时候，非准时闹钟可以把16个事件合并为一个, 所以这么看来,非准时闹钟一般来说比较节约能源.</p>
<p><a href="http://developer.android.com/reference/android/text/format/Formatter.html#formatFileSize(android.content.Context, long" target="_blank" rel="external">Formatter.formatFileSize()</a>) 一个区域化的文件大小格式化工具。通俗来说就是把大小转换为MB,G,KB之类的字符串.</p>
<p><a href="http://developer.android.com/reference/android/app/ActionBar.html#hide(" target="_blank" rel="external">ActionBar.hide()</a>)/<a href="http://developer.android.com/reference/android/app/ActionBar.html#show(" target="_blank" rel="external">.show()</a>) 顾名思义,隐藏和显示ActionBar,可以优雅地在全屏和带Actionbar之间转换.</p>
<p><a href="http://developer.android.com/reference/android/text/util/Linkify.html#addLinks(android.text.Spannable, int" target="_blank" rel="external">Linkify.addLinks()</a>)  在Text上添加链接.很实用.</p>
<p><a href="http://developer.android.com/reference/android/text/StaticLayout.html" target="_blank" rel="external">StaticLayout</a> 在自定义 View 中渲染文字的时候很实用。</p>
<p><a href="http://developer.android.com/reference/android/app/Activity.html#onBackPressed(" target="_blank" rel="external">Activity.onBackPressed()</a>) 很方便的管理back键的方法,有时候需要自己控制返回键的事件的时候,可以重写一下.比如加入 “点两下back键退出” 功能.</p>
<p><a href="http://developer.android.com/reference/android/view/GestureDetector.html" target="_blank" rel="external">GestureDetector</a> 用来监听和相应对应的手势事件,比如点击,长按,慢滑动,快滑动,用起来很简单,比你自己实现要方便许多.</p>
<p><a href="http://developer.android.com/reference/android/graphics/DrawFilter.html" target="_blank" rel="external">DrawFilter</a> 可以让你在不调用onDrew方法的情况下,操作canvas,比了个如,你可以在创建自定义 View 的时候设置一个 DrawFilter，给父 View 里面的所有 View 设置反别名。</p>
<p><a href="http://developer.android.com/reference/android/app/ActivityManager.html#getMemoryClass(" target="_blank" rel="external">ActivityManager.getMemoryClass()</a>) 告诉你你的机器还有多少内存,在计算缓存大小的时候会比较有用.</p>
<p><a href="http://developer.android.com/reference/android/view/ViewStub.html" target="_blank" rel="external">ViewStub</a> 它是一个初始化不做任何事情的 View，但是之后可以载入一个布局文件。在慢加载 View 中很适合做占位符。唯一的缺点就是不支持标签，所以如果你不太小心的话，可能会在视图结构中加入不需要的嵌套。</p>
<p><a href="http://developer.android.com/reference/android/os/SystemClock.html#sleep(long" target="_blank" rel="external">SystemClock.sleep()</a>) 这个方法在保证一定时间的 sleep 时很方便，通常我用来进行 debug 和模拟网络延时。</p>
<p><a href="http://developer.android.com/reference/android/util/DisplayMetrics.html#density" target="_blank" rel="external">DisplayMetrics.density</a> 这个方法你可以获取设备像素密度,大部分时候最好让系统来自动进行缩放资源之类的操作,但是有时候控制的效果会更好一些.(尤其是在自定义View的时候).</p>
<p><a href="http://developer.android.com/reference/android/util/Pair.html#create(A, B" target="_blank" rel="external">Pair.create()</a>) 方便构建类和构造器的方法。</p>
<h2 id="备忘">备忘</h2><p>More: <a href="http://www.androidperformance.com/android-tips-round-up.html" target="_blank" rel="external">Part1</a> , <a href="http://www.androidperformance.com/android-tips-round-up-2.html" target="_blank" rel="external">Part2</a> , <a href="http://www.androidperformance.com/android-tips-round-up-3.html" target="_blank" rel="external">Part3</a> , <a href="http://www.androidperformance.com/android-tips-round-up-4.html" target="_blank" rel="external">Part4</a>, <a href="http://www.androidperformance.com/android-tips-round-up-5.html" target="_blank" rel="external">Part5</a><br>原文地址:<a href="http://blog.danlew.net/2014/04/14/android-tips-round-up-part-2/" target="_blank" rel="external">http://blog.danlew.net/2014/03/30/android-tips-round-up-part-2/</a><br>原文作者:<a href="http://blog.danlew.net/about/" target="_blank" rel="external">http://blog.danlew.net/about/</a><br>本文地址:<a href="http://www.androidperformance.com/android-tips-round-up-2.html" target="_blank" rel="external">http://www.androidperformance.com/android-tips-round-up-2.html</a> 转载请注明.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文是一篇译文,这篇是这个系列的第二篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Android小技巧(1)]]></title>
    <link href="http://androidperformance.com/2014/05/28/android-tips-round-up-1.html"/>
    <id>http://androidperformance.com/2014/05/28/android-tips-round-up-1.html</id>
    <published>2014-05-28T15:47:43.000Z</published>
    <updated>2015-07-20T08:21:40.000Z</updated>
    <content type="html"><![CDATA[<p>本文是一篇译文,这篇是这个系列的第一篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<a id="more"></a>
<h2 id="正文">正文</h2><p><a href="http://developer.android.com/reference/android/app/Activity.html#startActivities(android.content.Intent[]" target="_blank" rel="external">Activity.startActivities()</a>) 常用于在应用程序中间启动其他的Activity.</p>
<p><a href="http://developer.android.com/reference/android/text/TextUtils.html#isEmpty(java.lang.CharSequence" target="_blank" rel="external">TextUtils.isEmpty()</a>) 简单的工具类,用于检测是否为空</p>
<p><a href="http://developer.android.com/reference/android/text/Html.html#fromHtml(java.lang.String" target="_blank" rel="external">Html.fromHtml()</a>) 用于生成一个Html,参数可以是一个字符串.个人认为它不是很快,所以我不怎么经常去用.（我说不经常用它是为了重点突出这句话：请多手动构建 Spannable 来替换 Html.fromHtml），但是它对渲染从 web 上获取的文字还是很不错的。</p>
<p><a href="http://developer.android.com/reference/android/widget/TextView.html#setError%28java.lang.CharSequence%29" target="_blank" rel="external">TextView.setError()</a> 在验证用户输入的时候很棒</p>
<p><a href="http://developer.android.com/reference/android/os/Build.VERSION_CODES.html" target="_blank" rel="external">Build.VERSION_CODES</a> 这个标明了当前的版本号,在处理兼容性问题的时候经常会用到.点进去可以看到各个版本的不同特性</p>
<p><a href="http://developer.android.com/reference/android/util/Log.html#getStackTraceString(java.lang.Throwable" target="_blank" rel="external">Log.getStackTraceString()</a>) 方便的日志类工具,方法Log.v()、Log.d()、Log.i()、Log.w()和Log.e()都是将信息打印到LogCat中，有时候需要将出错的信息插入到数据库或一个自定义的日志文件中，那么这种情况就需要将出错的信息以字符串的形式返回来，也就是使用static String getStackTraceString(Throwable tr)方法的时候.</p>
<p><a href="http://developer.android.com/reference/android/view/LayoutInflater.html#from%28android.content.Context%29" target="_blank" rel="external">LayoutInflater.from()</a> 顾名思义,用于Inflate一个layout,参数是layout的id.这个经常写Adapter的人会用的比较多.</p>
<p><a href="http://developer.android.com/reference/android/view/ViewConfiguration.html#getScaledTouchSlop%28%29" target="_blank" rel="external">ViewConfiguration.getScaledTouchSlop()</a> 使用 ViewConfiguration 中提供的值以保证所有触摸的交互都是统一的。这个方法获取的值表示:用户的手滑动这个距离后,才判定为正在进行滑动.当然这个值也可以自己来决定.但是为了一致性,还是使用标准的值较好.</p>
<p><a href="http://developer.android.com/reference/android/telephony/PhoneNumberUtils.html#convertKeypadLettersToDigits%28java.lang.String%29" target="_blank" rel="external">PhoneNumberUtils.convertKeypadLettersToDigits</a> 顾名思义.将字母转换为数字,类似于T9输入法,</p>
<p><a href="http://developer.android.com/reference/android/content/Context.html#getCacheDir%28%29" target="_blank" rel="external">Context.getCacheDir()</a> 获取缓存数据文件夹的路径,很简单但是知道的人不多,这个路径通常在SD卡上(这里的SD卡指的是广义上的SD卡,包括外部存储和内部存储)Adnroid/data/您的应用程序包名/cache/  下面.测试的时候,可以去这里面看是否缓存成功.缓存在这里的好处是:不用自己再去手动创建文件夹,不用担心用户把自己创建的文件夹删掉,在应用程序卸载的时候,这里会被清空,使用第三方的清理工具的时候,这里也会被清空.</p>
<p><a href="http://developer.android.com/reference/android/animation/ArgbEvaluator.html" target="_blank" rel="external">ArgbEvaluator</a> 用于处理颜色的渐变。就像 Chris Banes 说的一样，这个类会进行很多自动装箱的操作，所以最好还是去掉它的逻辑自己去实现它。这个没用过,不明其所以然,回头再补充.</p>
<p><a href="http://developer.android.com/reference/android/view/ContextThemeWrapper.html" target="_blank" rel="external">ContextThemeWrapper</a> 方便在运行的时候修改主题.</p>
<p><a href="http://developer.android.com/reference/android/widget/Space.html" target="_blank" rel="external">Space</a> space是Android 4.0中新增的一个控件，它实际上可以用来分隔不同的控件，其中形成一个空白的区域.这是一个轻量级的视图组件，它可以跳过Draw，对于需要占位符的任何场景来说都是很棒的。</p>
<p><a href="http://developer.android.com/reference/android/animation/ValueAnimator.html#reverse%28%29" target="_blank" rel="external">ValueAnimator.reverse()</a> 这个方法可以很顺利地取消正在运行的动画.我超喜欢.</p>
<h2 id="备忘">备忘</h2><p>More: <a href="http://www.androidperformance.com/android-tips-round-up.html" target="_blank" rel="external">Part1</a> , <a href="http://www.androidperformance.com/android-tips-round-up-2.html" target="_blank" rel="external">Part2</a> , <a href="http://www.androidperformance.com/android-tips-round-up-3.html" target="_blank" rel="external">Part3</a> , <a href="http://www.androidperformance.com/android-tips-round-up-4.html" target="_blank" rel="external">Part4</a>, <a href="http://www.androidperformance.com/android-tips-round-up-5.html" target="_blank" rel="external">Part5</a><br>原文地址:<a href="http://blog.danlew.net/2014/03/30/android-tips-round-up-part-1/" target="_blank" rel="external">http://blog.danlew.net/2014/03/30/android-tips-round-up-part-1/</a><br>原文作者:<a href="http://blog.danlew.net/about/" target="_blank" rel="external">http://blog.danlew.net/about/</a><br>本文地址:<a href="http://www.androidperformance.com/android-tips-round-up-1.html" target="_blank" rel="external">http://www.androidperformance.com/android-tips-round-up-1.html</a> 转载请注明.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文是一篇译文,这篇是这个系列的第一篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[Android4.4]第三方APP无法操作外置SD卡原因分析以及延伸阅读]]></title>
    <link href="http://androidperformance.com/2014/05/17/apps-can-no-android4-4-app-longer-write-files-to-your-sd-card.html"/>
    <id>http://androidperformance.com/2014/05/17/apps-can-no-android4-4-app-longer-write-files-to-your-sd-card.html</id>
    <published>2014-05-17T03:20:30.000Z</published>
    <updated>2015-03-27T05:20:04.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-问题背景:">1.问题背景:</h3><p>最近做Android4.4的平台移植,遇到一个问题:在Android4.4中,第三方App是没有权限操作外置SD卡的(除非是与自己包名相同的目录),开始以为是自己申请的权限不足,最后发现是Google在Android中限制了这一权限.这是原文:</p>
<blockquote>
<p><span style="\"color:" #404040;\"="">The WRITE_EXTERNAL_STORAGE permission must only grant write access to the primary external storage on a device. Apps must not be allowed to write to secondary external storage devices, except in their package-specific directories as allowed by synthesized permissions.</span></p>
</blockquote>
<p>意思就是说,只有主存储有读写的权限,第二存储(通常是外置SD卡或者USBOTG,这个可以在设置菜单中自己设置)只有读的权限.原因也有给出:</p>
<blockquote>
<p><span style="\"color:" #404040;\"="">Restricting writes in this way ensures the system can clean up files when applications are uninstalled.</span></p>
</blockquote>
<p>另一个原因我觉得是安全的问题,这一方面的陈述会在下面详细介绍.</p>
<a id="more"></a>
<h3 id="2-解决办法:">2.解决办法:</h3><p>解决办法分两种,一种针对用户,一种针对开发者.</p>
<p><strong><em>针对用户:</em></strong></p>
<p>已经root的用户可以通过修改:<span style="\"color:" #444444;\"="">/system/etc/permissions/platform.xml</span> 文件(使用RE文件管理器即可),找到如下代码块:</p>
<pre class="\"lang:java" decode:true\"="" title="\"写sd卡的权限\"">    &lt;permission name=\"android.permission.WRITE_EXTERNAL_STORAGE\" &gt;
        &lt;group gid=\"sdcard_r\" /&gt;
        &lt;group gid=\"sdcard_rw\" /&gt;
    &lt;/permission&gt;</pre>

<p>修改为:</p>
<pre class="\"lang:java" decode:true\"="" title="\"修改后的写SD卡权限\"">    &lt;permission name=\"android.permission.WRITE_EXTERNAL_STORAGE\" &gt;
        &lt;group gid=\"sdcard_r\" /&gt;
        &lt;group gid=\"sdcard_rw\" /&gt;
    &lt;group gid=\"media_rw\" /&gt;
    &lt;/permission&gt;</pre>

<p>然后重启.就可以读写SD卡了.</p>
<p>这个做法其实就是给<span style="\"color:" #666666;\"="">android.permission.WRITE_EXTERNAL_STORAGE</span> 这个权限组加上对media的读写权限.</p>
<p><strong><em>针对开发者:</em></strong></p>
<p><span style="\"color:" #323333;\"="">XDA论坛上的方法，先把文件改为图片类型，再用media content provider来删除.</span></p>
<pre class="\"lang:java" decode:true\"="" title="\"转换成媒体文件,再进行操作\"">private static final Uri FILES_URI = MediaStore.Files.getContentUri(\"external\");
    public static boolean deleteFile(Context context, String path) {
        ContentResolver cr = context.getContentResolver();
        if (cr == null) return false;
        final String selection = FileColumns.DATA + \"=?\";
        final String[] selectionArgs = new String[] { path };
        ContentValues values = new ContentValues();
        values.put(FileColumns.MEDIA_TYPE, FileColumns.MEDIA_TYPE_IMAGE);
        return cr.update(FILES_URI, values, selection, selectionArgs) &gt; 0
                &amp;&amp; cr.delete(FILES_URI, selection, selectionArgs) &gt; 0;
    }</pre>

<p>这样做是因为MediaProvider拥有读写SD卡的 权限,通过它去操作文件也可以达到目标.不过有人反映如果把默认存储设置为内置SD卡，该方法貌似就失效了。不知道有没有更好的办法？</p>
<p><strong><em>针对rom开发者:</em></strong></p>
<p>rom开发者有更好的选择,<span style="\"color:" #444444;\"="">platform.xml的文件位置在源代码:frameworks/base/data/etc/中,和方法1中的步骤一样:</span></p>
<pre class="\"lang:java" decode:true\"="" title="\"写sd卡的权限\"">    &lt;permission name=\"android.permission.WRITE_EXTERNAL_STORAGE\" &gt;
        &lt;group gid=\"sdcard_r\" /&gt;
        &lt;group gid=\"sdcard_rw\" /&gt;
    &lt;/permission&gt;</pre>

<p>修改为:</p>
<pre class="\"lang:java" decode:true\"="" title="\"修改后的写SD卡权限\"">    &lt;permission name=\"android.permission.WRITE_EXTERNAL_STORAGE\" &gt;
        &lt;group gid=\"sdcard_r\" /&gt;
        &lt;group gid=\"sdcard_rw\" /&gt;
    &lt;group gid=\"media_rw\" /&gt;
    &lt;/permission&gt;</pre>

<p>然后重新编译一个rom即可.</p>
<p>&nbsp;</p>
<h3 id="3-延伸阅读">3.延伸阅读</h3><p>Google这么做的原因,我也查阅了一些文章,下面是一些我觉得比较好的回答,大家感兴趣可以自己看一下:</p>
<p>第一篇是Google+上的一个人的分析,大概解释了一下google这样做的原因以及造成的影响(英文很简单):</p>
<blockquote>
<p><span style="\"color:" #404040;\"="">KitKat will make your SD Card completely useless: per the Android API specification, apps can no longer write files to your SD card.  And Samsung is following it.This only applies to dual-storage devices, i.e., devices with a user-writable internal flash storage <strong>AND</strong> a removable SD card.</span></p>
<p><span style="\"color:" #404040;\"="">From </span><span style="\"color:" #427fed;\"=""><a href="http://source.android.com/devices/tech/storage/index.html" target="_blank" rel="external">http://source.android.com/devices/tech/storage/index.html</a></span><span style="\"color:" #404040;\"="">:\”The WRITE_EXTERNAL_STORAGE permission must only grant write access to the primary external storage on a device. Apps must not be allowed to write to secondary external storage devices, except in their package-specific directories as allowed by synthesized permissions.\”</span></p>
<p><span style="\"color:" #404040;\"="">If your device has user-accessible internal flash storage, your SD Card is a \”secondary external storage device\”.</span></p>
<p><span style="\"color:" #404040;\"="">What this means is that with KitKat, applications will no longer be able create, modify, or remove files and folders on your external SD card.  As a for-instance, you can no longer use a file manager to copy files from your computer to the SD card over a network.  This ability, which has existed since the beginning of Android, has been taken away.</span></p>
<p><span style="\"color:" #404040;\"="">The only stated reason for this removal of functionality is that, \”Restricting writes in this way ensures the system can clean up files when applications are uninstalled.\”  I do not pretend to understand this logic.  Apps are still allowed to write in arbitrary directories on the primary storage (with the appropriate permission), but are denied the same access to external storage.</span></p>
<p><span style="\"color:" #404040;\"="">Samsung has implemented this feature with their KitKat OTA updates.  Note3 users are now complaining that FX File Explorer can no longer write to their external SD cards.  There are solutions to this problem for users with root access.  Users without root access appear to be screwed.</span></p>
<p><span style="\"color:" #404040;\"="">I\’m not quite certain how Google intends for you to place files on your SD card.  Perhaps you have to use proprietary Google apps that contain permissions unavailable to the rest of the developer world.  Perhaps you\’re supposed to put everything on the cloud and pay carrier data fees to get it there.  Perhaps you\’re supposed to use some kind of WIRE to attach your WIRELESS device to your computer and have the computer do that work for you.</span></p>
<p><span style="\"color:" #404040;\"="">In my opinion this is a horrible misstep by Google and the Android Open Source Project.  Functionality has been removed without reason, to the severe detriment of users and developers alike.</span></p>
<p><span style="\"color:" #404040;\"="">I apologize for not bringing this to everyone\’s attention when KitKat 4.4 was released, but it was not mentioned in the Android 4.4 changes document:</span><span style="\"color:" #427fed;\"=""><a href="http://developer.android.com/about/versions/android-4.4.html" target="_blank" rel="external">http://developer.android.com/about/versions/android-4.4.html</a></span><span style="\"color:" #404040;\"="">.  It\’s only mentioned in the article on </span><span style="\"color:" #427fed;\"="">source.android.com</span><span style="\"color:" #404040;\"="">.  I was only made aware of its existence from user reports as a result of Samsung implementing this change in its KitKat OTA updates. </span></p>
</blockquote>
<p>第二篇是知乎上的讨论,大家自行脑补:</p>
<blockquote>
<p><span style="\"color:" #232323;\"="">这有可能真的只是一个限制，影响很小，因为这个限制并不彻底，primary external storage 仍然可写，而支持双 SD 的设备并不很多。我们大家更期待的是让 primary external storage 也同样受到这个限制，虽然这个修改将涉及到更多应用的不兼容。</span></p>
<p><span style="\"color:" #232323;\"="">所以这个问题并没有彻底解决，到对 primary external storage 也限制的那个时候，才真正的解决了这个问题。</span></p>
<p><span style="\"color:" #232323;\"="">就目前而言，第二 SD 卡仍然是可以读写的，只是要读写到指定的目录（具体应该在 /Android/data/）。这样的规定意味着应用程序只能对 SD 卡的指定目录进行读写，不能读写任意目录。相当于 Google 出手对 SD 卡目录结构进行了规范。之前 android 不限制目录，所以各种应用就随意的在 SD 卡上建一个目录。然后 SD 卡上的目录到处都是，用户对这种现象早就深恶痛绝了！如果 Google 对这件事情下狠手，只能说是<strong>大快人心</strong>。</span></p>
<p><span style="\"color:" #232323;\"="">另外说一下，SD 卡上的指定目录是这样获取的：</span><br><span style="\"color:" #232323;\"="">1，程序相关的 内置存储目录，这个目录位于内置 flash，应用程序可以随意读写：</span></p>
<p><pre class="\"lang:java" decode:true\"="">getFilesDir();</pre><br><span style="\"color:" #232323;\"="">2，程序相关的 SD 卡外部存储目录，这个目录位于 SD 卡，应用程序可以随意读写：</span></p>
<p><pre class="\"lang:java" decode:true="" crayon-selected\"="">getExternalFilesDir(null);</pre><br><span style="\"color:" #232323;\"="">3，SD 卡公共目录，这些目录仍然可以访问，不受权限限制：</span></p>
<p><pre class="\"lang:java" decode:true\"="">Environment.getExternalStoragePublicDirectory(x)</pre><br><span style="\"color:" #232323;\"="">其中 x 可以是 Environment.DIRECTORY_ALARMS 等预定义的常量。可以查找 Environment 的帮助。</span></p>
<p><span style="\"color:" #232323;\"="">如果大家要存储数据，可以用 1 或者 2 的方法，获取正确的目录，然后进行任意读写，这样不会把 SD 卡的目录写乱。</span></p>
</blockquote>
<p>第三篇也是知乎上一个讨论:</p>
<blockquote>
<p><span style="\"color:" #232323;\"="">Google 给出的理由有一定的道理——相信很多有洁癖的人都很讨厌第三方应用在 SD 卡或者内置存储下随意建立文件夹吧，有节操的应用应该只在以自己的包名区分的目录下存放需要的文件。</span></p>
<p><span style="\"color:" #232323;\"="">至于为什么只限制 SD 卡，不包括内置存储，我觉得是因为 SD 卡是可以插在别的地方的，目录结构是有可能暴露出来的，也有可能被修改。规范应用在 SD 卡的读写，可以使得这个 SD 卡上的目录和文件可以在其他设备上被电脑「理解」——「这个目录是在某一个 Android 设备上用到的，我不必理会它」，如果第三方应用随意在 SD 卡根目录创建命名不规范并且无规律的目录，这个 SD 卡在其他地方就会使电脑或者人迷惑——「这个目录是干什么的？是谁创建的？我可不可以删掉它？」。手机的内部存储空间不能拆卸，所以其目录结构不会轻易暴露给用户，也不会放在别的设备上，所以可以暂时不管。</span></p>
</blockquote>
<p>&nbsp;</p>
<p>参考:</p>
<p>1.<a href="\">https://plus.google.com/+TodLiebeck/posts/gjnmuaDM8sn</a></p>
<p>2.<a href="\">http://www.zhihu.com/question/22778889</a></p>
<p>3.<a href="\">http://source.android.com/devices/tech/storage/index.html</a></p>
<p>&nbsp;</p>
<p>相关阅读 :</p>
<ol>
<li><a href="\">Android4.4中扫描文件广播权限变更分析</a></li>
</ol>
<blockquote>
<p><span style="\"color:" #ff0000;\"="">作者：<a href="\" title="\">Gracker</a></span><br><span style="\"color:" #ff0000;\"="">出处：<a href="\" title="\">androidperformance.com</a></span><br><span style="\"color:" #ff0000;\"="">本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</span><br><span style="\"color:" #ff0000;\"="">打赏一下： <a href="\">微博打赏</a></span></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-问题背景:">1.问题背景:</h3><p>最近做Android4.4的平台移植,遇到一个问题:在Android4.4中,第三方App是没有权限操作外置SD卡的(除非是与自己包名相同的目录),开始以为是自己申请的权限不足,最后发现是Google在Android中限制了这一权限.这是原文:</p>
<blockquote>
<p><span style=\"color: #404040;\">The WRITE_EXTERNAL_STORAGE permission must only grant write access to the primary external storage on a device. Apps must not be allowed to write to secondary external storage devices, except in their package-specific directories as allowed by synthesized permissions.</span></p>
</blockquote>
<p>意思就是说,只有主存储有读写的权限,第二存储(通常是外置SD卡或者USBOTG,这个可以在设置菜单中自己设置)只有读的权限.原因也有给出:</p>
<blockquote>
<p><span style=\"color: #404040;\">Restricting writes in this way ensures the system can clean up files when applications are uninstalled.</span></p>
</blockquote>
<p>另一个原因我觉得是安全的问题,这一方面的陈述会在下面详细介绍.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[Android4.4]Permission Denial: not allowed to send broadcast android.intent.action.MEDIA_MOUNTED]]></title>
    <link href="http://androidperformance.com/2014/05/14/android4-4permission-denial-not-allowed-to-send-broadcast-android-intent-action-media-mounted.html"/>
    <id>http://androidperformance.com/2014/05/14/android4-4permission-denial-not-allowed-to-send-broadcast-android-intent-action-media-mounted.html</id>
    <published>2014-05-14T15:37:28.000Z</published>
    <updated>2015-03-27T05:19:36.000Z</updated>
    <content type="html"><![CDATA[<h4 id="摘要:_Android4-4修改了MEDIA_MOUNTED广播的权限,导致发送这个广播会出现权限问题,本文分析这个问题出现的原因,并给出解决方案-">摘要: Android4.4修改了MEDIA_MOUNTED广播的权限,导致发送这个广播会出现权限问题,本文分析这个问题出现的原因,并给出解决方案.</h4><p>&nbsp;</p>
<h3 id="0-_问题背景">0. 问题背景</h3><p>在Android4.4之前，许多应用程序使用如下代码去通知更新文件数据库</p>
<pre class="\"lang:java" decode:true\"="" title="\"通知系统更新文件系统\"">sendBroadcast(new Intent(Intent.ACTION_MEDIA_MOUNTED, 
     Uri.parse(\"file://\" + Environment.getExternalStorageDirectory())));</pre>

<p>这样做的坏处：每次发送这个广播，都会<span style="\"color:" #222222;\"="">让MediaScanner重新扫描一次系统文件，很影响设备的电池寿命。当然传入的路径可以</span> 是单个文件或者内容很少的文件夹，会减轻扫描系统文件的压力，但是还是会因为扫描频繁而浪费电。所以在Android4.4<span style="\"color:" #222222;\"="">开始，只允许系统应用发送这样的intent。</span> 所以在Android4.4系统的机器上会出现如下错误：</p>
<pre class="\"lang:java" decode:true\"="" title="\"错误\""> Permission Denial: not allowed to send broadcast android.intent.action.MEDIA_MOUNTED</pre>

<h3 id="1-_解决办法：">1. 解决办法：</h3><p>1 . 将Intent换为 <a href="\"><code>ACTION_MEDIA_SCANNER_SCAN_FILE</code></a><span style="\"color:" #000000;\"="">.</span></p>
<pre class="\"lang:java" decode:true\"="" title="\"ACTION_MEDIA_SCANNER_SCAN_FILE\"">sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, 
     Uri.parse(\"file://\" + Environment.getExternalStorageDirectory())));</pre>

<p>但是这个Intent只扫描文件，不扫描文件夹。如果你的应用只操作单个文件而不是文件夹，就可以使用这个。 2. 不发广播，换为MediaScannerConnection进行通知更新</p>
<pre class="\"lang:java" decode:true\"="" title="\"MediaScannerConnection\""> MediaScannerConnection.scanFile(this,
          new String[] { file.toString() }, null,
          new MediaScannerConnection.OnScanCompletedListener() {
      public void onScanCompleted(String path, Uri uri) {
          Log.i(\"ExternalStorage\", \"Scanned \" + path + \":\");
          Log.i(\"ExternalStorage\", \"-&gt; uri=\" + uri);
      }
 });</pre>

<p>这样做就属于不发送广播,在4.4上可以正常工作.</p>
<a id="more"></a>
<h4 id="拓展">拓展</h4><p>代码跟踪,让我们看看scanFile做了什么事: 1.查看scanFile的源码:</p>
<pre class="\"lang:java" decode:true\"="" title="\"scanFile\"">    public static void scanFile(Context context, String[] paths, String[] mimeTypes,
            OnScanCompletedListener callback) {
        ClientProxy client = new ClientProxy(paths, mimeTypes, callback);
        MediaScannerConnection connection = new MediaScannerConnection(context, client);
        client.mConnection = connection;
        connection.connect();
    }</pre>

<p>2.ClintProxy源码:</p>
<pre class="\"lang:java" decode:true\"="" title="\"ClientProxy\"">    static class ClientProxy implements MediaScannerConnectionClient {
        final String[] mPaths;
        final String[] mMimeTypes;
        final OnScanCompletedListener mClient;
        MediaScannerConnection mConnection;
        int mNextPath;

        ClientProxy(String[] paths, String[] mimeTypes, OnScanCompletedListener client) {
            mPaths = paths;
            mMimeTypes = mimeTypes;
            mClient = client;
        }

        public void onMediaScannerConnected() {
            scanNextPath();
        }

        public void onScanCompleted(String path, Uri uri) {
            if (mClient != null) {
                mClient.onScanCompleted(path, uri);
            }
            scanNextPath();
        }

        void scanNextPath() {
            if (mNextPath &gt;= mPaths.length) {
                mConnection.disconnect();
                return;
            }
            String mimeType = mMimeTypes != null ? mMimeTypes[mNextPath] : null;
            mConnection.scanFile(mPaths[mNextPath], mimeType);
            mNextPath++;
        }
    }</pre>

<p>3.MediaScannerConnection的connect方法:</p>
<pre class="\"lang:java" decode:true\"="" title="\"connect\"">    /**
     * Initiates a connection to the media scanner service.
     * {@link MediaScannerConnectionClient#onMediaScannerConnected()}
     * will be called when the connection is established.
     */
    public void connect() {
        synchronized (this) {
            if (!mConnected) {
                Intent intent = new Intent(IMediaScannerService.class.getName());
                intent.setComponent(
                        new ComponentName(\"com.android.providers.media\",
                                \"com.android.providers.media.MediaScannerService\"));
                mContext.bindService(intent, this, Context.BIND_AUTO_CREATE);
                mConnected = true;
            }
        }
    }</pre>

<p>这里可以看到,最后是start了一个service:MediaScannerService MediaScannerService 的源码可以在<a href="\">这里看到</a>:我们重点看一下scan方法:</p>
<pre class="\"lang:java" decode:true\"="" title="\"scan\"">private void scan(String[] directories, String volumeName) {
        // don\'t sleep while scanning
        mWakeLock.acquire();

        ContentValues values = new ContentValues();
        values.put(MediaStore.MEDIA_SCANNER_VOLUME, volumeName);
        Uri scanUri = getContentResolver().insert(MediaStore.getMediaScannerUri(), values);

        Uri uri = Uri.parse(\"file://\" + directories[0]);
        sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_STARTED, uri));

        try {
            if (volumeName.equals(MediaProvider.EXTERNAL_VOLUME)) {
                 openDatabase(volumeName);    
            }

            MediaScanner scanner = createMediaScanner();
            scanner.scanDirectories(directories, volumeName);
        } catch (Exception e) {
            Log.e(TAG, \"exception in MediaScanner.scan()\", e); 
        }

        getContentResolver().delete(scanUri, null, null);

        sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_FINISHED, uri));
        mWakeLock.release();
    }</pre>

<p>可以看到最终调用了<span style="\"color:" #48484c;\"="">MediaScanner来进行扫描,扫描结束后,发送ACTION_MEDIA_SCANNER_FINISHED广播.应用程序可以接受此广播来更新界面之类</span></p>
<p>&nbsp;</p>
<p>参考资料：</p>
<ol>
<li><p><a href="\">http://stackoverflow.com/questions/18624235/android-refreshing-the-gallery-after-saving-new-images</a></p>
</li>
<li><p><a href="\">http://stackoverflow.com/questions/21469431/permission-denial-not-allowed-to-send-broadcast-in-android</a></p>
</li>
<li><p><a href="\">http://www.androideng.com/?p=1108</a></p>
</li>
</ol>
<blockquote>
<p><span style="\"color:" #ff0000;\"="">作者：<a href="\" title="\">Gracker</a></span><br><span style="\"color:" #ff0000;\"="">出处：<a href="\" title="\">androidperformance.com</a></span><br><span style="\"color:" #ff0000;\"="">本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</span><br><span style="\"color:" #ff0000;\"="">打赏一下： <a href="\">微博打赏</a></span></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="摘要:_Android4-4修改了MEDIA_MOUNTED广播的权限,导致发送这个广播会出现权限问题,本文分析这个问题出现的原因,并给出解决方案-">摘要: Android4.4修改了MEDIA_MOUNTED广播的权限,导致发送这个广播会出现权限问题,本文分析这个问题出现的原因,并给出解决方案.</h4><p>&nbsp;</p>
<h3 id="0-_问题背景">0. 问题背景</h3><p>在Android4.4之前，许多应用程序使用如下代码去通知更新文件数据库</p>
<pre class=\"lang:java decode:true\" title=\"通知系统更新文件系统\">sendBroadcast(new Intent(Intent.ACTION_MEDIA_MOUNTED, 
     Uri.parse(\"file://\" + Environment.getExternalStorageDirectory())));</pre>

<p>这样做的坏处：每次发送这个广播，都会<span style=\"color: #222222;\">让MediaScanner重新扫描一次系统文件，很影响设备的电池寿命。当然传入的路径可以</span> 是单个文件或者内容很少的文件夹，会减轻扫描系统文件的压力，但是还是会因为扫描频繁而浪费电。所以在Android4.4<span style=\"color: #222222;\">开始，只允许系统应用发送这样的intent。</span> 所以在Android4.4系统的机器上会出现如下错误：</p>
<pre class=\"lang:java decode:true\" title=\"错误\"> Permission Denial: not allowed to send broadcast android.intent.action.MEDIA_MOUNTED</pre>

<h3 id="1-_解决办法：">1. 解决办法：</h3><p>1 . 将Intent换为 <a href="\"><code>ACTION_MEDIA_SCANNER_SCAN_FILE</code></a><span style=\"color: #000000;\">.</span></p>
<pre class=\"lang:java decode:true\" title=\"ACTION_MEDIA_SCANNER_SCAN_FILE\">sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, 
     Uri.parse(\"file://\" + Environment.getExternalStorageDirectory())));</pre>

<p>但是这个Intent只扫描文件，不扫描文件夹。如果你的应用只操作单个文件而不是文件夹，就可以使用这个。 2. 不发广播，换为MediaScannerConnection进行通知更新</p>
<pre class=\"lang:java decode:true\" title=\"MediaScannerConnection\"> MediaScannerConnection.scanFile(this,
          new String[] { file.toString() }, null,
          new MediaScannerConnection.OnScanCompletedListener() {
      public void onScanCompleted(String path, Uri uri) {
          Log.i(\"ExternalStorage\", \"Scanned \" + path + \":\");
          Log.i(\"ExternalStorage\", \"-&gt; uri=\" + uri);
      }
 });</pre>

<p>这样做就属于不发送广播,在4.4上可以正常工作.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android开发:Log2File工具类]]></title>
    <link href="http://androidperformance.com/2014/05/02/android_log_to_file.html"/>
    <id>http://androidperformance.com/2014/05/02/android_log_to_file.html</id>
    <published>2014-05-02T05:25:35.000Z</published>
    <updated>2015-03-27T05:19:46.000Z</updated>
    <content type="html"><![CDATA[<div style="color: #000000;">Log2File工具类是用于Android程序将Log记录到文件中(如sd卡)的工具,应用场景：</div><br><div style="color: #000000;"><br><br>1.  无法连接电脑进行调试（usb线被usbotg占用）<br>2.  Log不容易被抓取<br>3.  Bug出现很随机，不是必出现<br>4.  其他自己脑补<br><br>##  0.说明<br><br>这篇文章最早是在我的CSDN博客上面发布了:<a href="http://blog.csdn.net/grackergao/article/details/18322749" title="Log2File类的使用" target="_blank" rel="external">http://blog.csdn.net/grackergao/article/details/18322749</a> .现在讲他转移到了这里,代码的Github地址 :<a href="https://github.com/Gracker/Android-Utils/blob/master/Log2File.java" title="Log2File的github地址" target="_blank" rel="external">https://github.com/Gracker/Android-Utils/blob/master/Log2File.java</a><br><br><a id="more"></a><br><br>## 1.Log2File工具类源码<br><br><pre class="lang:java decode:true " title="Log2File工具类源码">import java.io.BufferedWriter;<br>import java.io.File;<br>import java.io.FileWriter;<br>import java.io.IOException;<br>import java.util.Date;<br><br>import android.content.Context;<br>import android.os.Environment;<br><br>public class Log2File<br>{<br>    private static boolean  logInit;<br>    private static BufferedWriter writer;<br><br>    private Log2File()<br>    {<br><br>    }<br><br>    /<strong><br>     <em> 初始化Log,创建log文件
     </em> @param ctx<br>     <em> @param fileName
     </em> @return<br>     */<br>    public static boolean init(Context ctx, String fileName)<br>    {<br>        if(!logInit)<br>        {<br>            String state = Environment.getExternalStorageState();<br>            if (Environment.MEDIA_MOUNTED.equals(state))<br>            {<br>                File sdDir = Environment.getExternalStorageDirectory();<br>                File logDir = new File(sdDir.getAbsolutePath() + “/log2file/“ +<br>                        ctx.getPackageName() + “/“);<br><br>                try {<br>                    if(!logDir.exists())<br>                    {<br>                        logDir.mkdirs();<br>                    }<br><br>                    File logFile = new File(logDir, fileName);<br>                    logFile.createNewFile();<br><br>                    writer = new BufferedWriter(new FileWriter(logFile, true));<br>                    logInit = true;<br>                } catch (IOException e) {<br>                    // TODO Auto-generated catch block<br>                    e.printStackTrace();<br>                }<br><br>            }<br><br>        }<br><br>        return logInit;<br>    }<br><br>    /</strong><br>     <em> 写一条log
     </em> @param msg<br>     <em>/<br>    public static void w(String msg)<br>    {<br>        if(logInit)<br>        {<br>            try {<br>                Date date = new Date();<br>                writer.write(“[“ + date.toLocaleString() + “] “ + msg);<br>                writer.newLine();<br>                writer.flush();<br>            } catch (IOException e) {<br>                // TODO Auto-generated catch block<br>            }<br>        }<br>    }<br><br>    /**
     </em> 关闭log<br>     */<br>    public static void close()<br>    {<br>        if(logInit)<br>        {<br>            try {<br>                writer.close();<br>                writer = null;<br><br>            } catch (IOException e) {<br>                // TODO Auto-generated catch block<br>                e.printStackTrace();<br>            }<br><br>            logInit = false;<br>        }<br>    }<br>}<br></pre><br><br>##  2.Log2File类的使用<br><br><div>这个工具类的使用比较简单</div><br><div>1.首先调用init进行初始化</div><br><div><br><pre class="lang:java decode:true " title="Log2File类的初始化">Log2File.init(context, fileName);</pre><br>2.调用w()进行输出<br><pre class="lang:java decode:true " title="调用w(String msg)函数进行输出">Log2File.w(String msg);</pre><br>3.使用完毕后，记得要关闭Log<br><pre class="lang:java decode:true  crayon-selected" title="关闭Log">Log2File.close();</pre><br></div><br></div>]]></content>
    <summary type="html">
    <![CDATA[<div style="color: #000000;">Log2File工具类是用于Android程序将Log记录到文件中(如sd卡)的工具,应用场景：</div><br><div style="color: #000000;"><br><br>1.  无法连接电脑进行调试（usb线被usbotg占用）<br>2.  Log不容易被抓取<br>3.  Bug出现很随机，不是必出现<br>4.  其他自己脑补<br><br>##  0.说明<br><br>这篇文章最早是在我的CSDN博客上面发布了:<a href="http://blog.csdn.net/grackergao/article/details/18322749" title="Log2File类的使用">http://blog.csdn.net/grackergao/article/details/18322749</a> .现在讲他转移到了这里,代码的Github地址 :<a href="https://github.com/Gracker/Android-Utils/blob/master/Log2File.java" title="Log2File的github地址">https://github.com/Gracker/Android-Utils/blob/master/Log2File.java</a><br><br>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
      <category term="Github" scheme="http://androidperformance.com/categories/Android/Github/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Service：开发自己的通知中心(2):辅助性服务实战]]></title>
    <link href="http://androidperformance.com/2014/04/01/android-service-build-your-own-notification-servers-app.html"/>
    <id>http://androidperformance.com/2014/04/01/android-service-build-your-own-notification-servers-app.html</id>
    <published>2014-03-31T16:05:47.000Z</published>
    <updated>2015-03-27T05:27:19.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1-辅助性服务实战介绍">1.辅助性服务实战介绍</h2><p>上一篇文章介绍了什么是Accessibility以及简单的使用，这一篇文章就来讲讲如何使用Accessibility服务来创建一个简单的Android通知中心。Android中通知中心是一个系统层面的服务，负责显示应用和系统发来的通知（Notification，比如USB插入、选择输入法、未接来电、截图、天气信息、新闻推送等等）。在android4.3之前，一般的第三方应用是无法获取Notification list的（在Android4.3之后，有了一个新的接口,NotificationListenerService.getActiveNotifications(),可以获取当前的Notification）。但是利用Accessibility服务可以监听到各种事件的特性，可以开发一个第三方的通知中心，实现与系统通知栏类似的功能。</p>
<a id="more"></a>
<p>下面就来介绍如何开发自己的通知中心。</p>
<h2 id="2-开发第三方通知中心">2.开发第三方通知中心</h2><h3 id="2-1继承AccessibilitySerivce">2.1继承AccessibilitySerivce</h3><p>按照上一篇辅助性服务的介绍，一个辅助性服务可以被捆绑到一个标准的应用程序上，或者以一个单独的安卓工程被创建，我们这里建立一个服务，继承AccessibilitySerivce</p>
<pre class="\"lang:java" decode:true\"="" title="\"继承AccessibilityService\"">import android.accessibilityservice.AccessibilityService;
import android.accessibilityservice.AccessibilityServiceInfo;
import android.app.Notification;
import android.app.PendingIntent;
import android.content.Intent;
import android.os.Parcelable;
import android.util.Log;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityNodeInfo;
import android.view.accessibility.AccessibilityRecord;
import android.widget.Toast;

public class NotificationFetcherService extends AccessibilityService {

    private static final String TAG = \"NotificationFetcherService: \";

    public void onAccessibilityEvent(AccessibilityEvent event) {
        if (!(event.getEventType() == AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED) ){
            return;
        }

        Notification localNotification = (Notification)event.getParcelableData();

        if (localNotification != null) {
            Intent intent=new Intent();
            intent.putExtra(\"NotifyData\", localNotification);
            intent.setAction(\".NotificationFetcherService\");
            sendBroadcast(intent);
        }

    }

    @Override
    protected void onServiceConnected() {

        // Define it in both xml file and here,  for compatibility with pre-ICS devices
        AccessibilityServiceInfo info = new AccessibilityServiceInfo();
        info.eventTypes = AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED |
                AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED | 
                AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED;

        info.feedbackType = AccessibilityServiceInfo.FEEDBACK_GENERIC;
        setServiceInfo(info);
    }

    @Override
    public void onInterrupt() {
        System.out.println(\"onInterrupt\");
    }

}</pre>

<p>继承AccessibilitySerivce必须要重写几个重要的方法：</p>
<p>onServiceConnected方法负责在服务和Activity绑定的时候，进行初始化数据，这里新建了一个AccessibilityServiceInfo对象，并将TYPE_NOTIFICATION_STATE_CHANGED、TYPE_WINDOW_STATE_CHANGED、TYPE_WINDOW_CONTENT_CHANGED纳入监听范围，TYPE_NOTIFICATION_STATE_CHANGED表示这个服务可以监听Notification的变化，我们正是使用这个特性来实现第三方的通知中心功能。</p>
<p>onInterrupt是服务断开时调用的函数</p>
<p>onAccessibilityEvent是最重要的，它负责监听所注册的eventTypes（在onServiceConnected中注册的）的事件。从上面的代码中我们可以得到一个Notification对象：</p>
<pre class="\"lang:java" decode:true\"="" title="\"得到Notification对象\"">Notification localNotification = (Notification)event.getParcelableData();</pre>

<p>得到Notification对象之后，就可以进行自己的操作，我这里是通过广播的形式，将收到的Notification发送给Activity进行处理。</p>
<p>这里也会碰到一个小问题：当一个Notification对象太大时（比如截图、未接来电等，Notification.contentView就很大，通过广播传播会出现data过大无法传输的问题），这时可以把Notification.contentView对象暂时保存在Application中，然后再置为null，Activity中接收到数据后，再进行赋值。</p>
<h3 id="2-2在Manifest中注册service">2.2在Manifest中注册service</h3><pre class="\"lang:java" decode:true\"="">&lt;service
            android:name=\".NotificationFetcherService\"
            android:permission=\"android.permission.BIND_ACCESSIBILITY_SERVICE\" &gt;
            &lt;intent-filter&gt;
                &lt;action android:name=\"android.accessibilityservice.AccessibilityService\" /&gt;
            &lt;/intent-filter&gt;

            &lt;meta-data
                android:name=\"android.accessibilityservice\"
                android:resource=\"@xml/accessibilityserviceconfig /&gt;
&lt;/service&gt;</pre>

<p>这里就是普通的service注册，注意 &lt;mate-data&gt;标签中的xml文件：从Android 4.0版本开始，有另外一种方法：使用XML文件来配置这类服务。如果你以XML的形式来定义你的服务，某些像canRetrieveWindowContent可配置的选项就可用了。和service一样的配置，使用XML来定义。如果你要使用XML路径，要在你的mainfest文件中指定它，在你的服务声明中添加&lt;meta-data&gt;标签,并指向这个XML资源文件。比如上面的代码，我们在res/xml/中建立accessibilityaseviceconfig.xml，内容如下：</p>
<pre class="\"lang:java" decode:true\"="">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;
&lt;accessibility-service xmlns:android=\"http://schemas.android.com/apk/res/android\"
    android:accessibilityEventTypes=\"typeWindowStateChanged|typeNotificationStateChanged|typeWindowContentChanged\"
    android:accessibilityFeedbackType=\"feedbackGeneric\"
/&gt;</pre>

<p>服务这里就配置好了。</p>
<h3 id="2-3_接受并处理Notification">2.3 接受并处理Notification</h3><p>下面的Activity中就可以接受这个数据，然后怎么处理就看自己了，这里只是简单地显示出来。</p>
<pre class="\"lang:java" decode:true\"="">import android.app.Activity;
import android.app.Application;
import android.app.Notification;
import android.app.PendingIntent;
import android.app.PendingIntent.CanceledException;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.os.Parcelable;
import android.os.Process;
import android.text.method.ScrollingMovementMethod;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.LinearLayout;
import android.widget.RemoteViews;
import android.widget.TextView;

public class NotificaitonActivity extends Activity {
    private static final int NOTIFY_DATA_FLAG = 1;
    private static final String NOTIFY_DATA_ID_STR= \"NotifyData\";

    private NotifyDataReceiver  receiver;
    private TextView textView;
    private LinearLayout rootLayout;
    private Button button;

    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.activity_main);
        textView = (TextView) findViewById(R.id.notify_test_textview);
        textView.setMovementMethod(ScrollingMovementMethod.getInstance());
        rootLayout = (LinearLayout) findViewById(R.id.root_layout);

        registerBroadcast();

        button = (Button) findViewById(R.id.test_button);
        button.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Button b = new Button(NotificaitonActivity.this);
                b.setText(\"Tthis\");
                rootLayout.addView(b);
            }
        });
    }

    private void registerBroadcast() {
        receiver = new NotifyDataReceiver();
        IntentFilter filter = new IntentFilter();
        filter.addAction(\".NotificationFetcherService\");
        this.registerReceiver(receiver, filter);
        Log.e(\"Dx:\", \"Broadcast registered.........\");
    }

    private void addToUi(RemoteViews remoteView) {
        rootLayout.addView(remoteView);
    }

    private void showNotify(String notiString) {
        textView.setText(textView.getText() + \"n\" + notiString);
    }

    private class NotifyDataReceiver extends BroadcastReceiver{

        @Override
        public void onReceive(Context context, Intent intent) {
            Log.e(\"Dx:\", \"Receiver got msg in onReceive()...\");

            Parcelable notifyParcelable = intent.getParcelableExtra(\"NotifyData\");

            if (notifyParcelable != null) {

                Notification notification = (Notification) notifyParcelable;
                showNotify(\"tickerText: \" + notification.tickerText);
                showNotify(\"toString: \" + (String)(notification.toString()));

                RemoteViews remoteV = notification.contentView;
                if (remoteV==null) {
                    showNotify(\"remoteView is: null\" );
                } else {
                    showNotify(\"remoteView is: not null\" );

                    addToUi(remoteV);
                }

                PendingIntent pendIntent = notification.contentIntent;
                if (pendIntent==null) {
                    showNotify(\"pendIntent is: null\" );
                } else {
                showNotify(\"pendIntent is: not null\" );
                }

                showNotify(\"**************************\" );
                showNotify(\"                    \" );

            }

        }
    }

}</pre>

<p><span style="\"color:" #ff0000;\"="">注：这里有很重要的一点，由于AccessibilityService的特殊性，用户必须手动到设置-辅助功能中，打开对应的服务，我们才可以通过AccessibilityService获得对应的数据，这一点非常重要。</span></p>
<p>上面的Activity只是简单地显示Notification，关于更多Notification的操作，可以参考Notification这个类，其中重要的属性有：contentView，flags。要模拟真正的通知中心，还是要费一番功夫的。这里由于公司项目的保密，暂不提供对应的实现代码（其实得到Notification就已经成功了一半了），有兴趣的同学可以私下和我交流。</p>
<h2 id="3-总结和问题">3.总结和问题</h2><p>AccessibilityService的实战就讲到这里，这一篇博文也是拖了一段时间才写完的，也算是为前一段时间的项目做个了结。</p>
<p>项目中目前还存在的问题：</p>
<ol>
<li>无法获取安装这个应用之前的系统的Notification</li>
<li>得到的Notification对象没法保存在本地，所以这个服务被杀掉之后，所有的数据都会丢失。（试过用db4o这种对象数据库来进行存储，发现行不通）</li>
<li>对Android系统的Notification对象的行为模仿不够（有些系统的事件监听不到，比如usb的插拔、usb调试的开关等）</li>
</ol>
<p>上面的问题，如果你有好的想法，我们私下交流。</p>
<blockquote>
<p><span style="\"color:" #ff0000;\"="">作者：<a href="\" title="\">Gracker</a></span><br><span style="\"color:" #ff0000;\"="">出处：<a href="\" title="\">androidperformance.com</a></span><br><span style="\"color:" #ff0000;\"="">本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</span><br><span style="\"color:" #ff0000;\"="">打赏一下： <a href="\">微博打赏</a></span></p>
</blockquote>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-辅助性服务实战介绍">1.辅助性服务实战介绍</h2><p>上一篇文章介绍了什么是Accessibility以及简单的使用，这一篇文章就来讲讲如何使用Accessibility服务来创建一个简单的Android通知中心。Android中通知中心是一个系统层面的服务，负责显示应用和系统发来的通知（Notification，比如USB插入、选择输入法、未接来电、截图、天气信息、新闻推送等等）。在android4.3之前，一般的第三方应用是无法获取Notification list的（在Android4.3之后，有了一个新的接口,NotificationListenerService.getActiveNotifications(),可以获取当前的Notification）。但是利用Accessibility服务可以监听到各种事件的特性，可以开发一个第三方的通知中心，实现与系统通知栏类似的功能。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android:Ubuntu下执行Adb命令找不到设备]]></title>
    <link href="http://androidperformance.com/2014/03/25/ubuntu-adb-can-not-find-devices.html"/>
    <id>http://androidperformance.com/2014/03/25/ubuntu-adb-can-not-find-devices.html</id>
    <published>2014-03-25T03:15:17.000Z</published>
    <updated>2015-03-27T05:25:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1-问题概述">1.问题概述</h2><p><span style="color: #000000;">最近开发Nokia项目，遇到的问题如下：</span></p>
<p><span style="color: #000000;">插入Nokia x后，电脑没有反应，即不识别，同事的windows也不识别，最后在谷歌上搜索了良久，才找到了解决方案，但是没有记录，后来又要给别人配置的时候，发现忘记怎么配置了。想想这也是一个具有通性的问题，还是记录下来，分享给大家。</span></p>
<h2 id="2-问题解决方案">2.问题解决方案</h2><p><span style="color: #000000;">首先问题是：执行adb命令提示找不到设备，在做其他操作之前，请先确认已经做了如下操作：</span></p>
<ol>
<li><span style="color: #000000;">确定已经打开了USB调试选项（设置-开发者选项-USB调试），有的机器没有开发者选项，需要到关于里面点击版本号若干下，或者去百度谷歌。</span></li>
<li><span style="color: #000000;">确定使用sudo命令adb kill-server 和adb start-server后仍然没有用。</span><br><span style="color: #000000;">如果上述操作都确认了，还是找不到设备，那么继续往下看：</span></li>
</ol>
<a id="more"></a>
<h3 id="2-1-运行lsusb"><span style="color: #000000;">2.1.运行lsusb</span></h3><pre class="lang:java decode:true">~ » lsusb                                                                  
Bus 002 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching Hub
Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 001 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching Hub
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 003 Device 004: ID 1532:0016 Razer USA, Ltd DeathAdder Mouse
Bus 003 Device 003: ID 05d5:624c Super Gate Technology Co., Ltd 
Bus 003 Device 033: ID 0421:06e8 Nokia Mobile Phones 
Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hu</pre>

<h3 id="2-2-注册到udve的rules文件"><span style="color: #000000;">2.2.注册到udve的rules文件</span></h3><pre class="lang:java decode:true">vim  /etc/udev/rules.d/51-android.rules    
添加这个ID：1ebf，如下：    
SUBSYSTEM=="usb", SYSFS{"Nokia Mobile Phones"}=="0421", MODE="06e8"   
保存文件并运行：    
sudo chmod a+rx /etc/udev/rules.d/51-android.rules    
sudo /etc/init.d/udev restart    
运行结果如下：    
Rather than invoking init scripts through /etc/init.d, use the service(8)    
utility, e.g. service udev restart    
Since the script you are attempting to invoke has been converted to an    
Upstart job, you may also use the stop(8) and then start(8) utilities,    
e.g. stop udev ; start udev. The restart(8) utility is also available.    
udev stop/waiting    
udev start/running, process 14636</pre>

<h3 id="2-3-使用sudo_关闭和启动adb"><span style="color: #000000;"> 2.3.使用sudo 关闭和启动adb</span></h3><p><pre class="lang:java decode:true">cd ~/tools/android-sdk-linux_x86/platform-tools<br>sudo ./adb kill-server<br>sudo ./adb start-server</pre><br><span style="color: #000000;"><span style="color: #ff0000;"> 注：一般情况下，上面的操作就可以。特殊情况下，usb设备还是不能被识别，比如我手上这台Nokia X</span>。那么继续：</span></p>
<h3 id="2-4-打开_～/-android/adb_usb-ini，加入之前的lsusb得到的信息"><span style="color: #000000;">2.4.打开 ～/.android/adb_usb.ini，加入之前的lsusb得到的信息</span></h3><p><pre class="lang:java decode:true"># ANDROID 4RD PARTY USB VENDOR ID LIST – DO NOT EDIT.</pre></p>
<h1 id="USE_‘android_update_adb’_TO_GENERATE-">USE ‘android update adb’ TO GENERATE.</h1><h1 id="1_USB_VENDOR_ID_PER_LINE">1 USB VENDOR ID PER LINE</h1><p>#for nokia x<br>0x0421<br><span style="color: #000000;"> 保存关闭后，就可以识别了。windows下也是如此，不多叙述了。</span></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-问题概述">1.问题概述</h2><p><span style="color: #000000;">最近开发Nokia项目，遇到的问题如下：</span></p>
<p><span style="color: #000000;">插入Nokia x后，电脑没有反应，即不识别，同事的windows也不识别，最后在谷歌上搜索了良久，才找到了解决方案，但是没有记录，后来又要给别人配置的时候，发现忘记怎么配置了。想想这也是一个具有通性的问题，还是记录下来，分享给大家。</span></p>
<h2 id="2-问题解决方案">2.问题解决方案</h2><p><span style="color: #000000;">首先问题是：执行adb命令提示找不到设备，在做其他操作之前，请先确认已经做了如下操作：</span></p>
<ol>
<li><span style="color: #000000;">确定已经打开了USB调试选项（设置-开发者选项-USB调试），有的机器没有开发者选项，需要到关于里面点击版本号若干下，或者去百度谷歌。</span></li>
<li><span style="color: #000000;">确定使用sudo命令adb kill-server 和adb start-server后仍然没有用。</span><br><span style="color: #000000;">如果上述操作都确认了，还是找不到设备，那么继续往下看：</span></li>
</ol>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
      <category term="Linux" scheme="http://androidperformance.com/categories/Android/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Service：开发自己的通知中心(1):辅助性服务介绍]]></title>
    <link href="http://androidperformance.com/2014/03/17/android-build-your-own-android-notification-service-app.html"/>
    <id>http://androidperformance.com/2014/03/17/android-build-your-own-android-notification-service-app.html</id>
    <published>2014-03-17T06:07:53.000Z</published>
    <updated>2015-03-27T05:26:14.000Z</updated>
    <content type="html"><![CDATA[<p>## </p>
<h1 id="1_辅助性服务介绍">1 辅助性服务介绍</h1><p>辅助性服务是安卓框架的一个特性，它的设计是为了让已经安装在安卓设备上的应用程序能够为用户提供一种导航式(引导式）回应。一个辅助性服务能够传达给<br>用户关于这个应用程序的利益，例如把文本转换成语音、当用户手指停留屏幕的一个重要区域时的haptic反馈。这一节涵盖了怎样去创建一个辅助性服务，如何处理应用程序的信息接收，还有如何把信息反馈给用户。<br>创建自己的辅助性服务</p>
<a id="more"></a>
<h1 id="2_创建自己的辅助性服务">2 创建自己的辅助性服务</h1><h2 id="2-1_继承AccessibilitySerivce">2.1 继承AccessibilitySerivce</h2><p>一个辅助性服务可以被捆绑到一个标准的应用程序上，或者以一个单独的安卓工程被创建。在任何情况下，创建这类服务的步骤都是一样的。在你的工程中，创建一个类继续AccessibilitySerivce。</p>
<pre class="\"lang:java" decode:true\"="" title="\"继承AccessibilityService\"">package com.example.android.apis.accessibility;

import android.accessibilityservice.AccessibilityService;

public class MyAccessibilityService extends AccessibilityService {
...
    @Override
    public void onAccessibilityEvent(AccessibilityEvent event) {
    }

    @Override
    public void onInterrupt() {
    }

...
}</pre>

<p>&nbsp;</p>
<h2 id="2-2_在mainfest中声明service">2.2 在mainfest中声明service</h2><p>像其他服务一样，你也可以在mainfest文件中声明它。记得要指定它处理android.accessibilityservice这个意图。以便当应用程序触发一个AccessibilityEvent时，这个服务能被调用。</p>
<pre class="\"lang:java" decode:true\"="" title="\"进行配置\"">&lt;application ...&gt;
...
&lt;service android:name=\".MyAccessibilityService\"&gt;
     &lt;intent-filter&gt;
         &lt;action android:name=\"android.accessibilityservice.AccessibilityService\" /&gt;
     &lt;/intent-filter&gt;
     . . .
&lt;/service&gt;
...
&lt;/application&gt;</pre>

<p>&nbsp;</p>
<h2 id="2-3_配置serivce">2.3 配置serivce</h2><p>如果你为这个服务创建一个新的工程的话，且不打算要一个应用程序，你可以把它启动活动的类（通常叫做MainActivity.java)从你的源文件中删除。同时也把相应的活动元素从你的mainfest文件中删除。<br>配置自己的辅助性服务<br>为你的辅助性服务设置配置变量，用它来告诉系统，如何和何时你想要它运行。哪一类事件你想要去响应？这个服务对所有的应用程序都是活动的吗？或者只有指定的包名的？它使用什么样的反馈？<br>你有两种方法去设置这些变量。反向兼容的方法是以代码的形式来设置它们。<br>可以使setServiceInfo(android.accessibilityservice.AccessibilityServiceInfo).如果要这样做的话，要重写onServiceConnected()方法，然后配置在那里配置你的服务。</p>
<pre class="\"lang:java" decode:true\"=""> 
@Override
public void onServiceConnected() {
    // Set the type of events that this service wants to listen to.  Others
    // won\'t be passed to this service.
    info.eventTypes = AccessibilityEvent.TYPE_VIEW_CLICKED |
            AccessibilityEvent.TYPE_VIEW_FOCUSED;

    // If you only want this service to work with specific applications, set their
    // package names here.  Otherwise, when the service is activated, it will listen
    // to events from all applications.
    info.packageNames = new String[]
            {\"com.example.android.myFirstApp\", \"com.example.android.mySecondApp\"};

    // Set the type of feedback your service will provide.
    info.feedbackType = AccessibilityServiceInfo.FEEDBACK_SPOKEN;

    // Default services are invoked only if no package-specific ones are present
    // for the type of AccessibilityEvent generated.  This service *is*
    // application-specific, so the flag isn\'t necessary.  If this was a
    // general-purpose service, it would be worth considering setting the
    // DEFAULT flag.

    // info.flags = AccessibilityServiceInfo.DEFAULT;

    info.notificationTimeout = 100;

    this.setServiceInfo(info);

}</pre>

<p>从Android 4.0版本开始，有另外一种方法：使用XML文件来配置这类服务。如果你以XML的形式来定义你的服务，某些像canRetrieveWindowContent可配置的选项就可用了。和上面一样的配置，使用XML来定义，格式如下所示：</p>
<pre class="\"lang:java" decode:true\"="">&lt;accessibility-service
     android:accessibilityEventTypes=\"typeViewClicked|typeViewFocused\"
     android:packageNames=\"com.example.android.myFirstApp, com.example.android.mySecondApp\"
     android:accessibilityFeedbackType=\"feedbackSpoken\"
     android:notificationTimeout=\"100\"
     android:settingsActivity=\"com.example.android.apis.accessibility.TestBackActivity\"
     android:canRetrieveWindowContent=\"true\"
/&gt;</pre>

<p>如果你要使用XML路径，要在你的mainfest文件中指定它，在你的服务声明中添加&lt;meta-data&gt;标签,并指向这个XML资源文件。假如你把你的XML文件存储在res/xml/serviceconfig.xml这个路径下，新的标签格式如下所示：</p>
<pre class="\"lang:java" decode:true\"="">&lt;service android:name=\".MyAccessibilityService\"&gt;
     &lt;intent-filter&gt;
         &lt;action android:name=\"android.accessibilityservice.AccessibilityService\" /&gt;
     &lt;/intent-filter&gt;
     &lt;meta-data android:name=\"android.accessibilityservice\"
     android:resource=\"@xml/serviceconfig\" /&gt;
&lt;/service&gt;</pre>

<p>&nbsp;</p>
<h2 id="2-4_响应AccessibilityEvents事件">2.4 响应AccessibilityEvents事件</h2><p>现在,您的服务被设置为运行和监听事件，写一些代码，这样当一个AccessibilityEvent真的到来，它就知道要做什么了！<br>从重写onAccessibilityEvent(AccessibilityEvent)方法开始。然后使用getEventType()来确定事件类型，然后用getContentDescription来取出任何与触发事件相关的标签文本。</p>
<pre class="\"lang:java" decode:true\"=""> 
@Override
public void onAccessibilityEvent(AccessibilityEvent event) {
    final int eventType = event.getEventType();
    String eventText = null;
    switch(eventType) {
        case AccessibilityEvent.TYPE_VIEW_CLICKED:
            eventText = \"Focused: \";
            break;
        case AccessibilityEvent.TYPE_VIEW_FOCUSED:
            eventText = \"Focused: \";
            break;
    }

    eventText = eventText + event.getContentDescription();

    // Do something nifty with this text, like speak the composed string
    // back to the user.
    speakToUser(eventText);
    ...
}</pre>

<p>为更多的上下文查询视图层次结构<br>这一步是可选的，然而它非常有用。Android 4.0(API level 14)的一个新特性：可以用AccessibilityService来查询视图层次结构，收集事件所生成的一些UI组件信息，还有这些UI的父控件和子控件。要做到这一点，确保在你的XML配置文件中做了如下设置：</p>
<pre class="\"lang:java" decode:true\"="">android:canRetrieveWindowContent=\"true\"</pre>

<p>如果设置了，通过getSource()可获得一个AccessibilityNodeInfo对象。如果发起的窗口事件仍然是活动的窗口，该调用将会返回一个对象,否则，会返回null。下面这段代码演示何时接收一个事件，步骤如下：<br>立即捕获触发事件的父视图。<br>在那个视图中，寻找一个标签和一个复选框作的子视图。<br>如果找到，创建一个字符串来向用户报告，以表明这个标签是否被选择了。<br>如果遍历视图层次结构后返回null,则会退出该方法。</p>
<pre class="\"lang:java" decode:true\"=""> 
// Alternative onAccessibilityEvent, that uses AccessibilityNodeInfo

@Override
public void onAccessibilityEvent(AccessibilityEvent event) {

    AccessibilityNodeInfo source = event.getSource();
    if (source == null) {
        return;
    }

    // Grab the parent of the view that fired the event.
    AccessibilityNodeInfo rowNode = getListItemNodeInfo(source);
    if (rowNode == null) {
        return;
    }

    // Using this parent, get references to both child nodes, the label and the checkbox.
    AccessibilityNodeInfo labelNode = rowNode.getChild(0);
    if (labelNode == null) {
        rowNode.recycle();
        return;
    }

    AccessibilityNodeInfo completeNode = rowNode.getChild(1);
    if (completeNode == null) {
        rowNode.recycle();
        return;
    }

    // Determine what the task is and whether or not it\'s complete, based on
    // the text inside the label, and the state of the check-box.
    if (rowNode.getChildCount() &lt; 2 || !rowNode.getChild(1).isCheckable()) {
        rowNode.recycle();
        return;
    }

    CharSequence taskLabel = labelNode.getText();
    final boolean isComplete = completeNode.isChecked();
    String completeStr = null;

    if (isComplete) {
        completeStr = getString(R.string.checked);
    } else {
        completeStr = getString(R.string.not_checked);
    }
    String reportStr = taskLabel + completeStr;
    speakToUser(reportStr);
}</pre>

<p>现在你有一个完整的，可以工作的辅助性服务。现在，你也可以试着配置一下，看看Android的text-to-speech engine,或使用Vibrator提供触觉反馈是如何与用户交互。</p>
<p>最后，要使用配置好的service，必须要到“设置–辅助性服务”中打开对应的service，然后才能相应对应的事件。</p>
<blockquote>
<p><span style="\"color:" #ff0000;\"="">作者：<a href="\" title="\">Gracker</a></span><br><span style="\"color:" #ff0000;\"="">出处：<a href="\" title="\">androidperformance.com</a></span><br><span style="\"color:" #ff0000;\"="">本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</span><br><span style="\"color:" #ff0000;\"="">打赏一下： <a href="\">微博打赏</a></span></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>## </p>
<h1 id="1_辅助性服务介绍">1 辅助性服务介绍</h1><p>辅助性服务是安卓框架的一个特性，它的设计是为了让已经安装在安卓设备上的应用程序能够为用户提供一种导航式(引导式）回应。一个辅助性服务能够传达给<br>用户关于这个应用程序的利益，例如把文本转换成语音、当用户手指停留屏幕的一个重要区域时的haptic反馈。这一节涵盖了怎样去创建一个辅助性服务，如何处理应用程序的信息接收，还有如何把信息反馈给用户。<br>创建自己的辅助性服务</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
</feed>
