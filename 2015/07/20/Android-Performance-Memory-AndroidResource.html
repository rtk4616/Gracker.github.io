<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="专注 Android 性能优化"><title>Android代码内存优化建议-Android资源篇 | Performance</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android代码内存优化建议-Android资源篇</h1><a id="logo" href="/.">Performance</a><p class="description">True mastery of any skill takes a lifetime</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android代码内存优化建议-Android资源篇</h1><div class="post-meta">Jul 20, 2015<span> | </span><span class="category"><a href="/categories/Android/">Android</a><a href="/categories/Android/Menory/">Menory</a><a href="/categories/Android/Menory/Performance/">Performance</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>这篇文章主要介绍在实际Android应用程序的开发中，容易导致内存泄露的一些情况。开发人员如果在进行代码编写之前就有内存泄露方面的基础知识，那么写出来的代码会强壮许多，写这篇文章也是这个初衷。本文从Android开发中的资源使用情况入手，介绍了如何在Bitmap、数据库查询、9-patch、过渡绘制等方面优化内存的使用。</p>
<a id="more"></a>
<h1 id="Android资源优化"><a href="#Android资源优化" class="headerlink" title="Android资源优化"></a>Android资源优化</h1><h2 id="1-Bitmap优化"><a href="#1-Bitmap优化" class="headerlink" title="1. Bitmap优化"></a>1. Bitmap优化</h2><p>Android中的大部分内存问题归根结底都是Bitmap的问题，如果打开MAT(Memory analyzer tool)来看，实际占用内存大的都是一些Bitmap(以byte数组的形式存储)。所以Bitmap的优化应该是我们着重去解决的。Google在其官方有针对Bitmap的使用专门写了一个专题 : <a href="http://developer.android.com/training/displaying-bitmaps/index.html" target="_blank" rel="external">Displaying Bitmaps Efficiently</a>, 对应的中文翻译在 ：<a href="https://github.com/kesenhoo/android-training-course-in-chinese/tree/master/graphics/displaying-bitmaps" target="_blank" rel="external">displaying-bitmaps</a> , 在优化Bitmap资源之前，请先看看这个系列的文档，以确保自己正确地使用了Bitmap。</p>
<p>Bitmap如果没有被释放，那么一般只有两个问题：</p>
<ul>
<li>用户在使用完这个Bitmap之后，没有主动去释放Bitmap资源。</li>
<li>这个Bitmap资源被引用所以无法被释放 。</li>
</ul>
<h3 id="1-1-主动释放Bitmap资源"><a href="#1-1-主动释放Bitmap资源" class="headerlink" title="1.1 主动释放Bitmap资源"></a>1.1 主动释放Bitmap资源</h3><p>当你确定这个Bitmap资源不会再被使用的时候(当然这个Bitmap不释放可能会让程序下一次启动或者resume快一些，但是其占用的内存资源太大，可能导致程序在后台的时候被杀掉，反而得不偿失)，我们建议手动调用recycle()方法，释放其Native内存：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if(<span class="keyword">bitmap </span>!= null &amp;&amp; !<span class="keyword">bitmap.isRecycled())&#123; </span> </div><div class="line">    <span class="keyword">bitmap.recycle(); </span></div><div class="line">    <span class="keyword">bitmap </span>= null<span class="comment">; </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们也可以看一下Bitmap.java中recycle()方法的说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">/**</span></div><div class="line">     * Free the native object associated with this bitmap, and clear the</div><div class="line">     * reference to the pixel data. This will not free the pixel data synchronously;</div><div class="line">     * it simply allows it to be garbage collected if there are no other references.</div><div class="line">     * The bitmap is marked as "dead", meaning it will throw an exception if</div><div class="line">     * getPixels() or setPixels() is called, and will draw nothing. This operation</div><div class="line">     * cannot be reversed, so it should only be called if you are sure there are no</div><div class="line">     * further uses for the bitmap. This is an advanced call, and normally need</div><div class="line">     * not be called, since the normal GC process will free up this memory when</div><div class="line">     * there are no more references to this bitmap.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!mRecycled) &#123;</div><div class="line">            <span class="keyword">if</span> (nativeRecycle(mNativeBitmap)) &#123;</div><div class="line">                <span class="comment">// return value indicates whether native pixel object was actually recycled.</span></div><div class="line">                <span class="comment">// false indicates that it is still in use at the native level and these</span></div><div class="line">                <span class="comment">// objects should not be collected now. They will be collected later when the</span></div><div class="line">                <span class="comment">// Bitmap itself is collected.</span></div><div class="line">                mBuffer = <span class="keyword">null</span>;</div><div class="line">                mNinePatchChunk = <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">            mRecycled = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">......</div><div class="line"><span class="comment">//如果使用过程中抛出异常的判断</span></div><div class="line"><span class="keyword">if</span> (bitmap.isRecycled()) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Canvas: trying to use a recycled bitmap "</span> + bitmap);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用bitmap.recycle之后，这个Bitmap如果没有被引用到，那么就会被垃圾回收器回收。如果不主动调用这个方法，垃圾回收器也会进行回收工作，只不过垃圾回收器的不确定性太大，依赖其自动回收不靠谱(比如垃圾回收器一次性要回收好多Bitmap，那么需要的时间就会很多，导致回收的时候会卡顿)。所以我们需要主动调用recycle。</p>
<h3 id="1-2-主动释放ImageView的图片资源"><a href="#1-2-主动释放ImageView的图片资源" class="headerlink" title="1.2 主动释放ImageView的图片资源"></a>1.2 主动释放ImageView的图片资源</h3><p>由于我们在实际开发中，很多情况是在xml布局文件中设置ImageView的src或者在代码中调用ImageView.setImageResource/setImageURI/setImageDrawable等方法设置图像，下面代码可以回收这个ImageView所对应的资源：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">private</span> static void recycleImageViewBitMap(ImageView imageView) &#123;</div><div class="line">    <span class="meta">if</span> (imageView != null) &#123;</div><div class="line">        <span class="keyword">BitmapDrawable </span><span class="keyword">bd </span>= (<span class="keyword">BitmapDrawable) </span>imageView.getDrawable()<span class="comment">;</span></div><div class="line">        rceycleBitmapDrawable(<span class="keyword">bd);</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="symbol">private</span> static void rceycleBitmapDrawable(<span class="keyword">BitmapDrawable </span><span class="keyword">bitmapDrawable) </span>&#123;</div><div class="line">    <span class="meta">if</span> (<span class="keyword">bitmapDrawable </span>!= null) &#123;</div><div class="line">        <span class="keyword">Bitmap </span><span class="keyword">bitmap </span>= <span class="keyword">bitmapDrawable.getBitmap();</span></div><div class="line">        rceycleBitmap(<span class="keyword">bitmap);</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">bitmapDrawable </span>= null<span class="comment">;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="symbol">private</span> static void rceycleBitmap(<span class="keyword">Bitmap </span><span class="keyword">bitmap) </span>&#123;</div><div class="line">    <span class="meta">if</span> (<span class="keyword">bitmap </span>!= null &amp;&amp; !<span class="keyword">bitmap.isRecycled()) </span>&#123;</div><div class="line">        <span class="keyword">bitmap.recycle();</span></div><div class="line">        <span class="keyword">bitmap </span>= null<span class="comment">;</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1-3-主动释放ImageView的背景资源"><a href="#1-3-主动释放ImageView的背景资源" class="headerlink" title="1.3 主动释放ImageView的背景资源"></a>1.3 主动释放ImageView的背景资源</h3><p>如果你的ImageView是有Background，那么下面的代码可以释放他：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">public</span> static void recycleBackgroundBitMap(ImageView view) &#123;</div><div class="line">    <span class="meta">if</span> (view != null) &#123;</div><div class="line">        <span class="keyword">BitmapDrawable </span><span class="keyword">bd </span>= (<span class="keyword">BitmapDrawable) </span>view.getBackground()<span class="comment">;</span></div><div class="line">        rceycleBitmapDrawable(<span class="keyword">bd);</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="symbol">public</span> static void recycleImageViewBitMap(ImageView imageView) &#123;</div><div class="line">    <span class="meta">if</span> (imageView != null) &#123;</div><div class="line">        <span class="keyword">BitmapDrawable </span><span class="keyword">bd </span>= (<span class="keyword">BitmapDrawable) </span>imageView.getDrawable()<span class="comment">;</span></div><div class="line">        rceycleBitmapDrawable(<span class="keyword">bd);</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="symbol">private</span> static void rceycleBitmapDrawable(<span class="keyword">BitmapDrawable </span><span class="keyword">bitmapDrawable) </span>&#123;</div><div class="line">    <span class="meta">if</span> (<span class="keyword">bitmapDrawable </span>!= null) &#123;</div><div class="line">        <span class="keyword">Bitmap </span><span class="keyword">bitmap </span>= <span class="keyword">bitmapDrawable.getBitmap();</span></div><div class="line">        rceycleBitmap(<span class="keyword">bitmap);</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">bitmapDrawable </span>= null<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1-4-尽量少用Png图，多用NinePatch的图"><a href="#1-4-尽量少用Png图，多用NinePatch的图" class="headerlink" title="1.4 尽量少用Png图，多用NinePatch的图"></a>1.4 尽量少用Png图，多用NinePatch的图</h3><p>现在手机的分辨率越来越高，图片资源在被加载后所占用的内存也越来越大，所以要尽量避免使用大的PNG图，在产品设计的时候就要尽量避免用一张大图来进行展示，尽量多用NinePatch资源。</p>
<p>Android中的NinePatch指的是一种拉伸后不会变形的特殊png图，NinePatch的拉伸区域可以自己定义。这种图的优点是体积小，拉伸不变形，可以适配多机型。Android SDK中有自带NinePatch资源制作工具，Android-Studio中在普通png图片点击右键可以将其转换为NinePatch资源，使用起来非常方便。</p>
<p><img src="/images/Memory_AndroidSoruce/1.png" alt="左边是原图，右边是拉伸后的效果"></p>
<h3 id="1-5-使用大图之前，尽量先对其进行压缩"><a href="#1-5-使用大图之前，尽量先对其进行压缩" class="headerlink" title="1.5 使用大图之前，尽量先对其进行压缩"></a>1.5 使用大图之前，尽量先对其进行压缩</h3><p>图片有不同的形状与大小。在大多数情况下它们的实际大小都比需要呈现出来的要大很多。例如，系统的Gallery程序会显示那些你使用设备camera拍摄的图片，但是那些图片的分辨率通常都比你的设备屏幕分辨率要高很多。</p>
<p>考虑到程序是在有限的内存下工作，理想情况是你只需要在内存中加载一个低分辨率的版本即可。这个低分辨率的版本应该是与你的UI大小所匹配的，这样才便于显示。一个高分辨率的图片不会提供任何可见的好处，却会占用宝贵的(precious)的内存资源，并且会在快速滑动图片时导致(incurs)附加的效率问题。</p>
<p>Google官网的Training中，有一篇文章专门介绍如何有效地加载大图，里面提到了两个比较重要的技术：</p>
<ul>
<li>在图片加载前获取其宽高和类型</li>
<li>加载一个按比例缩小的版本到内存中</li>
</ul>
<p>原文地址：<a href="http://developer.android.com/training/displaying-bitmaps/load-bitmap.html#read-bitmap" target="_blank" rel="external">Loading Large Bitmaps Efficiently</a>,中文翻译地址：<a href="https://github.com/kesenhoo/android-training-course-in-chinese/blob/master/graphics/displaying-bitmaps/load-bitmap.md" target="_blank" rel="external">有效地加载大尺寸位图</a>，强烈建议每一位Android开发者都去看一下，并在自己的实际项目中使用到。</p>
<p>更多关于Bitmap的使用和优化，可以参考Android官方Training专题的<a href="http://developer.android.com/training/displaying-bitmaps/index.html" target="_blank" rel="external">displaying-bitmaps</a></p>
<h2 id="2-查询数据库没有关闭游标"><a href="#2-查询数据库没有关闭游标" class="headerlink" title="2 查询数据库没有关闭游标"></a>2 查询数据库没有关闭游标</h2><p>程序中经常会进行查询数据库的操作，但是经常会有使用完毕Cursor后没有关闭的情况。如果我们的查询结果集比较小，对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会复现内存问题，这样就会给以后的测试和问题排查带来困难和风险。<br>示例代码：</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Cursor cursor = getContentResolver().query(uri ...);</div><div class="line">	<span class="keyword">if</span> (cursor.moveToNext()) &#123;</div><div class="line"> 	... ... </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>修正示例代码:</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Cursor <span class="built_in">cursor</span> = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  	<span class="built_in">cursor</span> = getContentResolver().query(uri ...);</div><div class="line">	<span class="keyword">if</span> (<span class="built_in">cursor</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">cursor</span>.moveToNext()) &#123;</div><div class="line">	... ... </div><div class="line">	&#125;</div><div class="line">	&#125; <span class="keyword">finally</span> &#123;</div><div class="line">		<span class="keyword">if</span> (<span class="built_in">cursor</span> != <span class="keyword">null</span>) &#123;</div><div class="line">	<span class="keyword">try</span> &#123; </div><div class="line">		<span class="built_in">cursor</span>.close();</div><div class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">		<span class="comment">//ignore this</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>`</p>
<h2 id="3-构造Adapter时，没有使用缓存的convertView"><a href="#3-构造Adapter时，没有使用缓存的convertView" class="headerlink" title="3 构造Adapter时，没有使用缓存的convertView"></a>3 构造Adapter时，没有使用缓存的convertView</h2><p>以构造ListView的BaseAdapter为例，在BaseAdapter中提供了方法：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> View getView(<span class="keyword">int</span> <span class="built_in">position</span>, View convertView, ViewGroup parent)</div></pre></td></tr></table></figure>
<p>来向ListView提供每一个item所需要的view对象。初始时ListView会从BaseAdapter中根据当前的屏幕布局实例化一定数量的view对象，同时ListView会将这些view对象缓存起来。当向上滚动ListView时，原先位于最上面的list item的view对象会被回收，然后被用来构造新出现的最下面的list item。这个构造过程就是由getView()方法完成的，getView()的第二个形参 View convertView就是被缓存起来的list item的view对象(初始化时缓存中没有view对象则convertView是null)。<br>由此可以看出，如果我们不去使用convertView，而是每次都在getView()中重新实例化一个View对象的话，即浪费资源也浪费时间，也会使得内存占用越来越大。ListView回收list item的view对象的过程可以查看:android.widget.AbsListView.java –> void addScrapView(View scrap) 方法。</p>
<p><img src="/images/Memory_AndroidSoruce/2.png" alt="ListView的getView"></p>
<p>示例代码：</p>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public <span class="keyword">View</span> getView(int position, <span class="keyword">View</span> convertView, ViewGroup parent) &#123;</div><div class="line"> <span class="keyword">View</span> <span class="keyword">view</span> = <span class="keyword">new</span> Xxx(...)<span class="comment">;</span></div><div class="line"> ... ...</div><div class="line"> <span class="keyword">return</span> <span class="keyword">view</span><span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>`<br>示例修正代码：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public <span class="built_in">View</span> getView(int position, <span class="built_in">View</span> convertView, ViewGroup parent) &#123;</div><div class="line"> <span class="built_in">View</span> <span class="built_in">view</span> = <span class="built_in">null</span>;</div><div class="line"> <span class="keyword">if</span> (convertView != <span class="built_in">null</span>) &#123;</div><div class="line"> <span class="built_in">view</span> = convertView;</div><div class="line"> populate(<span class="built_in">view</span>, getItem(position));</div><div class="line"> ...</div><div class="line"> &#125; <span class="keyword">else</span> &#123;</div><div class="line"> <span class="built_in">view</span> = <span class="keyword">new</span> Xxx(...);</div><div class="line"> ...</div><div class="line"> &#125;</div><div class="line"> <span class="keyword">return</span> <span class="built_in">view</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于ListView的使用和优化，可以参考这两篇文章：</p>
<ul>
<li><a href="http://www.vogella.com/tutorials/AndroidListView/article.html" target="_blank" rel="external">Using lists in Android (ListView) - Tutorial
  </a></li>
<li><a href="http://developer.android.com/training/improving-layouts/smooth-scrolling.html#ViewHolder" target="_blank" rel="external">Making ListView Scrolling Smooth</a></li>
</ul>
<h2 id="4-释放对象的引用"><a href="#4-释放对象的引用" class="headerlink" title="4 释放对象的引用"></a>4 释放对象的引用</h2><p>前面有说过，一个对象的内存没有被释放是因为他被其他的对象所引用，系统不回去释放这些有GC Root的对象。</p>
<p>示例A：<br>假设有如下操作</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DemoActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">	... ...</div><div class="line">	<span class="keyword">private</span> <span class="type">Handler</span> mHandler = ...</div><div class="line">	<span class="keyword">private</span> <span class="type">Object</span> obj;</div><div class="line">	public void operation() &#123;</div><div class="line">	 obj = initObj();</div><div class="line">	 ...</div><div class="line">	 [<span class="type">Mark</span>]</div><div class="line">	 mHandler.post(<span class="keyword">new</span> <span class="type">Runnable</span>() &#123;</div><div class="line">	        public void run() &#123;</div><div class="line">	         useObj(obj);</div><div class="line">	        &#125;</div><div class="line">	 &#125;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们有一个成员变量 obj，在operation()中我们希望能够将处理obj实例的操作post到某个线程的MessageQueue中。在以上的代码中，即便是mHandler所在的线程使用完了obj所引用的对象，但这个对象仍然不会被垃圾回收掉，因为DemoActivity.obj还保有这个对象的引用。所以如果在DemoActivity中不再使用这个对象了，可以在[Mark]的位置释放对象的引用，而代码可以修改为：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</div><div class="line">	obj = initObj();</div><div class="line">	...</div><div class="line">	<span class="keyword">final</span> Object o = obj;</div><div class="line">	obj = <span class="keyword">null</span>;</div><div class="line">	mHandler.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">	    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">	        useObj(o);</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>示例B：<br>假设我们希望在锁屏界面(LockScreen)中，监听系统中的电话服务以获取一些信息(如信号强度等)，则可以在LockScreen中定义一个PhoneStateListener的对象，同时将它注册到TelephonyManager服务中。对于LockScreen对象，当需要显示锁屏界面的时候就会创建一个LockScreen对象，而当锁屏界面消失的时候LockScreen对象就会被释放掉。  </p>
<p>但是如果在释放LockScreen对象的时候忘记取消我们之前注册的PhoneStateListener对象，则会导致LockScreen无法被垃圾回收。如果不断的使锁屏界面显示和消失，则最终会由于大量的LockScreen对象没有办法被回收而引起OutOfMemory,使得system_ui进程挂掉。</p>
<p>总之当一个生命周期较短的对象A，被一个生命周期较长的对象B保有其引用的情况下，在A的生命周期结束时，要在B中清除掉对A的引用。</p>
<p>使用MAT可以很方便地查看对象之间的引用，</p>
<h2 id="5-在Activity的生命周期中释放资源"><a href="#5-在Activity的生命周期中释放资源" class="headerlink" title="5 在Activity的生命周期中释放资源"></a>5 在Activity的生命周期中释放资源</h2><p>Android应用程序中最典型的需要注意释放资源的情况是在Activity的生命周期中，在onPause()、onStop()、onDestroy()方法中需要适当的释放资源的情况。由于此情况很基础，在此不详细说明，具体可以查看官方文档对Activity生命周期的介绍，以明确何时应该释放哪些资源。</p>
<h2 id="6-消除过渡绘制"><a href="#6-消除过渡绘制" class="headerlink" title="6 消除过渡绘制"></a>6 消除过渡绘制</h2><p>过渡绘制指的是在屏幕一个像素上绘制多次(超过一次),比如一个TextView后有背景，那么显示文本的像素至少绘了两次，一次是背景，一次是文本。GPU过度绘制或多或少对性能有些影响,设备的内存带宽是有限的，当过度绘制导致应用需要更多的带宽(超过了可用带宽)的时候性能就会降低。带宽的限制每个设备都可能是不一样的。</p>
<p>过渡绘制的原因:</p>
<ol>
<li>同一层级的View叠加</li>
<li>复杂的层级叠加</li>
</ol>
<p>减少过渡绘制能去掉一些无用的View，能有效减少GPU的负载，也可以减轻一部分内存压力。关于过渡绘制我专门写了一篇文章来介绍：<a href="http://www.androidperformance.com/android-performance-optimization-overdraw-1.html" target="_blank" rel="external">过渡绘制及其优化</a></p>
<h2 id="7-使用Android系统自带的资源"><a href="#7-使用Android系统自带的资源" class="headerlink" title="7 使用Android系统自带的资源"></a>7 使用Android系统自带的资源</h2><p>在Android应用开发过程中，屏幕上控件的布局代码和程序的逻辑代码通常是分开的。界面的布局代码是放在一个独立的xml文件中的，这个文件里面是树型组织的，控制着页面的布局。通常，在这个页面中会用到很多控件，控件会用到很多的资源。Android系统本身有很多的资源，包括各种各样的字符串、图片、动画、样式和布局等等，这些都可以在应用程序中直接使用。这样做的好处很多，既可以减少内存的使用，又可以减少部分工作量，也可以缩减程序安装包的大小。</p>
<p>比如下面的代码就是使用系统的ListView：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;ListView </div><div class="line">    android:<span class="built_in">id</span>=<span class="string">"@android:id/list"</span></div><div class="line">    android:layout_width=<span class="string">"fill_parent"</span></div><div class="line">    android:layout_height=<span class="string">"fill_parent"</span>/&gt;</div></pre></td></tr></table></figure>
<h2 id="8-使用内存相关工具检测"><a href="#8-使用内存相关工具检测" class="headerlink" title="8 使用内存相关工具检测"></a>8 使用内存相关工具检测</h2><p>在开发中，不可能保证一次就开发出一个内存管理非常棒的应用，所以在开发的每一个阶段，都要有意识地去针对内存进行专门的检查。目前Android提供了许多布局、内存相关的工具，比如Lint、MAT等。学会这些工具的使用是一个Android开发者必不可少的技能。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://androidperformance.com/2015/07/20/Android-Performance-Memory-AndroidResource.html" data-id="cj1w1bzx500045izez7jy4xzm" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Android/">Android</a><a href="/tags/MAT/">MAT</a><a href="/tags/Performance/">Performance</a><a href="/tags/Menory/">Menory</a></div><div class="post-nav"><a href="/2015/07/20/Android-Performance-Memory-Google.html" class="pre">Android代码内存优化建议-Android官方篇</a><a href="/2015/07/20/Android-Performance-Memory-onTrimMemory.html" class="next">Android代码内存优化建议-OnTrimMemory优化</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://androidperformance.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Github/">Github</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Menory/">Menory</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Menory/Performance/">Performance</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/View/">View</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/性能优化/">性能优化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/设计/">设计</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/设计/翻译/">翻译</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/2017/">2017</a></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/hwui/" style="font-size: 15px;">hwui</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/MAT/" style="font-size: 15px;">MAT</a> <a href="/tags/Performance/" style="font-size: 15px;">Performance</a> <a href="/tags/Menory/" style="font-size: 15px;">Menory</a> <a href="/tags/启动优化/" style="font-size: 15px;">启动优化</a> <a href="/tags/DelayLoad/" style="font-size: 15px;">DelayLoad</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/RenderThread/" style="font-size: 15px;">RenderThread</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/HashMap/" style="font-size: 15px;">HashMap</a> <a href="/tags/Singleton/" style="font-size: 15px;">Singleton</a> <a href="/tags/Nexus/" style="font-size: 15px;">Nexus</a> <a href="/tags/设计规范/" style="font-size: 15px;">设计规范</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/04/23/About-work.html">关于 2017</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/19/Avoiding-cold-starts-on-Android.html">Avoiding cold starts on Android</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/07/how-png-works.html">How PNG Works</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/05/android-bottom-bar-2.html">Android Bottom navigation 规范二：样式、行为与规格</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/05/android-bottom-bar-1.html">Android Bottom navigation 规范一：使用方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/31/How-to-calculation-android-app-lunch-time.html">Android 中如何计算 App 的启动时间？</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/29/Android应用启动优化-一种DelayLoad的实现和原理-下篇.html">Android应用启动优化:一种DelayLoad的实现和原理(下篇)</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/11/18/Android-app-lunch-optimize-delay-load.html">Android应用启动优化:一种DelayLoad的实现和原理(上篇)</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/12/AndroidL-hwui-RenderThread-workflow.html">Android5.0中 hwui 中 RenderThread 工作流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/05/HashMap.html">HashMap源码分析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a>2017 </a><a href="/." rel="nofollow">Performance.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>