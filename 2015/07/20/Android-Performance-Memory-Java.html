<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="google-site-verification" content="" />
  
  <title>Android代码内存优化建议-Java官方篇</title>
  <meta name="author" content="Gracker">
   <meta name="description" content="专注 Android 性能优化">
  

  <meta property="og:title" content="Android代码内存优化建议-Java官方篇"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:site_name" content="Performance"/>
 <meta property="og:image" content="undefined"/>
  
  <link href="/apple-touch-icon-precomposed.png" sizes="180x180" rel="apple-touch-icon-precomposed">
  <link rel="alternate" href="/atom.xml" title="Performance" type="application/atom+xml">
  <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.6/css/bootstrap.min.css">
  <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="/css/m.min.css">
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
</head>

<body>
  <div id='wx_pic' style='display:none;'><img src='/wx_share.png'/></div>
  <div id="main">
    <div class="behind">
      <div class="back">
        <a href="/" class="black-color"><i class="fa fa-times" aria-hidden="true"></i></a>
      </div>
      <div class="description">
        &nbsp;True mastery of any skill takes a lifetime
      </div>
    </div>
    <div class="container">
      

  <article class="standard post">
    <div class="title">
      
  
    <h1 class="page-title center">
        Android代码内存优化建议-Java官方篇
    </h1>
  


    </div>
    <div class="meta center">
      
<time datetime="2015-07-20T03:26:09.000Z">
  <i class="fa fa-calendar"></i>&nbsp;
  2015-07-20
</time>



    
    &nbsp;
    <i class="fa fa-tag"></i>&nbsp;
    <a href="/categories/Android/">Android</a>·<a href="/categories/Android/Menory/">Menory</a>·<a href="/categories/Android/Menory/Performance/">Performance</a>




    
    &nbsp;
    <i class="fa fa-tag"></i>&nbsp;
    <a href="/tags/Android/">Android</a>·<a href="/tags/MAT/">MAT</a>·<a href="/tags/Performance/">Performance</a>·<a href="/tags/Menory/">Menory</a>


    </div>
    <hr>
    <div class="picture-container">
      
    </div>
    <p>这篇文章主要是介绍了一些小细节的优化技巧，当这些小技巧综合使用起来的时候，对于整个App的性能提升还是有作用的，只是不能较大幅度的提升性能而已。选择合适的算法与数据结构才应该是你首要考虑的因素，在这篇文章中不会涉及这方面。你应该使用这篇文章中的小技巧作为平时写代码的习惯，这样能够提升代码的效率。</p>
<p>本文的原文为Google官方Training的性能优化部分，这一章节主要讲解的是高性能Android代码优化建议,建议所有Android应用开发者都仔细阅读这份文档，并将所提到的编码思想运用到实际的Android开发中。</p>
<a id="more"></a>
<blockquote>
<p>原文地址：<a href="http://developer.android.com/training/articles/perf-tips.html" target="_blank" rel="external">http://developer.android.com/training/articles/perf-tips.html</a></p>
</blockquote>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>通常来说，高效的代码需要满足下面两个规则：</p>
<ul>
<li>不要做冗余的动作</li>
<li>如果能避免，尽量不要分配内存</li>
</ul>
<p>你会面临最棘手的一个问题是当你优化一个肯定会在多种类型的硬件上运行的应用程序。不同版本的VM在不同的处理器上运行速度不同。它甚至不是你可以简单地说“设备X因为F原因比设备Y快/慢”那么简单,而且也不能简单地从一个设备拓展到另一个设备。特别提醒的是模拟器在性能方面和其他的设备没有可比性。通常有JIT优化和没有JIT优化的设备之间存在巨大差异:经过JIT代码优化的设备并不一定比没有经过JIT代码优化的设备好。</p>
<p>代码的执行效果会受到设备CPU,设备内存,系统版本等诸多因素的影响。为了确保代码能够在不同设备上都运行良好，需要最大化代码的效率。</p>
<h2 id="1-避免创建不必要的对象"><a href="#1-避免创建不必要的对象" class="headerlink" title="1)避免创建不必要的对象"></a>1)避免创建不必要的对象</h2><p>虽然GC可以回收不用的对象，可是为这些对象分配内存，并回收它们同样是需要耗费资源的。<br>因此请尽量避免创建不必要的对象，有下面一些例子来说明这个问题：</p>
<ul>
<li>如果你需要返回一个String对象，并且你知道它最终会需要连接到一个StringBuffer，请修改你的实现方式，避免直接进行连接操作，应该采用创建一个临时对象来做这个操作.</li>
<li>当从输入的数据集中抽取出Strings的时候，尝试返回原数据的substring对象，而不是创建一个重复的对象。</li>
</ul>
<p>一个稍微激进点的做法是把所有多维的数据分解成1维的数组:</p>
<ul>
<li>一组int数据要比一组Integer对象要好很多。可以得知，两组1维数组要比一个2维数组更加的有效率。同样的，这个道理可以推广至其他原始数据类型。</li>
<li>如果你需要实现一个数组用来存放(Foo,Bar)的对象，尝试分解为Foo[]与Bar[]要比(Foo,Bar)好很多。(当然，为了某些好的API的设计，可以适当做一些妥协。但是在自己的代码内部，你应该多多使用分解后的容易。</li>
</ul>
<p>通常来说，需要避免创建更多的对象。更少的对象意味者更少的GC动作，GC会对用户体验有比较直接的影响。</p>
<h2 id="2-选择Static而不是Virtual"><a href="#2-选择Static而不是Virtual" class="headerlink" title="2)选择Static而不是Virtual"></a>2)选择Static而不是Virtual</h2><p>如果你不需要访问一个对象的值域,请保证这个方法是static类型的,这样方法调用将快15%-20%。这是一个好的习惯，因为你可以从方法声明中得知调用无法改变这个对象的状态。</p>
<h2 id="3-常量声明为Static-Final"><a href="#3-常量声明为Static-Final" class="headerlink" title="3)常量声明为Static Final"></a>3)常量声明为Static Final</h2><p>先看下面这种声明的方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> intVal = <span class="number">42</span>;</div><div class="line"><span class="keyword">static</span> String strVal = <span class="string">"Hello, world!"</span>;</div></pre></td></tr></table></figure></p>
<p>编译器会在类首次被使用到的时候，使用初始化<code>&lt;clinit&gt;</code>方法来初始化上面的值，之后访问的时候会需要先到它那里查找，然后才返回数据。我们可以使用static final来提升性能：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> intVal = <span class="number">42</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> String strVal = <span class="string">"Hello, world!"</span>;</div></pre></td></tr></table></figure></p>
<p>这时再也不需要上面的那个方法来做多余的查找动作了。<br><strong> 所以，请尽可能的为常量声明为static final类型的。</strong></p>
<h2 id="4-避免内部的Getters-Setters"><a href="#4-避免内部的Getters-Setters" class="headerlink" title="4)避免内部的Getters/Setters"></a>4)避免内部的Getters/Setters</h2><p>像C++等native language,通常使用getters(i = getCount())而不是直接访问变量(i = mCount).这是编写C++的一种优秀习惯，而且通常也被其他面向对象的语言所采用，例如C#与Java，因为编译器通常会做inline访问，而且你需要限制或者调试变量，你可以在任何时候在getter/setter里面添加代码。<br><strong>然而，在Android上，这是一个糟糕的写法</strong>。Virtual method的调用比起直接访问变量要耗费更多。那么合理的做法是：<strong>在面向对象的设计当中应该使用getter/setter，但是在类的内部你应该直接访问变量。</strong><br>没有<code>JIT(Just In Time Compiler)</code>时，直接访问变量的速度是调用getter的3倍。有JIT时,直接访问变量的速度是通过getter访问的7倍。<br>请注意，如果你使用<a href="http://developer.android.com/tools/help/proguard.html" target="_blank" rel="external">ProGuard</a>, 你可以获得同样的效果，因为ProGuard可以为你inline accessors.</p>
<h2 id="5-使用增强的For循环写法"><a href="#5-使用增强的For循环写法" class="headerlink" title="5)使用增强的For循环写法"></a>5)使用增强的For循环写法</h2><p>请比较下面三种循环的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> mSplat;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo[] mArray = ...</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mArray.length; ++i) &#123;</div><div class="line">        sum += mArray[i].mSplat;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">one</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    Foo[] localArray = mArray;</div><div class="line">    <span class="keyword">int</span> len = localArray.length;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</div><div class="line">        sum += localArray[i].mSplat;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">two</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (Foo a : mArray) &#123;</div><div class="line">        sum += a.mSplat;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>zero()是最慢的，因为JIT没有办法对它进行优化。</li>
<li>one()稍微快些。</li>
<li>two() 在没有做JIT时是最快的，可是如果经过JIT之后，与方法one()是差不多一样快的。它使用了增强的循环方法for-each。</li>
</ul>
<p>所以请尽量使用for-each的方法，但是对于ArrayList，请使用方法one()。</p>
<h2 id="6-使用包级访问而不是内部类的私有访问"><a href="#6-使用包级访问而不是内部类的私有访问" class="headerlink" title="6)使用包级访问而不是内部类的私有访问"></a>6)使用包级访问而不是内部类的私有访问</h2><p>参考下面一段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">stuff</span><span class="params">()</span> </span>&#123;</div><div class="line">            Foo.<span class="keyword">this</span>.doStuff(Foo.<span class="keyword">this</span>.mValue);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mValue;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        Inner in = <span class="keyword">new</span> Inner();</div><div class="line">        mValue = <span class="number">27</span>;</div><div class="line">        in.stuff();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStuff</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Value is "</span> + value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里重要的是，我们定义了一个私有的内部类（Foo$Inner），它直接访问了外部类中的私有方法以及私有成员对象。这是合法的，这段代码也会如同预期一样打印出”Value is 27”。</p>
<p>问题是，VM因为Foo和Foo$Inner是不同的类，会认为在Foo$Inner中直接访问Foo类的私有成员是不合法的。即使Java语言允许内部类访问外部类的私有成员。为了去除这种差异，编译器会产生一些仿造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">int</span> Foo.access$<span class="number">100</span>(Foo foo) &#123;</div><div class="line">    <span class="keyword">return</span> foo.mValue;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*package*/</span> <span class="keyword">static</span> <span class="keyword">void</span> Foo.access$<span class="number">200</span>(Foo foo, <span class="keyword">int</span> value) &#123;</div><div class="line">    foo.doStuff(value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每当内部类需要访问外部类中的mValue成员或需要调用doStuff()函数时，它都会调用这些静态方法。这意味着，上面的代码可以归结为，通过accessor函数来访问成员变量。早些时候我们说过，通过accessor会比直接访问域要慢。所以，这是一个特定语言用法造成性能降低的例子。</p>
<p>如果你正在性能热区（hotspot:高频率、重复执行的代码段）使用像这样的代码，你可以把内部类需要访问的域和方法声明为包级访问，而不是私有访问权限。不幸的是，这意味着在相同包中的其他类也可以直接访问这些域，所以在公开的API中你不能这样做。</p>
<h2 id="7-避免使用float类型"><a href="#7-避免使用float类型" class="headerlink" title="7)避免使用float类型"></a>7)避免使用float类型</h2><p>Android系统中float类型的数据存取速度是int类型的一半，尽量优先采用int类型。</p>
<h2 id="8-使用库函数"><a href="#8-使用库函数" class="headerlink" title="8)使用库函数"></a>8)使用库函数</h2><p>尽量使用System.arraycopy()等一些封装好的库函数，它的效率是手动编写copy实现的9倍多。</p>
<p><strong> Tip: Also see Josh Bloch’s Effective Java, item 47. </strong></p>
<h2 id="9-谨慎使用native函数"><a href="#9-谨慎使用native函数" class="headerlink" title="9)谨慎使用native函数"></a>9)谨慎使用native函数</h2><p>当你需要把已经存在的native code迁移到Android，请谨慎使用JNI。如果你要使用JNI,请学习<a href="http://developer.android.com/guide/practices/jni.html" target="_blank" rel="external">JNI Tips</a></p>
<h2 id="10-关于性能的误区"><a href="#10-关于性能的误区" class="headerlink" title="10)关于性能的误区"></a>10)关于性能的误区</h2><p>在没有做JIT之前，使用一种确切的数据类型确实要比抽象的数据类型速度要更有效率。(例如，使用HashMap要比Map效率更高。) 有误传效率要高一倍，实际上只是6%左右。而且，在JIT之后，他们直接并没有大多差异。</p>
<h2 id="11-关于测量"><a href="#11-关于测量" class="headerlink" title="11)关于测量"></a>11)关于测量</h2><p>上面文档中出现的数据是Android的实际运行效果。我们可以用<a href="http://developer.android.com/tools/debugging/debugging-tracing.html" target="_blank" rel="external">Traceview</a> 来测量，但是测量的数据是没有经过JIT优化的，所以实际的效果应该是要比测量的数据稍微好些。</p>
<p>关于如何测量与调试，还可以参考下面两篇文章：</p>
<ul>
<li><a href="http://developer.android.com/tools/debugging/debugging-tracing.html" target="_blank" rel="external">Profiling with Traceview and dmtracedump</a></li>
<li><a href="http://developer.android.com/tools/debugging/systrace.html" target="_blank" rel="external">Analysing Display and Performance with Systrace</a></li>
</ul>


  </article>
  </script>
    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
  </script>
  <div class="busuanzi center">
    页阅读量:&nbsp;<span id="busuanzi_value_page_pv"></span>&nbsp;・&nbsp;
    站访问量:&nbsp;<span id="busuanzi_value_site_pv"></span>&nbsp;・&nbsp;
    站访客数:&nbsp;<span id="busuanzi_value_site_uv"></span>
  </div>




    </div>
  </div>
  <footer class="page-footer"><div class="clearfix">
</div>
<div class="right-foot container">
    <div class="firstrow">
        <a href="#top" >
        <i class="fa fa-arrow-right"></i>
        </a>
        © XXX 2015-2016
    </div>
    <div class="secondrow">
        <a href="https://github.com/gaoryrt/hexo-theme-pln">
        Theme Pln
        </a>
    </div>
</div>
<div class="clearfix">
</div>
</footer>
  <script src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script>
<script src="/js/search.js"></script>
<script type="text/javascript">

// comments below to disable loading animation
function revealOnScroll() {
  var scrolled = $(window).scrollTop();
  $(".excerpt, .index-title, .index-meta, p").each(function() {
    var current = $(this),
      height = $(window).outerHeight(),
      offsetTop = current.offset().top;
    (scrolled + height + 50 > offsetTop) ? current.addClass("animation"):'';
  });
}
$(window).on("scroll", revealOnScroll);
$(document).ready(revealOnScroll)

// disqus scripts


// dropdown scripts
$(".dropdown").click(function(event) {
  var current = $(this);
  event.stopPropagation();
  $(current).children(".dropdown-content")[($(current).children(".dropdown-content").hasClass("open"))?'removeClass':'addClass']("open")
});
$(document).click(function(){
    $(".dropdown-content").removeClass("open");
})

// back to top scripts
$("a[href='#top']").click(function() {
  $("html, body").animate({ scrollTop: 0 }, 500);
  return false;
});


var path = "/search.xml";
searchFunc(path, 'local-search-input', 'local-search-result');

</script>

</body>
</html>
