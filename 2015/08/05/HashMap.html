<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="专注 Android 性能优化"><title>HashMap源码分析 | Android Performance</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.2"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-50993302-2','auto');
ga('require', 'GTM-5T9PB73');
ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">HashMap源码分析</h1><a id="logo" href="/.">Android Performance</a><p class="description">True mastery of any skill takes a lifetime</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">HashMap源码分析</h1><div class="post-meta">Aug 5, 2015<span> | </span><span class="category"><a href="/categories/Java/">Java</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><p>链表和数组可以按照人们意愿排列元素的次序，但是，如果想要查看某个指定的元素，却又忘记了它的位置，就需要访问所有的元素，直到找到为止。如果集合中元素很多，将会消耗很多时间。有一种数据结构可以快速查找所需要查找的对象，这个就是哈希表（hash table）.</p>
<p>HashMap是基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
<a id="more"></a>
<h3 id="1-HashMap的数据结构："><a href="#1-HashMap的数据结构：" class="headerlink" title="1. HashMap的数据结构："></a>1. HashMap的数据结构：</h3><p>HashMap使用数组和链表来共同组成的。可以看出底层是一个数组，而数组的每个元素都是一个链表头。</p>
<p><img src="/images/hashMapSourceAnalysis/hs.20150729.01.jpg" alt="enter image description here"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">final</span> K key;</div><div class="line">        V value;</div><div class="line">        Entry&lt;K,V&gt; next;</div><div class="line">        <span class="keyword">int</span> hash;</div><div class="line">        ...</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>Entry是HashMap中的一个内部静态类，包级私有，实现了Map中的接口Entey<k,v>。可以看出来它内部含有一个指向下一个元素的指针。</k,v></p>
<h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2.构造函数"></a>2.构造函数</h3><p>HashMap的构造函数有四个：</p>
<ol>
<li>HashMap() — 构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。 </li>
<li>HashMap(int initialCapacity)  — 构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。 </li>
<li>HashMap(int initialCapacity, float loadFactor) — 构造一个带指定初始容量和加载因子的空 HashMap。 </li>
<li>HashMap(Map&lt;? extends K,? extends V&gt; m) — 构造一个映射关系与指定 Map 相同的新 HashMap</li>
</ol>
<p>实际上就两种，一个是指定初始容量和加载因子，一个是用一个给定的映射关系生成一个新的HashMap。说一下第一种。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    * Constructs an empty &lt;tt&gt;HashMap &lt;/tt&gt; with the specified initial</span></div><div class="line"><span class="comment">    * capacity and load factor.</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span>  loadFactor      the load factor</span></div><div class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></div><div class="line"><span class="comment">    *         or the load factor is nonpositive</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">( <span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException( <span class="string">"Illegal initial capacity: "</span> +</div><div class="line">                                              initialCapacity);</div><div class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">           initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float. isNaN(loadFactor))</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException( <span class="string">"Illegal load factor: "</span> +</div><div class="line">                                              loadFactor);</div><div class="line"></div><div class="line">       <span class="comment">// Find a power of 2 &gt;= initialCapacity</span></div><div class="line">       <span class="keyword">int</span> capacity = <span class="number">1</span>;</div><div class="line">       <span class="keyword">while</span> (capacity &lt; initialCapacity)</div><div class="line">           capacity &lt;&lt;= <span class="number">1</span>;</div><div class="line"></div><div class="line">       <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">       threshold = (<span class="keyword">int</span>)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</div><div class="line">       table = <span class="keyword">new</span> Entry[capacity];</div><div class="line">       useAltHashing = sun.misc.VM. isBooted() &amp;&amp;</div><div class="line">               (capacity &gt;= Holder. ALTERNATIVE_HASHING_THRESHOLD);</div><div class="line">       init();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>参数很简单，初始容量，和加载因子。初始容量定义了初识数组的大小，加载因子和初始容量的乘积确定了一个阈值。阈值最大是(1&lt;&lt;30) + 1。初始容量一定是2的N次方，而且刚刚比要设置的值大。默认初始容量是16，默认加载因子是0.75。当表中的元素数量大于等于阈值时，数组的容量会翻倍，并重新插入元素到新的数组中，所以HashMap不保证顺序恒久不变。</p>
<p>当输入的加载因子小于零或者不是浮点数时会抛出异常（IllegalArgumentException）。</p>
<h3 id="3-put操作"><a href="#3-put操作" class="headerlink" title="3.put操作"></a>3.put操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    * Associates the specified value with the specified key in this map.</span></div><div class="line"><span class="comment">    * If the map previously contained a mapping for the key, the old</span></div><div class="line"><span class="comment">    * value is replaced.</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> value value to be associated with the specified key</span></div><div class="line"><span class="comment">    * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key &lt;/tt&gt;, or</span></div><div class="line"><span class="comment">    *         &lt;tt&gt;null &lt;/tt&gt; if there was no mapping for &lt;tt&gt; key&lt;/tt&gt; .</span></div><div class="line"><span class="comment">    *         (A &lt;tt&gt;null &lt;/tt&gt; return can also indicate that the map</span></div><div class="line"><span class="comment">    *         previously associated &lt;tt&gt;null &lt;/tt&gt; with &lt;tt&gt; key&lt;/tt&gt; .)</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">           <span class="keyword">return</span> putForNullKey(value);</div><div class="line">       <span class="keyword">int</span> hash = hash(key);</div><div class="line">       <span class="keyword">int</span> i = indexFor(hash, table .length );</div><div class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e. next) &#123;</div><div class="line">           Object k;</div><div class="line">           <span class="keyword">if</span> (e. hash == hash &amp;&amp; ((k = e. key) == key || key.equals(k))) &#123;</div><div class="line">               V oldValue = e. value;</div><div class="line">               e. value = value;</div><div class="line">               e.recordAccess( <span class="keyword">this</span>);</div><div class="line">               <span class="keyword">return</span> oldValue;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       modCount++;</div><div class="line">       addEntry(hash, key, value, i);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>由于HashMap只是key值为null，所以首先要判断key值是不是为null，是则进行特殊处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    * Offloaded version of put for null keys</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</div><div class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e. next) &#123;</div><div class="line">           <span class="keyword">if</span> (e. key == <span class="keyword">null</span>) &#123;</div><div class="line">               V oldValue = e. value;</div><div class="line">               e. value = value;</div><div class="line">               e.recordAccess( <span class="keyword">this</span>);</div><div class="line">               <span class="keyword">return</span> oldValue;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       modCount++;</div><div class="line">       addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>可以看出key值为null则会插入到数组的第一个位置。如果第一个位置存在，则替代，不存在则添加一个新的。稍后会看到addEntry函数。</p>
<p><strong> PS：考虑一个问题，key值为null会插入到table[0]，那为什么还要遍历整个链表呢？</strong></p>
<p>回到put函数中。在判断key不为null后，会求key的hash值，并通过indexFor函数找出这个key应该存在table中的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    * Returns index for hash code h.</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span> <span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>indexFor函数很简短，但是却实现的很巧妙。一般来说我们把一个数映射到一个固定的长度会用取余（%）运算，也就是h % length，但里巧妙地运用了table.length的特性。还记得前面说了数组的容量都是很特殊的数，是2的N次方。用二进制表示也就是一个1后面N个0，（length-1）就是N个1了。这里直接用与运算，运算速度快，效率高。但是这是是利用了length的特殊性，如果length不是2的N次方的话可能会增加冲突。</p>
<p>前面的问题在这里就有答案了。因为indexFor函数返回值的范围是0到（length-1），所以可能会有key值不是null的Entry存到table[0]中，所以前面还是需要遍历链表的。</p>
<p>得到key值对应在table中的位置，就可以对链表进行遍历，如果存在该key则，替换value，并把旧的value返回，modCount++代表操作数加1。这个属性用于Fail-Fast机制，后面讲到。如果遍历链表后发现key不存在，则要插入一个新的Entry到链表中。这时就会调用addEntry函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Adds a new entry with the specified key, value and hash code to</span></div><div class="line"><span class="comment"> * the specified bucket.  It is the responsibility of this</span></div><div class="line"><span class="comment"> * method to resize the table if appropriate.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Subclass overrides this to alter the behavior of put method.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span> <span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; ( <span class="keyword">null</span> != table[bucketIndex])) &#123;</div><div class="line">        resize(<span class="number">2</span> * table. length);</div><div class="line">        hash = ( <span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</div><div class="line">        bucketIndex = indexFor(hash, table.length);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    createEntry(hash, key, value, bucketIndex);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数有四个参数，第一个是key的hash值，第二个第三个分别是key和value，最后一个是这个key在table中的位置，也就是indexFor(hash(key), table.length-1)。首先会判断size（当前表中的元素个数）是不是大于或等于阈值。并且判断数组这个位置是不是空。如果条件满足则要resize(2 * table. length)，等下我们来看这个操作。超过阈值要resize是为了减少冲突，提高访问效率。判断当前位置不是空时才resize是为了尽可能减少resize次数，因为这个位置是空，放一个元素在这也没有冲突，所以不影响效率，就先不进行resize了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Rehashes the contents of this map into a new array with a</span></div><div class="line"><span class="comment"> * larger capacity.  This method is called automatically when the</span></div><div class="line"><span class="comment"> * number of keys in this map reaches its threshold.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * If current capacity is MAXIMUM_CAPACITY, this method does not</span></div><div class="line"><span class="comment"> * resize the map, but sets threshold to Integer.MAX_VALUE.</span></div><div class="line"><span class="comment"> * This has the effect of preventing future calls.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> newCapacity the new capacity, MUST be a power of two;</span></div><div class="line"><span class="comment"> *        must be greater than current capacity unless current</span></div><div class="line"><span class="comment"> *        capacity is MAXIMUM_CAPACITY (in which case value</span></div><div class="line"><span class="comment"> *        is irrelevant).</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</div><div class="line">    Entry[] oldTable = table;</div><div class="line">    <span class="keyword">int</span> oldCapacity = oldTable. length;</div><div class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</div><div class="line">        threshold = Integer. MAX_VALUE;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</div><div class="line">    <span class="keyword">boolean</span> oldAltHashing = useAltHashing;</div><div class="line">    useAltHashing |= sun.misc.VM. isBooted() &amp;&amp;</div><div class="line">            (newCapacity &gt;= Holder. ALTERNATIVE_HASHING_THRESHOLD);</div><div class="line">    <span class="keyword">boolean</span> rehash = oldAltHashing ^ useAltHashing;</div><div class="line">    transfer(newTable, rehash);</div><div class="line">    table = newTable;</div><div class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor , MAXIMUM_CAPACITY + <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>resize操作先要判断当前table的长度是不是已经等于最大容量（1&lt;&lt;30）了，如果是则把阈值调到整数的最大值（(1&lt;&lt;31) - 1），就没有再拓展table的必要了。如果没有到达最大容量，就要生成一个新的空数组，长度是原来的两倍。这时候可能要问了，如果oldTable. length不等于MAXIMUM_CAPACITY，但是（2 * oldTable. length）也就是newCapacity大于MAXIMUM_CAPACITY怎么办？这个是不可能的，因为数组长度是2的N次方，而MAXIMUM_CAPACITY = 1&lt;&lt;30。<br>生成新的数组后要执行transfer函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Transfers all entries from current table to newTable.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> newCapacity = newTable. length;</div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</div><div class="line">        <span class="keyword">while</span>( <span class="keyword">null</span> != e) &#123;</div><div class="line">            Entry&lt;K,V&gt; next = e. next;</div><div class="line">            <span class="keyword">if</span> ( rehash) &#123;</div><div class="line">                e. hash = <span class="keyword">null</span> == e. key ? <span class="number">0</span> : hash(e. key);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</div><div class="line">            e. next = newTable[i];</div><div class="line">            newTable[i] = e;</div><div class="line">            e = next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数要做的就是把原来table中的值挨个拿出来插到新数组中，由于数组长度发生了改变，所以元素的位置肯定发生变化，所以HashMap不能保证该顺序恒久不变。回到resize函数，这时新的数组已经生成了，只需要替换原来数组就好了。并且要更新一下阈值。可以看出来resize是个比较消耗资源的函数，所以能减少resize的次数就尽量减少。</p>
<p>回到函数addEntry 中，判断完是不是需要resize后就需要创建一个新的Entry了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Like addEntry except that this version is used when creating entries</span></div><div class="line"><span class="comment"> * as part of Map construction or "pseudo -construction" (cloning,</span></div><div class="line"><span class="comment"> * deserialization).  This version needn't worry about resizing the table.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Subclass overrides this to alter the behavior of HashMap(Map),</span></div><div class="line"><span class="comment"> * clone, and readObject.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">( <span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</div><div class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</div><div class="line">    size++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用createEntry函数，参数跟addEntry一样，第一个是key的hash值，第二个第三个分别是key和value，最后一个是这个key在table中的位置。这里的操作与Entry的构造函数有关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Creates new entry.</span></div><div class="line"><span class="comment"> */</span></div><div class="line">Entry (<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</div><div class="line">    value = v;</div><div class="line">    next = n;</div><div class="line">    key = k;</div><div class="line">    hash = h;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构造函数中传入一个Entry对象，并把它当做这个新生成的Entry的next。所以createEntry函数中的操作相当于把table[bucketIndex]上的链表拿下来，放在新的Entry后面，然后再把新的Entry放到table[bucketIndex]上。</p>
<p><img src="/images/hashMapSourceAnalysis/hs.20150729.02.jpg" alt="enter image description here"></p>
<p>到这里整个put函数算是结束了。如果新插入的K，V则会返回null。</p>
<h3 id="4-get操作"><a href="#4-get操作" class="headerlink" title="4.get操作"></a>4.get操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Returns the value to which the specified key is mapped,</span></div><div class="line"><span class="comment"> * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &lt;p&gt;More formally, if this map contains a mapping from a key</span></div><div class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></div><div class="line"><span class="comment"> * key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></div><div class="line"><span class="comment"> * it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily &lt;/i&gt;</span></div><div class="line"><span class="comment"> * indicate that the map contains no mapping for the key; it's also</span></div><div class="line"><span class="comment"> * possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></div><div class="line"><span class="comment"> * The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></div><div class="line"><span class="comment"> * distinguish these two cases.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@see</span> #put(Object, Object)</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> getForNullKey();</div><div class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也是先判断key是不是null，做特殊处理。直接上代码，不赘述。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Offloaded version of get() to look up null keys.  Null keys map</span></div><div class="line"><span class="comment"> * to index 0.  This null case is split out into separate methods</span></div><div class="line"><span class="comment"> * for the sake of performance in the two most commonly used</span></div><div class="line"><span class="comment"> * operations (get and put), but incorporated with conditionals in</span></div><div class="line"><span class="comment"> * others.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">private</span> V <span class="title">getForNullKey</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e. next) &#123;</div><div class="line">        <span class="keyword">if</span> (e. key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> e. value;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>key不是null则会调用getEntry函数，并返回一个Entry对象，如果不是null，就返回entry的value。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Returns the entry associated with the specified key in the</span></div><div class="line"><span class="comment"> * HashMap.  Returns null if the HashMap contains no mapping</span></div><div class="line"><span class="comment"> * for the key.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[ indexFor(hash, table.length)];</div><div class="line">         e != <span class="keyword">null</span>;</div><div class="line">         e = e. next) &#123;</div><div class="line">        Object k;</div><div class="line">        <span class="keyword">if</span> (e. hash == hash &amp;&amp;</div><div class="line">            ((k = e. key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            <span class="keyword">return</span> e;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>直接求key值hash值，然后求table中的位置，遍历链表。有返回entry对象，没有返回null。</p>
<h3 id="5-Fail-Fast机制"><a href="#5-Fail-Fast机制" class="headerlink" title="5. Fail-Fast机制"></a>5. Fail-Fast机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * The number of times this HashMap has been structurally modified</span></div><div class="line"><span class="comment"> * Structural modifications are those that change the number of mappings in</span></div><div class="line"><span class="comment"> * the HashMap or otherwise modify its internal structure (e.g.,</span></div><div class="line"><span class="comment"> * rehash).  This field is used to make iterators on Collection-views of</span></div><div class="line"><span class="comment"> * the HashMap fail -fast.  (See ConcurrentModificationException).</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</div></pre></td></tr></table></figure>
<p>我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。</p>
<p>这一策略在源码中的实现是通过modCount域，保证线程之间修改的可见性。，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。</p>
<p><strong>注意</strong>，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>《Core JAVA》</li>
<li>《JAVA API》</li>
</ul>
<p>博客知识交流不方便，我搞了个<strong>免费</strong> 的知识星期，大家有兴趣的可加进来大家一起讨论，扫描下面的二维码即可加入：</p>
<p><img src="/images/media/591520762002_.pic.jpg" alt="591520762002_.pi"></p>
</div><iframe src="/donate/?AliPayQR=/img/AliPayQR.png&amp;WeChatQR=/img/WeChatQR.png&amp;GitHub=undefined&amp;BTCQR=undefined&amp;BTCKEY=undefined&amp;PayPal=undefined" style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><script type="text/javascript" src="/js/share.js?v=0.0.2" async></script><a data-url="http://androidperformance.com/2015/08/05/HashMap.html" data-id="cjfhpf3kg003e60zeg1tqhg69" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACKklEQVR42u3aMZakMAwFwL7/pXvTSaD/l2Hfw5SjDhjsItBIlj6feH3/rOSZ9vl8l6WFgYHxWMb3dOVbHh3iHJbv++MDYWBgvIBxFMGS3+eB8uhvzz9HfjYMDAyM5OjJSnbEwMDAuI+RVJf5oTEwMDBWitj8Gm7lPbfX4hgYGA9k5Lfu///3Lf0NDAyMRzFWCtGrUsm8VXB4KgwMjK0ZeYDLr++TpHDWDPiRkmJgYGzKyEvKduPZNdxwUAwDA+NljNnYRBsi23TwR8jGwMDYmrFyWT+LdbNAH70HAwNjU0Y7tpWng7M25OwZDAyMvRnJeNbsuLNSthgCy1+HgYGxBaMNu7Nkbjb4VWe4GBgYmzJWGgNtQZsXvfV1GwYGxqaM2UvvSBxn42KflW+DgYHxcMYKqS1l8x3rYQsMDIyNGCttyPULtctSQwwMjK0ZsyJ2don2iVd+eYeBgbE3oy0gZ83OdnRj1mDAwMDYm7HSHriqlsyL2Dp8Y2BgbMFor/vXL87a90ftBAwMjNcwZmE0H8toG595woqBgfEeRjsEtjJa0V7ADf9vYGBgPJzxLVeexs2OmDQb6mobAwPj4YyVhuKsndC+5+KQjYGB8VhGG2RnBWeS6uXgojGAgYGxEaOoeoPNkuu22dBYMTOCgYHxYkYbjmdFb91GxcDAwChD6qzZmQT3H0UsBgbG1ox2YCIZpEiSvzw1xMDAeDNjZVKjDZ03zoxgYGDsyfgHvjQi4P7bnEMAAAAASUVORK5CYII=" class="article-share-link">分享</a><div class="tags"><a href="/tags/Java/">Java</a><a href="/tags/HashMap/">HashMap</a></div><div class="post-nav"><a href="/2015/08/12/AndroidL-hwui-RenderThread-workflow.html" class="pre">Android5.0中 hwui 中 RenderThread 工作流程</a><a href="/2015/07/20/Android-Performance-Memory-onTrimMemory.html" class="next">Android代码内存优化建议-OnTrimMemory优化</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC8zMjY3NC85MjM1"><script>(function(d, s) {
   var j, e = d.getElementsByTagName(s)[0];
   if (typeof LivereTower === 'function') { return; }
   j = d.createElement(s);
   j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
   j.async = true;
   e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">39</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Github/">Github</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Memory/">Memory</a><span class="category-list-count">13</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Memory/Performance/">Performance</a><span class="category-list-count">10</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Performance/">Performance</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/View/">View</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/性能优化/">性能优化</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/设计/">设计</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/设计/翻译/">翻译</a><span class="category-list-count">2</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">Life</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/2017/">2017</a><span class="category-list-count">1</span></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Tools/" style="font-size: 15px;">Tools</a> <a href="/tags/推荐/" style="font-size: 15px;">推荐</a> <a href="/tags/MAT/" style="font-size: 15px;">MAT</a> <a href="/tags/Performance/" style="font-size: 15px;">Performance</a> <a href="/tags/Memory/" style="font-size: 15px;">Memory</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/启动优化/" style="font-size: 15px;">启动优化</a> <a href="/tags/DelayLoad/" style="font-size: 15px;">DelayLoad</a> <a href="/tags/Peroformance/" style="font-size: 15px;">Peroformance</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Systrace/" style="font-size: 15px;">Systrace</a> <a href="/tags/hwui/" style="font-size: 15px;">hwui</a> <a href="/tags/RenderThread/" style="font-size: 15px;">RenderThread</a> <a href="/tags/Menory/" style="font-size: 15px;">Menory</a> <a href="/tags/Nexus/" style="font-size: 15px;">Nexus</a> <a href="/tags/设计规范/" style="font-size: 15px;">设计规范</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Singleton/" style="font-size: 15px;">Singleton</a> <a href="/tags/HashMap/" style="font-size: 15px;">HashMap</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/04/01/why-60-fps.html">流畅度1 - 为什么是 60 fps ?</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/11/Android_Systrace_0.html">【置顶】Android Performance Tools -- Systrace 系列文章目录</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/06/2017年度最推荐.html">2017年度最推荐</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/19/Android-performance-optimization-skills-and-tools.html">Android 性能优化必知必会</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/23/About-work.html">关于 2017</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/05/android-bottom-bar-2.html">Android Bottom navigation 规范二：样式、行为与规格</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/05/android-bottom-bar-1.html">Android Bottom navigation 规范一：使用方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/31/How-to-calculation-android-app-lunch-time.html">Android 中如何计算 App 的启动时间？</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/29/Android应用启动优化-一种DelayLoad的实现和原理-下篇.html">Android应用启动优化:一种DelayLoad的实现和原理(下篇)</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/11/18/Android-app-lunch-optimize-delay-load.html">Android应用启动优化:一种DelayLoad的实现和原理(上篇)</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.zhihu.com/people/gracker/activities" title="Zhihu" target="_blank">Zhihu</a><ul></ul><a href="https://github.com/Gracker" title="GitHub" target="_blank">GitHub</a><ul></ul><a href="https://source.android.google.cn/devices/tech/" title="Android 核心技术" target="_blank">Android 核心技术</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Android Performance.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.2" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.2" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.2"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.2"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.2"></script></div></body></html>