<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="专注 Android 性能优化"><title>Android5.0中 hwui 中 RenderThread 工作流程 | Android Performance</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.2"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-50993302-2','auto');
ga('require', 'GTM-5T9PB73');
ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android5.0中 hwui 中 RenderThread 工作流程</h1><a id="logo" href="/.">Android Performance</a><p class="description">True mastery of any skill takes a lifetime</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android5.0中 hwui 中 RenderThread 工作流程</h1><div class="post-meta">Aug 12, 2015<span> | </span><span class="category"><a href="/categories/Android/">Android</a><a href="/categories/Android/View/">View</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇文章是自己的一个学习笔记，记录了 Android 5.0 中 hwui 中的 RenderThread 的简单工作流程。由于是学习笔记，所以其中一些细节不会太详细，我只是将大概的流程走一遍，将其工作流标注出来，下次遇到问题的时候就可以知道去哪里查。</p>
<p>下图是我用 Systrace 抓取的一个应用启动的时候 RenderThread 的第一次 Draw 的 Trace 图，从这里面的顺序来看 RenderThread 的流程。熟悉应用启动流程的话应该知道，只有当第一次 DrawFrame 完成之后，整个应用的界面才会显示在手机上，在这之前，用户看到的是应用的 StartingWindow 的界面。</p>
<a id="more"></a>
<p><img src="/images/hwui/renderthread/1.png" alt="RenderThread Draw first frame"></p>
<h2 id="从Java层说起"><a href="#从Java层说起" class="headerlink" title="从Java层说起"></a>从Java层说起</h2><p>应用程序的每一帧是从接收到 VSYNC 信号开始进行计算和绘制的,这要从 Choreographer 这个类说起了，不过由于篇幅原因，我们直接看一帧的绘制调用关系链即可：</p>
<p><img src="/images/hwui/renderthread/2.png" alt="绘制关系链"></p>
<p>Choreographer 的 drawFrame 会调用到 ViewRootImpl 的 performTraversals 方法，而 performTraversals 方法最终会调用到performDraw() 方法， performDraw 又会调用到 draw(boolean fullRedrawNeeded) 方法，这个 draw 方法是 ViewRootImpl 的私有方法，和我们熟知的那个draw并不是同一个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">            <span class="keyword">if</span> (mAttachInfo.mHardwareRenderer != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mHardwareRenderer.isEnabled()) &#123;</div><div class="line">                mIsAnimating = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">boolean</span> invalidateRoot = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">if</span> (mHardwareYOffset != yOffset || mHardwareXOffset != xOffset) &#123;</div><div class="line">                    mHardwareYOffset = yOffset;</div><div class="line">                    mHardwareXOffset = xOffset;</div><div class="line">                    mAttachInfo.mHardwareRenderer.invalidateRoot();</div><div class="line">                &#125;</div><div class="line">                mResizeAlpha = resizeAlpha;</div><div class="line"></div><div class="line">                dirty.setEmpty();</div><div class="line"></div><div class="line">                mBlockResizeBuffer = <span class="keyword">false</span>;</div><div class="line">                mAttachInfo.mHardwareRenderer.draw(mView, mAttachInfo, <span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果是走硬件绘制路线的话，则会走这一条先，之后就会调用 mHardwareRenderer 的 draw 方法,这里的 mHardwareRenderer 指的是 ThreadedRenderer ，其 Draw 函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(View view, AttachInfo attachInfo, HardwareDrawCallbacks callbacks)</span> </span>&#123;</div><div class="line">    attachInfo.mIgnoreDirtyState = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">long</span> frameTimeNanos = mChoreographer.getFrameTimeNanos();</div><div class="line">    attachInfo.mDrawingTime = frameTimeNanos / TimeUtils.NANOS_PER_MS;</div><div class="line"></div><div class="line">    <span class="keyword">long</span> recordDuration = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (mProfilingEnabled) &#123;</div><div class="line">        recordDuration = System.nanoTime();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    updateRootDisplayList(view, callbacks);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mProfilingEnabled) &#123;</div><div class="line">        recordDuration = System.nanoTime() - recordDuration;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    attachInfo.mIgnoreDirtyState = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// register animating rendernodes which started animating prior to renderer</span></div><div class="line">    <span class="comment">// creation, which is typical for animators started prior to first draw</span></div><div class="line">    <span class="keyword">if</span> (attachInfo.mPendingAnimatingRenderNodes != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = attachInfo.mPendingAnimatingRenderNodes.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            registerAnimatingRenderNode(</div><div class="line">                    attachInfo.mPendingAnimatingRenderNodes.get(i));</div><div class="line">        &#125;</div><div class="line">        attachInfo.mPendingAnimatingRenderNodes.clear();</div><div class="line">        <span class="comment">// We don't need this anymore as subsequent calls to</span></div><div class="line">        <span class="comment">// ViewRootImpl#attachRenderNodeAnimator will go directly to us.</span></div><div class="line">        attachInfo.mPendingAnimatingRenderNodes = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> syncResult = nSyncAndDrawFrame(mNativeProxy, frameTimeNanos,</div><div class="line">            recordDuration, view.getResources().getDisplayMetrics().density);</div><div class="line">    <span class="keyword">if</span> ((syncResult &amp; SYNC_INVALIDATE_REQUIRED) != <span class="number">0</span>) &#123;</div><div class="line">        attachInfo.mViewRootImpl.invalidate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数里面的 updateRootDisplayList(view, callbacks) ;即 getDisplayList 操作。接下来就是比较重要的一个操作：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int syncResult = nSyncAndDrawFrame(<span class="name">mNativeProxy</span>, frameTimeNanos,</div><div class="line">        recordDuration, view.getResources().getDisplayMetrics().density)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>可以看出这是一个阻塞操作，等Native层完成后，拿到返回值后才会进行下一步的操作。</p>
<h2 id="Native层"><a href="#Native层" class="headerlink" title="Native层"></a>Native层</h2><p>其Native代码在android_view_ThreadedRenderer.cpp中，对应的实现代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">android_view_ThreadedRenderer_syncAndDrawFrame</span><span class="params">(JNIEnv* env, jobject clazz,</span></span></div><div class="line"><span class="function"><span class="params">        jlong proxyPtr, jlong frameTimeNanos, jlong recordDuration, jfloat density)</span> </span>&#123;</div><div class="line">    RenderProxy* proxy = <span class="keyword">reinterpret_cast</span>&lt;RenderProxy*&gt;(proxyPtr);</div><div class="line">    <span class="keyword">return</span> proxy-&gt;syncAndDrawFrame(frameTimeNanos, recordDuration, density);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RenderProxy的路径位于frameworks/base/libs/hwui/renderthread/RenderProxy.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> RenderProxy::syncAndDrawFrame(<span class="keyword">nsecs_t</span> frameTimeNanos, <span class="keyword">nsecs_t</span> recordDurationNanos,</div><div class="line">        <span class="keyword">float</span> density) &#123;</div><div class="line">    mDrawFrameTask.setDensity(density);</div><div class="line">    <span class="keyword">return</span> mDrawFrameTask.drawFrame(frameTimeNanos, recordDurationNanos);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 mDrawFrameTask 是一个 DrawFrameTask 对象，其路径位于frameworks/base/libs/hwui/renderthread/DrawFrameTask.cpp，其中drawFrame代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> DrawFrameTask::drawFrame(<span class="keyword">nsecs_t</span> frameTimeNanos, <span class="keyword">nsecs_t</span> recordDurationNanos) &#123;</div><div class="line">    mSyncResult = kSync_OK;</div><div class="line">    mFrameTimeNanos = frameTimeNanos;</div><div class="line">    mRecordDurationNanos = recordDurationNanos;</div><div class="line">    postAndWait();</div><div class="line"></div><div class="line">    <span class="comment">// Reset the single-frame data</span></div><div class="line">    mFrameTimeNanos = <span class="number">0</span>;</div><div class="line">    mRecordDurationNanos = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> mSyncResult;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 postAndWait() 的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> DrawFrameTask::postAndWait() &#123;</div><div class="line">    AutoMutex _lock(mLock);</div><div class="line">    mRenderThread-&gt;<span class="built_in">queue</span>(<span class="keyword">this</span>);</div><div class="line">    mSignal.wait(mLock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就是将一个 DrawFrameTask 放入到了 mRenderThread 中,其中 queue 方法实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> RenderThread::<span class="built_in">queue</span>(RenderTask* task) &#123;</div><div class="line">    AutoMutex _lock(mLock);</div><div class="line">    mQueue.<span class="built_in">queue</span>(task);</div><div class="line">    <span class="keyword">if</span> (mNextWakeup &amp;&amp; task-&gt;mRunAt &lt; mNextWakeup) &#123;</div><div class="line">        mNextWakeup = <span class="number">0</span>;</div><div class="line">        mLooper-&gt;wake();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 mQueue 是一个 TaskQueue 对象，其</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> TaskQueue::queue(RenderTask* <span class="keyword">task</span>) &#123;</div><div class="line">    <span class="comment">// Since the RenderTask itself forms the linked list it is not allowed</span></div><div class="line">    <span class="comment">// to have the same task queued twice</span></div><div class="line">    LOG_ALWAYS_FATAL_IF(<span class="keyword">task</span>-&gt;mNext || mTail == <span class="keyword">task</span>, <span class="string">"Task is already in the queue!"</span>);</div><div class="line">    <span class="keyword">if</span> (mTail) &#123;</div><div class="line">        <span class="comment">// Fast path if we can just append</span></div><div class="line">        <span class="keyword">if</span> (mTail-&gt;mRunAt &lt;= <span class="keyword">task</span>-&gt;mRunAt) &#123;</div><div class="line">            mTail-&gt;mNext = <span class="keyword">task</span>;</div><div class="line">            mTail = <span class="keyword">task</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// Need to find the proper insertion point</span></div><div class="line">            RenderTask* <span class="keyword">previous</span> = <span class="number">0</span>;</div><div class="line">            RenderTask* <span class="keyword">next</span> = mHead;</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">next</span> &amp;&amp; <span class="keyword">next</span>-&gt;mRunAt &lt;= <span class="keyword">task</span>-&gt;mRunAt) &#123;</div><div class="line">                <span class="keyword">previous</span> = <span class="keyword">next</span>;</div><div class="line">                <span class="keyword">next</span> = <span class="keyword">next</span>-&gt;mNext;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (!<span class="keyword">previous</span>) &#123;</div><div class="line">                <span class="keyword">task</span>-&gt;mNext = mHead;</div><div class="line">                mHead = <span class="keyword">task</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">previous</span>-&gt;mNext = <span class="keyword">task</span>;</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">next</span>) &#123;</div><div class="line">                    <span class="keyword">task</span>-&gt;mNext = <span class="keyword">next</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    mTail = <span class="keyword">task</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        mTail = mHead = <span class="keyword">task</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着看 RenderThread 之前的 queue 方法，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Looper::wake() &#123;</div><div class="line">    <span class="keyword">ssize_t</span> nWrite;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        nWrite = write(mWakeWritePipeFd, <span class="string">"W"</span>, <span class="number">1</span>);</div><div class="line">    &#125; <span class="keyword">while</span> (nWrite == <span class="number">-1</span> &amp;&amp; errno == EINTR);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (nWrite != <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (errno != EAGAIN) &#123;</div><div class="line">            ALOGW(<span class="string">"Could not write wake signal, errno=%d"</span>, errno);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>wake 函数则更为简单，仅仅向管道的写端写入一个字符“W”，这样管道的读端就会因为有数据可读而从等待状态中醒来。</p>
<h2 id="HWUI-RenderThread"><a href="#HWUI-RenderThread" class="headerlink" title="HWUI-RenderThread"></a>HWUI-RenderThread</h2><p>接下来会到哪里去，我们首先要熟悉一下RenderThread，RenderThread是继承自Thread的，这个Thread是utils/Thread.h,RenderThread的初始化函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">RenderThread::RenderThread() : Thread(<span class="literal">true</span>), Singleton&lt;RenderThread&gt;()</div><div class="line">        , mNextWakeup(LLONG_MAX)</div><div class="line">        , mDisplayEventReceiver(<span class="number">0</span>)</div><div class="line">        , mVsyncRequested(<span class="literal">false</span>)</div><div class="line">        , mFrameCallbackTaskPending(<span class="literal">false</span>)</div><div class="line">        , mFrameCallbackTask(<span class="number">0</span>)</div><div class="line">        , mRenderState(<span class="literal">NULL</span>)</div><div class="line">        , mEglManager(<span class="literal">NULL</span>) &#123;</div><div class="line">    mFrameCallbackTask = <span class="keyword">new</span> DispatchFrameCallbacks(<span class="keyword">this</span>);</div><div class="line">    mLooper = <span class="keyword">new</span> Looper(<span class="literal">false</span>);</div><div class="line">    run(<span class="string">"RenderThread"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其 run 方法在 Thread 中有说明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Start the thread in threadLoop() which needs to be implemented.</span></div><div class="line"><span class="function"><span class="keyword">virtual</span> status_t    <span class="title">run</span><span class="params">(    <span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="number">0</span>,</span></span></div><div class="line"><span class="function"><span class="params">                            <span class="keyword">int32_t</span> priority = PRIORITY_DEFAULT,</span></span></div><div class="line"><span class="function"><span class="params">                            <span class="keyword">size_t</span> <span class="built_in">stack</span> = <span class="number">0</span>)</span></span>;</div></pre></td></tr></table></figure>
<p>即启动 threadLoop 函数，我们来看 RenderThread 的 threadLoop 函数，这个函数比较重要：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> RenderThread::threadLoop() &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(HAVE_PTHREADS)</span></div><div class="line">    setpriority(PRIO_PROCESS, <span class="number">0</span>, PRIORITY_DISPLAY);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    initThreadLocals();</div><div class="line"></div><div class="line">    <span class="keyword">int</span> timeoutMillis = <span class="number">-1</span>;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">int</span> result = mLooper-&gt;pollOnce(timeoutMillis);</div><div class="line">        LOG_ALWAYS_FATAL_IF(result == Looper::POLL_ERROR,</div><div class="line">                <span class="string">"RenderThread Looper POLL_ERROR!"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">nsecs_t</span> nextWakeup;</div><div class="line">        <span class="comment">// Process our queue, if we have anything</span></div><div class="line">        <span class="keyword">while</span> (RenderTask* task = nextTask(&amp;nextWakeup)) &#123;</div><div class="line">            task-&gt;run();</div><div class="line">            <span class="comment">// task may have deleted itself, do not reference it again</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (nextWakeup == LLONG_MAX) &#123;</div><div class="line">            timeoutMillis = <span class="number">-1</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">nsecs_t</span> timeoutNanos = nextWakeup - systemTime(SYSTEM_TIME_MONOTONIC);</div><div class="line">            timeoutMillis = nanoseconds_to_milliseconds(timeoutNanos);</div><div class="line">            <span class="keyword">if</span> (timeoutMillis &lt; <span class="number">0</span>) &#123;</div><div class="line">                timeoutMillis = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (mPendingRegistrationFrameCallbacks.size() &amp;&amp; !mFrameCallbackTaskPending) &#123;</div><div class="line">            drainDisplayEventQueue(<span class="literal">true</span>);</div><div class="line">            mFrameCallbacks.insert(</div><div class="line">                    mPendingRegistrationFrameCallbacks.begin(), mPendingRegistrationFrameCallbacks.end());</div><div class="line">            mPendingRegistrationFrameCallbacks.clear();</div><div class="line">            requestVsync();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，一个 for 循环是一个无限循环，而其中 pollOnce 是一个阻塞函数，直到我们上面调用了 mLooper-&gt;wake() 之后，会继续往下走，走到 while 循环中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (RenderTask* task = nextTask(&amp;nextWakeup)) &#123;</div><div class="line">            task-&gt;run();</div><div class="line">            <span class="comment">// task may have deleted itself, do not reference it again</span></div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>会将 RenderTask 取出来执行其 run 方法，经过前面的流程我们知道这个 RenderTask 是一个 DrawFrameTask ，其run方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> DrawFrameTask::run() &#123;</div><div class="line">    ATRACE_NAME(<span class="string">"DrawFrame"</span>);</div><div class="line"></div><div class="line">    mContext-&gt;profiler().setDensity(mDensity);</div><div class="line">    mContext-&gt;profiler().startFrame(mRecordDurationNanos);</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> canUnblockUiThread;</div><div class="line">    <span class="keyword">bool</span> canDrawThisFrame;</div><div class="line">    &#123;</div><div class="line">        TreeInfo info(TreeInfo::MODE_FULL, mRenderThread-&gt;renderState());</div><div class="line">        canUnblockUiThread = syncFrameState(info);</div><div class="line">        canDrawThisFrame = info.out.canDrawThisFrame;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Grab a copy of everything we need</span></div><div class="line">    CanvasContext* context = mContext;</div><div class="line"></div><div class="line">    <span class="comment">// From this point on anything in "this" is *UNSAFE TO ACCESS*</span></div><div class="line">    <span class="keyword">if</span> (canUnblockUiThread) &#123;</div><div class="line">        unblockUiThread();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (CC_LIKELY(canDrawThisFrame)) &#123;</div><div class="line">        context-&gt;draw();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!canUnblockUiThread) &#123;</div><div class="line">        unblockUiThread();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="RenderThread-DrawFrame"><a href="#RenderThread-DrawFrame" class="headerlink" title="RenderThread.DrawFrame"></a>RenderThread.DrawFrame</h2><p>上面说到了 DrawFrameTask 的 run 方法，这里 run 方法中的执行的方法即我们在最前面那张图中所示的部分（即文章最前面那张图），下面的流程就是那张图中的函数调用，我们结合代码和图，一部分一部分来走整个 DrawFrame 的流程：</p>
<h3 id="1-syncFrameState"><a href="#1-syncFrameState" class="headerlink" title="1. syncFrameState"></a>1. syncFrameState</h3><p>第一个比较重要的函数是 syncFrameState ，从函数名就可以知道， syncFrameState 的作用就是同步 frame 信息，将 Java 层维护的 frame 信息同步到 RenderThread中。</p>
<blockquote>
<p>Main Thread 和Render Thread 都各自维护了一份应用程序窗口视图信息。各自维护了一份应用程序窗口视图信息的目的，就是为了可以互不干扰，进而实现最大程度的并行。其中，Render Thread维护的应用程序窗口视图信息是来自于 Main Thread 的。因此，当Main Thread 维护的应用程序窗口信息发生了变化时，就需要同步到 Render Thread 去。</p>
</blockquote>
<p>所以查看代码就可以知道有两个 RenderNode，一个在 hwui 中，一个在 View 中。简单来说，同步信息就是将 Java 层的 RenderNode 中的信息同步到 hwui 中的 RenderNode 中。 注意syncFrameState的返回值赋给了 canUnblockUiThread ，从名字可以看出这个 canUnblockUiThread 的作用是判断是否唤醒 Main Thread ，也就是说如果返回为 true 的话，会提前唤醒主线程来执行其他的事情，而不用等到 draw 完成后再去唤醒 Main Thread。 这也是 Android 5.0 和 Android 4.x 最大的区别了。</p>
<p><img src="/images/hwui/renderthread/3.png" alt="syncFrameState"></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">bool</span> DrawFrameTask::syncFrameState(TreeInfo&amp; info) &#123;</div><div class="line">    mRenderThread-&gt;timeLord().vsyncReceived(mFrameTimeNanos);</div><div class="line">    mContext-&gt;makeCurrent();</div><div class="line">    Caches::getInstance().textureCache.resetMarkInUse();</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; mLayers.size(); i++) &#123;</div><div class="line">        mContext-&gt;processLayerUpdate(mLayers[i].get());</div><div class="line">    &#125;</div><div class="line">    mLayers.clear();</div><div class="line">    mContext-&gt;prepareTree(info);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (info.out.hasAnimations) &#123;</div><div class="line">        <span class="keyword">if</span> (info.out.requiresUiRedraw) &#123;</div><div class="line">            mSyncResult |= kSync_UIRedrawRequired;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// If prepareTextures is false, we ran out of texture cache space</span></div><div class="line">    <span class="keyword">return</span> info.prepareTextures;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先是makeCurrent，这里的mContext是一个CanvasContext对象，其makeCurrent实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> CanvasContext::makeCurrent() &#123;</div><div class="line">    <span class="comment">// In the meantime this matches the behavior of GLRenderer, so it is not a regression</span></div><div class="line">    mHaveNewSurface |= mEglManager.makeCurrent(mEglSurface);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>mEglManager是一个EglManager对象，其实现为：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">bool EglManager::makeCurrent(EGLSurface <span class="built_in">surface</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (isCurrent(<span class="built_in">surface</span>)) <span class="built_in">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">surface</span> == EGL_NO_SURFACE) &#123;</div><div class="line">        // If we are setting EGL_NO_SURFACE we don't care about any of the <span class="built_in">potential</span></div><div class="line">        // <span class="built_in">return</span> <span class="built_in">errors</span>, which would only happen <span class="keyword">if</span> mEglDisplay had already been</div><div class="line">        // destroyed <span class="keyword">in</span> which case the current <span class="built_in">context</span> <span class="built_in">is</span> already NO_CONTEXT</div><div class="line">        TIME_LOG(<span class="string">"eglMakeCurrent"</span>, eglMakeCurrent(mEglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        EGLBoolean success;</div><div class="line">        TIME_LOG(<span class="string">"eglMakeCurrent"</span>, success = eglMakeCurrent(mEglDisplay, <span class="built_in">surface</span>, <span class="built_in">surface</span>, mEglContext));</div><div class="line">        <span class="keyword">if</span> (!success) &#123;</div><div class="line">            LOG_ALWAYS_FATAL(<span class="string">"Failed to make current on surface %p, error=%s"</span>,</div><div class="line">                (void*)<span class="built_in">surface</span>, egl_error_str());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    mCurrentSurface = <span class="built_in">surface</span>;</div><div class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里会判断mCurrentSurface == surface，如果成立，则不用再初始化操作，如果是另外一个surface。，则会执行eglMakeCurrent，来重新创建上下文。</p>
<p>makeCurrent之后，会调用mContext-&gt;prepareTree(info)，其实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> CanvasContext::prepareTree(TreeInfo&amp; info) &#123;</div><div class="line">    mRenderThread.removeFrameCallback(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    info.damageAccumulator = &amp;mDamageAccumulator;</div><div class="line">    info.renderer = mCanvas;</div><div class="line">    <span class="keyword">if</span> (mPrefetechedLayers.size() &amp;&amp; info.mode == TreeInfo::MODE_FULL) &#123;</div><div class="line">        info.canvasContext = <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    mAnimationContext-&gt;startFrame(info.mode);</div><div class="line">    mRootRenderNode-&gt;prepareTree(info);</div><div class="line">    mAnimationContext-&gt;runRemainingAnimations(info);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (info.canvasContext) &#123;</div><div class="line">        freePrefetechedLayers();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> runningBehind = <span class="number">0</span>;</div><div class="line">    <span class="comment">// <span class="doctag">TODO:</span> This query is moderately expensive, investigate adding some sort</span></div><div class="line">    <span class="comment">// of fast-path based off when we last called eglSwapBuffers() as well as</span></div><div class="line">    <span class="comment">// last vsync time. Or something.</span></div><div class="line">    TIME_LOG(<span class="string">"nativeWindowQuery"</span>, mNativeWindow-&gt;query(mNativeWindow.get(),</div><div class="line">            NATIVE_WINDOW_CONSUMER_RUNNING_BEHIND, &amp;runningBehind));</div><div class="line">    info.out.canDrawThisFrame = !runningBehind;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (info.out.hasAnimations || !info.out.canDrawThisFrame) &#123;</div><div class="line">        <span class="keyword">if</span> (!info.out.requiresUiRedraw) &#123;</div><div class="line">            <span class="comment">// If animationsNeedsRedraw is set don't bother posting for an RT anim</span></div><div class="line">            <span class="comment">// as we will just end up fighting the UI thread.</span></div><div class="line">            mRenderThread.postFrameCallback(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 mRootRenderNode-&gt;prepareTree(info) 又是最重要的。回到Java层，我们知道 ThreadedRenderer 在初始化时，初始化了一个指针</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> rootNodePtr = nCreateRootRenderNode();</div></pre></td></tr></table></figure>
<p>这个RootRenderNode也就是一个根Node，</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">mRootNode</span> = RenderNode.adopt(rootNodePtr)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>然后会创建一个 mNativeProxy 指针，在 Native 层初始化一个 RenderProxy 对象，将 rootNodePtr 传给 RenderProxy 对象，这样在 RenderProxy 我们就可以得到这个对象的指针了。其中 CanvasContext 也是在 RenderProxy 对象初始化的时候被初始化的，初始化的时候将 rootNodePtr 传给了 CanvasContext 对象。</p>
<p>我们之前提到 ThreadedRenderer 的 draw 方法中首先会调用updateRootDisplayList，即我们熟悉的 getDisplayList 。这个方法中，其实也分为两个步骤，第一个步骤是 updateViewTreeDisplayList，第二个步骤是将根 Node 加入到 DrawOp 中：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">canvas</span><span class="selector-class">.insertReorderBarrier</span>();</div><div class="line"><span class="selector-tag">canvas</span><span class="selector-class">.drawRenderNode</span>(<span class="selector-tag">view</span><span class="selector-class">.getDisplayList</span>());</div><div class="line"><span class="selector-tag">canvas</span><span class="selector-class">.insertInorderBarrier</span>();</div></pre></td></tr></table></figure></p>
<p>其最终实现在</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">status_t</span> DisplayListRenderer::drawRenderNode(RenderNode* renderNode, Rect&amp; dirty, <span class="keyword">int32_t</span> flags) &#123;</div><div class="line">    LOG_ALWAYS_FATAL_IF(!renderNode, <span class="string">"missing rendernode"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// dirty is an out parameter and should not be recorded,</span></div><div class="line">    <span class="comment">// it matters only when replaying the display list</span></div><div class="line">    DrawRenderNodeOp* op = <span class="keyword">new</span> (alloc()) DrawRenderNodeOp(renderNode, flags, *currentTransform());</div><div class="line">    addRenderNodeOp(op);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> DrawGlInfo::kStatusDone;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再回到我们之前的 CanvasContext.prepareTree 中提到的 mRootRenderNode-&gt;prepareTree(info)，这时候这里的 mRootRenderNode 就是 CanvasContext 初始化是传进来的。</p>
<p>其实现在 RenderNode.cpp 中：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">void RenderNode::prepareTree(Tree<span class="literal">Inf</span>o&amp; <span class="literal">inf</span>o) &#123;</div><div class="line">    prepareTreeImpl(<span class="literal">inf</span>o);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void RenderNode::prepareTreeImpl(Tree<span class="literal">Inf</span>o&amp; <span class="literal">inf</span>o) &#123;</div><div class="line">    TT_START_MARK(getName());</div><div class="line">    <span class="literal">inf</span>o.damageAccumulator-&gt;pushTransform(this);</div><div class="line"></div><div class="line">    if (<span class="literal">inf</span>o.mode == Tree<span class="literal">Inf</span>o::MODE_FULL) &#123;</div><div class="line">        pushStagingPropertiesChanges(<span class="literal">inf</span>o); //同步当前正在处理的Render <span class="keyword">Node</span><span class="title">的Property</span></div><div class="line">    &#125;</div><div class="line">    uint32_t animatorDirtyMask = <span class="number">0</span>;</div><div class="line">    if (CC_LIKELY(<span class="literal">inf</span>o.runAnimations)) &#123;</div><div class="line">        animatorDirtyMask = mAnimatorManager.animate(<span class="literal">inf</span>o);//执行动画相关的操作</div><div class="line">    &#125;</div><div class="line">    prepareLayer(<span class="literal">inf</span>o, animatorDirtyMask);</div><div class="line">    if (<span class="literal">inf</span>o.mode == Tree<span class="literal">Inf</span>o::MODE_FULL) &#123;</div><div class="line">        pushStagingDisplayListChanges(<span class="literal">inf</span>o);  //同步当前正在处理的Render <span class="keyword">Node</span><span class="title">的Display</span> List</div><div class="line">    &#125;</div><div class="line">    prepareSubTree(<span class="literal">inf</span>o, mDisplayListData); //同步当前正在处理的Render <span class="keyword">Node</span><span class="title">的Display</span> List引用的Bitmap，以及当前正在处理的Render <span class="keyword">Node</span><span class="title">的子Render</span> <span class="keyword">Node</span><span class="title">的Display</span> List等信息</div><div class="line">    pushLayerUpdate(<span class="literal">inf</span>o); //检查当前正在处理的Render <span class="keyword">Node</span><span class="title">是否设置了Layer</span>。如果设置了的话，就对这些Layer进行处理</div><div class="line"></div><div class="line">    <span class="literal">inf</span>o.damageAccumulator-&gt;popTransform();</div><div class="line">    TT_END_MARK();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里所涉及到的进一步的具体操作大家可以自行去看代码。</p>
<h2 id="2-draw"><a href="#2-draw" class="headerlink" title="2. draw"></a>2. draw</h2><p><img src="/images/hwui/renderthread/4.png" alt="Draw"></p>
<p>执行完syncFrameState之后，接下来就是执行draw</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">if</span> <span class="params">(CC_LIKELY(canDrawThisFrame)</span>) &#123;</span></div><div class="line"><span class="function">    <span class="title">context</span>-&gt;</span>draw();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CanvasContext的draw函数是一个核心函数，其位置在 frameworks/base/libs/hwui/OpenGLRenderer.cpp ，其实现如下：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">void CanvasContext::draw() &#123;</div><div class="line">    profiler().markPlaybackStart();</div><div class="line"></div><div class="line">    SkRect dirty;</div><div class="line">    mDamageAccumulator.finish(&amp;dirty);</div><div class="line"></div><div class="line">    ......</div><div class="line"></div><div class="line">    status_t status;</div><div class="line">    <span class="keyword">if</span> (!dirty.isEmpty()) &#123;</div><div class="line">        <span class="function"><span class="title">status</span> = mCanvas-&gt;</span>prepareDirty(dirty.fLeft, dirty.fTop,</div><div class="line">                dirty.fRight, dirty.fBottom, mOpaque);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="function"><span class="title">status</span> = mCanvas-&gt;</span>prepare(mOpaque);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Rect outBounds;</div><div class="line">    <span class="function"><span class="title">status</span> |= mCanvas-&gt;</span>drawRenderNode(mRootRenderNode.get(), outBounds);</div><div class="line"></div><div class="line">    profiler().draw(mCanvas);</div><div class="line"></div><div class="line">    <span class="function"><span class="title">mCanvas</span>-&gt;</span>finish();</div><div class="line"></div><div class="line">    profiler().markPlaybackEnd();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (status &amp; DrawGlInfo::kStatusDrew) &#123;</div><div class="line">        swapBuffers();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    profiler().finishFrame();</div><div class="line"></div><div class="line">    <span class="comment">/// M: enable to get overdraw count</span></div><div class="line">    <span class="keyword">if</span> (CC_UNLIKELY(g_HWUI_debug_overdraw)) &#123;</div><div class="line">        <span class="keyword">if</span> (!mDebugOverdrawLayer) &#123;</div><div class="line">            mDebugOverdrawLayer = LayerRenderer::createRenderLayer(mRenderThread.renderState(),</div><div class="line">                <span class="function"><span class="title">mCanvas</span>-&gt;</span><span class="function"><span class="title">getWidth</span>(), mCanvas-&gt;</span>getHeight());</div><div class="line">        &#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> (mDebugOverdrawLayer-&gt;</span><span class="function"><span class="title">layer</span>.getWidth() != mCanvas-&gt;</span>getWidth() ||</div><div class="line">                   <span class="function"><span class="title">mDebugOverdrawLayer</span>-&gt;</span><span class="function"><span class="title">layer</span>.getHeight() != mCanvas-&gt;</span>getHeight()) &#123;</div><div class="line">            <span class="function"><span class="title">if</span> (!LayerRenderer::resizeLayer(mDebugOverdrawLayer, mCanvas-&gt;</span><span class="function"><span class="title">getWidth</span>(), mCanvas-&gt;</span>getHeight())) &#123;</div><div class="line">                LayerRenderer::destroyLayer(mDebugOverdrawLayer);</div><div class="line">                mDebugOverdrawLayer = NULL;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-1-eglBeginFrame"><a href="#2-1-eglBeginFrame" class="headerlink" title="2.1 eglBeginFrame"></a>2.1 eglBeginFrame</h4><p>首先来看eglBeginFrame的实现</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void EglManager::beginFrame(EGLSurface <span class="built_in">surface</span>, EGLint* <span class="built_in">width</span>, EGLint* <span class="built_in">height</span>) &#123;</div><div class="line">    makeCurrent(<span class="built_in">surface</span>);</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">width</span>) &#123;</div><div class="line">        eglQuerySurface(mEglDisplay, <span class="built_in">surface</span>, EGL_WIDTH, <span class="built_in">width</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="built_in">height</span>) &#123;</div><div class="line">        eglQuerySurface(mEglDisplay, <span class="built_in">surface</span>, EGL_HEIGHT, <span class="built_in">height</span>);</div><div class="line">    &#125;</div><div class="line">    eglBeginFrame(mEglDisplay, <span class="built_in">surface</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>makeCurrent是用来管理上下文，eglBeginFrame主要是校验参数的合法性。</p>
<h4 id="2-2-prepareDirty"><a href="#2-2-prepareDirty" class="headerlink" title="2.2 prepareDirty"></a>2.2 prepareDirty</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">status_t status<span class="comment">;</span></div><div class="line">if (!<span class="keyword">dirty.isEmpty()) </span>&#123;</div><div class="line">    status = mCanvas-&gt;prepareDirty(<span class="keyword">dirty.fLeft, </span><span class="keyword">dirty.fTop,</span></div><div class="line"><span class="keyword"> </span>           <span class="keyword">dirty.fRight, </span><span class="keyword">dirty.fBottom, </span>mOpaque)<span class="comment">;</span></div><div class="line">&#125; else &#123;</div><div class="line">    status = mCanvas-&gt;prepare(mOpaque)<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的mCanvas是一个OpenGLRenderer对象，其prepareDirty实现</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//<span class="doctag">TODO:</span>增加函数功能描述</span></div><div class="line">status_t OpenGLRenderer::prepareDirty(<span class="keyword">float</span> left, <span class="keyword">float</span> top,</div><div class="line">        <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">bool</span> opaque) &#123;</div><div class="line">    setupFrameState(left, top, right, bottom, opaque);</div><div class="line"></div><div class="line">    <span class="comment">// Layer renderers will start the frame immediately</span></div><div class="line">    <span class="comment">// The framebuffer renderer will first defer the display list</span></div><div class="line">    <span class="comment">// for each layer and wait until the first drawing command</span></div><div class="line">    <span class="comment">// to start the frame</span></div><div class="line">    <span class="keyword">if</span> (currentSnapshot()-&gt;fbo == <span class="number">0</span>) &#123;</div><div class="line">        syncState();</div><div class="line">        updateLayers();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> startFrame();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> DrawGlInfo::kStatusDone;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-3-drawRenderNode"><a href="#2-3-drawRenderNode" class="headerlink" title="2.3 drawRenderNode"></a>2.3 drawRenderNode</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Rect outBounds;</div><div class="line">status |<span class="type">= mCanvas</span>-&gt;drawRenderNode(mRootRenderNode.get(), outBounds);</div></pre></td></tr></table></figure>
<p>接下来就是调用OpenGLRenderer的drawRenderNode方法进行绘制</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">status_t OpenGLRenderer::drawRenderNode(RenderNode* renderNode, Rect&amp; dirty, int32_t replayFlags) &#123;</div><div class="line">    status_t status;</div><div class="line">    <span class="comment">// All the usual checks and setup operations (quickReject, setupDraw, etc.)</span></div><div class="line">    <span class="comment">// will be performed by the display list itself</span></div><div class="line">    <span class="keyword">if</span> (renderNode &amp;&amp; renderNode-&gt;isRenderable()) &#123;</div><div class="line">        <span class="comment">// compute 3d ordering</span></div><div class="line">        renderNode-&gt;computeOrdering();</div><div class="line">        <span class="keyword">if</span> (CC_UNLIKELY(mCaches.drawDeferDisabled)) &#123; <span class="comment">//判断是否不重排序</span></div><div class="line">            status = startFrame();</div><div class="line">            ReplayStateStruct replayStruct(*<span class="keyword">this</span>, dirty, replayFlags);</div><div class="line">            renderNode-&gt;replay(replayStruct, <span class="number">0</span>);</div><div class="line">            <span class="keyword">return</span> status | replayStruct.mDrawGlStatus;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 需要重新排序</span></div><div class="line">        bool avoidOverdraw = !mCaches.debugOverdraw &amp;&amp; !mCountOverdraw; <span class="comment">// shh, don't tell devs!</span></div><div class="line">        DeferredDisplayList deferredList(*currentClipRect(), avoidOverdraw);</div><div class="line">        DeferStateStruct deferStruct(deferredList, *<span class="keyword">this</span>, replayFlags);</div><div class="line">        renderNode-&gt;defer(deferStruct, <span class="number">0</span>); <span class="comment">//递归进行重排操作</span></div><div class="line"></div><div class="line">        flushLayers(); <span class="comment">// 首先执行设置了 Layer 的子 Render Node 的绘制命令，以便得到一个对应的FBO</span></div><div class="line">        status = startFrame(); <span class="comment">//执行一些诸如清理颜色绘冲区等基本操作</span></div><div class="line">        status = deferredList.flush(*<span class="keyword">this</span>, dirty) | status;</div><div class="line">        <span class="keyword">return</span> status;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Even if there is no drawing command(Ex: invisible),</span></div><div class="line">    <span class="comment">// it still needs startFrame to clear buffer and start tiling.</span></div><div class="line">    <span class="keyword">return</span> startFrame();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的 renderNode 是一个 Root Render Node，</p>
<p>可以看到，到了这里虽然只是开始，但是其实已经结束了，这个函数里面最重要的几步:</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">renderNode-&gt;defer(deferStruct, <span class="number">0</span>); <span class="comment">//进行重排序</span></div><div class="line"></div><div class="line">flushLayers(); 首先执行设置了 Layer 的子 Render Node 的绘制命令，以便得到一个对应的FBO</div><div class="line"></div><div class="line">status = deferredList.<span class="built_in">flush</span>(*<span class="keyword">this</span>, dirty) | status;   <span class="comment">//对deferredList中的绘制命令进行真正的绘制操作</span></div></pre></td></tr></table></figure>
<p>这几个是渲染部分真正的核心部分，其中的代码细节需要自己去研究。老罗在这部分讲的很细，有空可以去看看他的文章<a href="http://blog.csdn.net/Luoshengyang/article/details/46281499" target="_blank" rel="external"><a href="http://blog.csdn.net/luoshengyang/article/details/46281499" target="_blank" rel="external">Android应用程序UI硬件加速渲染的Display List渲染过程分析</a></a>.</p>
<h4 id="2-4-swapBuffers"><a href="#2-4-swapBuffers" class="headerlink" title="2.4 swapBuffers"></a>2.4 swapBuffers</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="comment">(status &amp; DrawGlInfo::kStatusDrew)</span> &#123;</div><div class="line">    swapBuffers<span class="comment">()</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其核心就是调用EGL的 eglSwapBuffers(mEglDisplay, surface), duration)函数。</p>
<h4 id="2-5-FinishFrame"><a href="#2-5-FinishFrame" class="headerlink" title="2.5  FinishFrame"></a>2.5  FinishFrame</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">profiler</span>()<span class="selector-class">.finishFrame</span>();</div></pre></td></tr></table></figure>
<p>主要是记录时间信息。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>鉴于我比较懒，而且总结能力不如老罗，就直接把他的总结贴过来了。<br>RenderThread的总的流程如下：</p>
<blockquote>
<ol>
<li><p>将Main Thread维护的Display List同步到Render Thread维护的Display List去。这个同步过程由Render Thread执行，但是Main Thread会被阻塞住。</p>
</li>
<li><p>如果能够完全地将Main Thread维护的Display List同步到Render Thread维护的Display List去，那么Main Thread就会被唤醒，此后Main Thread和Render Thread就互不干扰，各自操作各自内部维护的Display List；否则的话，Main Thread就会继续阻塞，直到Render Thread完成应用程序窗口当前帧的渲染为止。</p>
</li>
<li><p>Render Thread在渲染应用程序窗口的Root Render Node的Display List之前，首先将那些设置了Layer的子Render Node的Display List渲染在各自的一个FBO上，接下来再一起将这些FBO以及那些没有设置Layer的子Render Node的Display List一起渲染在Frame Buffer之上，也就是渲染在从Surface Flinger请求回来的一个图形缓冲区上。这个图形缓冲区最终会被提交给Surface Flinger合并以及显示在屏幕上。</p>
</li>
</ol>
<p>第2步能够完全将Main Thread维护的Display List同步到Render Thread维护的Display List去很关键，它使得Main Thread和Render Thread可以并行执行，这意味着Render Thread在渲染应用程序窗口当前帧的Display List的同时，Main Thread可以去准备应用程序窗口下一帧的Display List，这样就使得应用程序窗口的UI更流畅。</p>
</blockquote>
<p>注意最后一段，在 Android 4.x 时代，没有RenderThread的时代，只有 Main Thread ，也就是说 必须要等到 Draw 完成后，才会去准备下一帧的数据，如下图：</p>
<p><img src="/images/hwui/renderthread/5.png" alt="Paste_Image.png"></p>
<p>Android5.0 之后，如老罗所说，有两种情况，</p>
<p><img src="/images/hwui/renderthread/6.png" alt="Main Thread 和 Render Thread"></p>
<p><img src="/images/hwui/renderthread/7.png" alt="Render Thread 提前唤醒了 Main Thread"></p>
<p>可以看到第二张图中，Render Thread 并没有绘制完成，但是由于其提前唤醒了 Main Thread ，所以 Main Thread 在下一个Vsync信号到来的时候，响应了Vsync事件，开始准备下一帧。<br>此时虽然由于第一帧绘制时间过长，导致掉了一帧，但是第二帧没有收到任何影响。</p>
<p>博客知识交流不方便，我搞了个<strong>免费</strong> 的知识星期，大家有兴趣的可加进来大家一起讨论，扫描下面的二维码即可加入：</p>
<p><img src="/images/media/591520762002_.pic.jpg" alt="591520762002_.pi"></p>
</div><iframe src="/donate/?AliPayQR=/img/AliPayQR.png&amp;WeChatQR=/img/WeChatQR.png&amp;GitHub=undefined&amp;BTCQR=undefined&amp;BTCKEY=undefined&amp;PayPal=undefined" style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><script type="text/javascript" src="/js/share.js?v=0.0.2" async></script><a data-url="http://androidperformance.com/2015/08/12/AndroidL-hwui-RenderThread-workflow.html" data-id="cjfhpf3jf001460ze0n5nd5e6" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACsklEQVR42u3aMZIiMRAEwP3/p/ecMzZiD6jqljiMHIuAYVDKkJpqfX3F1/eP6+c7v1+f+vT5Lx6+8PDw8BZDf/7o3++3T3v03RycjxkPDw/vNi//yXYKZpOSjOH5mPHw8PA+n5dg2s2mLa/x8PDwPpk3G267hfy3jQEPDw8v4CVhRBLvJttADn5r1oKHh4fX5ahRF+lzXl/p7+Hh4eGtu+p5XNu2//OCezbOv9/Fw8PDu8DLF9y2bN0EDW3h/uJOPDw8vKO8JHQ41ZpKItd8y4le4+Hh4V3j5QtxXkDPNoY2OH4xlXh4eHjXeLNBz8KLWfGdBxz/+K+Ah4eHd5TXHpxKlvJ84d40t4r78fDw8I7y9o38NmBtn9lO6MMwAg8PD+8or/hCGUDkk7KJkh/eg4eHh3eZNwsFkgFtgokkmy2yFjw8PLw1L/97v2l9zaKK5JDBMJjAw8PDW/A2ra92a8nL4nbLeXgPHh4e3gXe7No3utqCeFOC4+Hh4d3jtZFuGxzkA53hozACDw8Pb82bBayz1tfm0FXbEnt4MgIPDw/vKG9fEM+69nm0UR8Cw8PDw7vA28P2hXJbfM8aeHh4eHhneXmTKV+s21J7T40iCTw8PLxDvHapPVXyPr8zGUMbVeDh4eGd4m0C3M0JhVnsm4cgeHh4eO/nJeFsO4g2ztgU7nh4eHi3efmD2jjgVCBbbAZ4eHh4b+GdbdK3IUL7nGJq8PDw8I7yvssraVblAUf+tFlBj4eHh3eD1y64s8NSeTCxb4wNLzw8PLyS1/7M84V4Vny3bbaieYaHh4d3jZcXvm0E3Bbi+w0MDw8P75N5m9ZXXmTnxwgObwx4eHh4h3hJ9DCLaDd4PDw8vPfz8iBgVna3k5I31V5sJHh4eHgXeO2f/FkbbDOgU/fg4eHhrXl/AHjE5Cmsej3EAAAAAElFTkSuQmCC" class="article-share-link">分享</a><div class="tags"><a href="/tags/Android/">Android</a><a href="/tags/hwui/">hwui</a><a href="/tags/RenderThread/">RenderThread</a><a href="/tags/Menory/">Menory</a></div><div class="post-nav"><a href="/2015/11/18/Android-app-lunch-optimize-delay-load.html" class="pre">Android应用启动优化:一种DelayLoad的实现和原理(上篇)</a><a href="/2015/08/05/HashMap.html" class="next">HashMap源码分析</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC8zMjY3NC85MjM1"><script>(function(d, s) {
   var j, e = d.getElementsByTagName(s)[0];
   if (typeof LivereTower === 'function') { return; }
   j = d.createElement(s);
   j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
   j.async = true;
   e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">39</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Github/">Github</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Memory/">Memory</a><span class="category-list-count">13</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Memory/Performance/">Performance</a><span class="category-list-count">10</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Performance/">Performance</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/View/">View</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/性能优化/">性能优化</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/设计/">设计</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/设计/翻译/">翻译</a><span class="category-list-count">2</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">Life</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/2017/">2017</a><span class="category-list-count">1</span></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Tools/" style="font-size: 15px;">Tools</a> <a href="/tags/推荐/" style="font-size: 15px;">推荐</a> <a href="/tags/MAT/" style="font-size: 15px;">MAT</a> <a href="/tags/Performance/" style="font-size: 15px;">Performance</a> <a href="/tags/Memory/" style="font-size: 15px;">Memory</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/启动优化/" style="font-size: 15px;">启动优化</a> <a href="/tags/DelayLoad/" style="font-size: 15px;">DelayLoad</a> <a href="/tags/Peroformance/" style="font-size: 15px;">Peroformance</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Systrace/" style="font-size: 15px;">Systrace</a> <a href="/tags/hwui/" style="font-size: 15px;">hwui</a> <a href="/tags/RenderThread/" style="font-size: 15px;">RenderThread</a> <a href="/tags/Menory/" style="font-size: 15px;">Menory</a> <a href="/tags/Nexus/" style="font-size: 15px;">Nexus</a> <a href="/tags/设计规范/" style="font-size: 15px;">设计规范</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Singleton/" style="font-size: 15px;">Singleton</a> <a href="/tags/HashMap/" style="font-size: 15px;">HashMap</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/04/01/why-60-fps.html">流畅度1 - 为什么是 60 fps ?</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/11/Android_Systrace_0.html">【置顶】Android Performance Tools -- Systrace 系列文章目录</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/06/2017年度最推荐.html">2017年度最推荐</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/19/Android-performance-optimization-skills-and-tools.html">Android 性能优化必知必会</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/23/About-work.html">关于 2017</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/05/android-bottom-bar-2.html">Android Bottom navigation 规范二：样式、行为与规格</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/05/android-bottom-bar-1.html">Android Bottom navigation 规范一：使用方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/31/How-to-calculation-android-app-lunch-time.html">Android 中如何计算 App 的启动时间？</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/29/Android应用启动优化-一种DelayLoad的实现和原理-下篇.html">Android应用启动优化:一种DelayLoad的实现和原理(下篇)</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/11/18/Android-app-lunch-optimize-delay-load.html">Android应用启动优化:一种DelayLoad的实现和原理(上篇)</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.zhihu.com/people/gracker/activities" title="Zhihu" target="_blank">Zhihu</a><ul></ul><a href="https://github.com/Gracker" title="GitHub" target="_blank">GitHub</a><ul></ul><a href="https://source.android.google.cn/devices/tech/" title="Android 核心技术" target="_blank">Android 核心技术</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Android Performance.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.2" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.2" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.2"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.2"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.2"></script></div></body></html>