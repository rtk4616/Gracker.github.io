<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Android5.0中 hwui 中 RenderThread 工作流程 | Performance</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言本篇文章是自己的一个学习笔记，记录了 Android 5.0 中 hwui 中的 RenderThread 的简单工作流程。由于是学习笔记，所以其中一些细节不会太详细，我只是将大概的流程走一遍，将其工作流标注出来，下次遇到问题的时候就可以知道去哪里查。
下图是我用 Systrace 抓取的一个应用启动的时候 RenderThread 的第一次 Draw 的 Trace 图，从这里面的顺序来看">
<meta property="og:type" content="article">
<meta property="og:title" content="Android5.0中 hwui 中 RenderThread 工作流程">
<meta property="og:url" content="http://androidperformance.com/2015/08/12/AndroidL-hwui-RenderThread-workflow.html">
<meta property="og:site_name" content="Performance">
<meta property="og:description" content="前言本篇文章是自己的一个学习笔记，记录了 Android 5.0 中 hwui 中的 RenderThread 的简单工作流程。由于是学习笔记，所以其中一些细节不会太详细，我只是将大概的流程走一遍，将其工作流标注出来，下次遇到问题的时候就可以知道去哪里查。
下图是我用 Systrace 抓取的一个应用启动的时候 RenderThread 的第一次 Draw 的 Trace 图，从这里面的顺序来看">
<meta property="og:image" content="http://androidperformance.com/images/hwui/renderthread/1.png">
<meta property="og:image" content="http://androidperformance.com/images/hwui/renderthread/2.png">
<meta property="og:image" content="http://androidperformance.com/images/hwui/renderthread/3.png">
<meta property="og:image" content="http://androidperformance.com/images/hwui/renderthread/4.png">
<meta property="og:image" content="http://androidperformance.com/images/hwui/renderthread/5.png">
<meta property="og:image" content="http://androidperformance.com/images/hwui/renderthread/6.png">
<meta property="og:image" content="http://androidperformance.com/images/hwui/renderthread/7.png">
<meta property="og:updated_time" content="2015-08-12T14:45:31.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android5.0中 hwui 中 RenderThread 工作流程">
<meta name="twitter:description" content="前言本篇文章是自己的一个学习笔记，记录了 Android 5.0 中 hwui 中的 RenderThread 的简单工作流程。由于是学习笔记，所以其中一些细节不会太详细，我只是将大概的流程走一遍，将其工作流标注出来，下次遇到问题的时候就可以知道去哪里查。
下图是我用 Systrace 抓取的一个应用启动的时候 RenderThread 的第一次 Draw 的 Trace 图，从这里面的顺序来看">
  
    <link rel="alternative" href="/atom.xml" title="Performance" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/favicon.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Gracker</a></h1>
		</hgroup>

		
		<p class="header-subtitle">专注 Android 性能优化</p>
		
				


		
			<div id="switch-btn" class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div id="switch-area" class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/随笔">随笔</a></li>
				        
							<li><a href="/tags">标签云</a></li>
				        
							<li><a href="/about">关于我</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<ul class="social">
							
								<li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/gracker520" title="新浪微博"></a></li>
					        
								<li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/Gracker" title="GitHub"></a></li>
					        
								<li id="简书"><a class="简书" target="_blank" href="http://www.jianshu.com/users/FK4sc4/latest_articles" title="简书"></a></li>
					        
								<li id="知乎"><a class="知乎" target="_blank" href="http://www.zhihu.com/people/gracker" title="知乎"></a></li>
					        
								<li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
					        
						</ul>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/HashMap/" style="font-size: 10px;">HashMap</a> <a href="/tags/Java/" style="font-size: 12.5px;">Java</a> <a href="/tags/MAT/" style="font-size: 15px;">MAT</a> <a href="/tags/Menory/" style="font-size: 17.5px;">Menory</a> <a href="/tags/Nexus/" style="font-size: 10px;">Nexus</a> <a href="/tags/Performance/" style="font-size: 15px;">Performance</a> <a href="/tags/RenderThread/" style="font-size: 10px;">RenderThread</a> <a href="/tags/Singleton/" style="font-size: 10px;">Singleton</a> <a href="/tags/hwui/" style="font-size: 10px;">hwui</a> <a href="/tags/启动优化/" style="font-size: 10px;">启动优化</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Gracker</a></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<a href="/" class="profilepic">
				<img lazy-src="/img/favicon.png" class="js-avatar">
			</a>
			<hgroup>
			  <h1 class="header-author"><a href="/" title="回到主页">Gracker</a></h1>
			</hgroup>
			
			<p class="header-subtitle">专注 Android 性能优化</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
					<li><a href="/tags">标签云</a></li>
		        
					<li><a href="/about">关于我</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
						<ul class="social">
							
								<li id="新浪微博"><a class="新浪微博" target="_blank" href="http://weibo.com/gracker520" title="新浪微博"></a></li>
					        
								<li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/Gracker" title="GitHub"></a></li>
					        
								<li id="简书"><a class="简书" target="_blank" href="http://www.jianshu.com/users/FK4sc4/latest_articles" title="简书"></a></li>
					        
								<li id="知乎"><a class="知乎" target="_blank" href="http://www.zhihu.com/people/gracker" title="知乎"></a></li>
					        
								<li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
					        
						</ul>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-AndroidL-hwui-RenderThread-workflow" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/12/AndroidL-hwui-RenderThread-workflow.html" class="article-date">
  	<time datetime="2015-08-12T14:38:01.000Z" itemprop="datePublished">2015-08-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Android5.0中 hwui 中 RenderThread 工作流程
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Android/">Android</a><a class="article-category-link" href="/categories/Android/View/">View</a>
	</div>


        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Menory/">Menory</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RenderThread/">RenderThread</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hwui/">hwui</a></li></ul>
	</div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言">前言</h2><p>本篇文章是自己的一个学习笔记，记录了 Android 5.0 中 hwui 中的 RenderThread 的简单工作流程。由于是学习笔记，所以其中一些细节不会太详细，我只是将大概的流程走一遍，将其工作流标注出来，下次遇到问题的时候就可以知道去哪里查。</p>
<p>下图是我用 Systrace 抓取的一个应用启动的时候 RenderThread 的第一次 Draw 的 Trace 图，从这里面的顺序来看 RenderThread 的流程。熟悉应用启动流程的话应该知道，只有当第一次 DrawFrame 完成之后，整个应用的界面才会显示在手机上，在这之前，用户看到的是应用的 StartingWindow 的界面。</p>
<a id="more"></a>
<p><img src="/images/hwui/renderthread/1.png" alt="RenderThread Draw first frame"></p>
<h2 id="从Java层说起">从Java层说起</h2><p>应用程序的每一帧是从接收到 VSYNC 信号开始进行计算和绘制的,这要从 Choreographer 这个类说起了，不过由于篇幅原因，我们直接看一帧的绘制调用关系链即可：</p>
<p><img src="/images/hwui/renderthread/2.png" alt="绘制关系链"></p>
<p>Choreographer 的 drawFrame 会调用到 ViewRootImpl 的 performTraversals 方法，而 performTraversals 方法最终会调用到performDraw() 方法， performDraw 又会调用到 draw(boolean fullRedrawNeeded) 方法，这个 draw 方法是 ViewRootImpl 的私有方法，和我们熟知的那个draw并不是同一个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (mAttachInfo.mHardwareRenderer != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mHardwareRenderer.isEnabled()) &#123;</span><br><span class="line">                mIsAnimating = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">boolean</span> invalidateRoot = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (mHardwareYOffset != yOffset || mHardwareXOffset != xOffset) &#123;</span><br><span class="line">                    mHardwareYOffset = yOffset;</span><br><span class="line">                    mHardwareXOffset = xOffset;</span><br><span class="line">                    mAttachInfo.mHardwareRenderer.invalidateRoot();</span><br><span class="line">                &#125;</span><br><span class="line">                mResizeAlpha = resizeAlpha;</span><br><span class="line"></span><br><span class="line">                dirty.setEmpty();</span><br><span class="line"></span><br><span class="line">                mBlockResizeBuffer = <span class="keyword">false</span>;</span><br><span class="line">                mAttachInfo.mHardwareRenderer.draw(mView, mAttachInfo, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是走硬件绘制路线的话，则会走这一条先，之后就会调用 mHardwareRenderer 的 draw 方法,这里的 mHardwareRenderer 指的是 ThreadedRenderer ，其 Draw 函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(View view, AttachInfo attachInfo, HardwareDrawCallbacks callbacks)</span> </span>&#123;</span><br><span class="line">    attachInfo.mIgnoreDirtyState = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">long</span> frameTimeNanos = mChoreographer.getFrameTimeNanos();</span><br><span class="line">    attachInfo.mDrawingTime = frameTimeNanos / TimeUtils.NANOS_PER_MS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> recordDuration = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (mProfilingEnabled) &#123;</span><br><span class="line">        recordDuration = System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    updateRootDisplayList(view, callbacks);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mProfilingEnabled) &#123;</span><br><span class="line">        recordDuration = System.nanoTime() - recordDuration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    attachInfo.mIgnoreDirtyState = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// register animating rendernodes which started animating prior to renderer</span></span><br><span class="line">    <span class="comment">// creation, which is typical for animators started prior to first draw</span></span><br><span class="line">    <span class="keyword">if</span> (attachInfo.mPendingAnimatingRenderNodes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = attachInfo.mPendingAnimatingRenderNodes.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            registerAnimatingRenderNode(</span><br><span class="line">                    attachInfo.mPendingAnimatingRenderNodes.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        attachInfo.mPendingAnimatingRenderNodes.clear();</span><br><span class="line">        <span class="comment">// We don't need this anymore as subsequent calls to</span></span><br><span class="line">        <span class="comment">// ViewRootImpl#attachRenderNodeAnimator will go directly to us.</span></span><br><span class="line">        attachInfo.mPendingAnimatingRenderNodes = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> syncResult = nSyncAndDrawFrame(mNativeProxy, frameTimeNanos,</span><br><span class="line">            recordDuration, view.getResources().getDisplayMetrics().density);</span><br><span class="line">    <span class="keyword">if</span> ((syncResult &amp; SYNC_INVALIDATE_REQUIRED) != <span class="number">0</span>) &#123;</span><br><span class="line">        attachInfo.mViewRootImpl.invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数里面的 updateRootDisplayList(view, callbacks) ;即 getDisplayList 操作。接下来就是比较重要的一个操作：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int syncResult = nSyncAndDrawFrame<span class="list">(<span class="keyword">mNativeProxy</span>, frameTimeNanos,</span><br><span class="line">        recordDuration, view.getResources<span class="list">()</span>.getDisplayMetrics<span class="list">()</span>.density)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>可以看出这是一个阻塞操作，等Native层完成后，拿到返回值后才会进行下一步的操作。</p>
<h2 id="Native层">Native层</h2><p>其Native代码在android_view_ThreadedRenderer.cpp中，对应的实现代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">android_view_ThreadedRenderer_syncAndDrawFrame</span><span class="params">(JNIEnv* env, jobject clazz,</span><br><span class="line">        jlong proxyPtr, jlong frameTimeNanos, jlong recordDuration, jfloat density)</span> </span>&#123;</span><br><span class="line">    RenderProxy* proxy = <span class="keyword">reinterpret_cast</span>&lt;RenderProxy*&gt;(proxyPtr);</span><br><span class="line">    <span class="keyword">return</span> proxy-&gt;syncAndDrawFrame(frameTimeNanos, recordDuration, density);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RenderProxy的路径位于frameworks/base/libs/hwui/renderthread/RenderProxy.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> RenderProxy::syncAndDrawFrame(<span class="keyword">nsecs_t</span> frameTimeNanos, <span class="keyword">nsecs_t</span> recordDurationNanos,</span><br><span class="line">        <span class="keyword">float</span> density) &#123;</span><br><span class="line">    mDrawFrameTask.setDensity(density);</span><br><span class="line">    <span class="keyword">return</span> mDrawFrameTask.drawFrame(frameTimeNanos, recordDurationNanos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 mDrawFrameTask 是一个 DrawFrameTask 对象，其路径位于frameworks/base/libs/hwui/renderthread/DrawFrameTask.cpp，其中drawFrame代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> DrawFrameTask::drawFrame(<span class="keyword">nsecs_t</span> frameTimeNanos, <span class="keyword">nsecs_t</span> recordDurationNanos) &#123;</span><br><span class="line">    mSyncResult = kSync_OK;</span><br><span class="line">    mFrameTimeNanos = frameTimeNanos;</span><br><span class="line">    mRecordDurationNanos = recordDurationNanos;</span><br><span class="line">    postAndWait();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset the single-frame data</span></span><br><span class="line">    mFrameTimeNanos = <span class="number">0</span>;</span><br><span class="line">    mRecordDurationNanos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mSyncResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 postAndWait() 的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DrawFrameTask::postAndWait() &#123;</span><br><span class="line">    AutoMutex _lock(mLock);</span><br><span class="line">    mRenderThread-&gt;<span class="built_in">queue</span>(<span class="keyword">this</span>);</span><br><span class="line">    mSignal.wait(mLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是将一个 DrawFrameTask 放入到了 mRenderThread 中,其中 queue 方法实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RenderThread::<span class="built_in">queue</span>(RenderTask* task) &#123;</span><br><span class="line">    AutoMutex _lock(mLock);</span><br><span class="line">    mQueue.<span class="built_in">queue</span>(task);</span><br><span class="line">    <span class="keyword">if</span> (mNextWakeup &amp;&amp; task-&gt;mRunAt &lt; mNextWakeup) &#123;</span><br><span class="line">        mNextWakeup = <span class="number">0</span>;</span><br><span class="line">        mLooper-&gt;wake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 mQueue 是一个 TaskQueue 对象，其</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> TaskQueue::queue(RenderTask* <span class="keyword">task</span>) &#123;</span><br><span class="line">    <span class="comment">// Since the RenderTask itself forms the linked list it is not allowed</span></span><br><span class="line">    <span class="comment">// to have the same task queued twice</span></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(<span class="keyword">task</span>-&gt;mNext || mTail == <span class="keyword">task</span>, <span class="string">"Task is already in the queue!"</span>);</span><br><span class="line">    <span class="keyword">if</span> (mTail) &#123;</span><br><span class="line">        <span class="comment">// Fast path if we can just append</span></span><br><span class="line">        <span class="keyword">if</span> (mTail-&gt;mRunAt &lt;= <span class="keyword">task</span>-&gt;mRunAt) &#123;</span><br><span class="line">            mTail-&gt;mNext = <span class="keyword">task</span>;</span><br><span class="line">            mTail = <span class="keyword">task</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Need to find the proper insertion point</span></span><br><span class="line">            RenderTask* <span class="keyword">previous</span> = <span class="number">0</span>;</span><br><span class="line">            RenderTask* <span class="keyword">next</span> = mHead;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">next</span> &amp;&amp; <span class="keyword">next</span>-&gt;mRunAt &lt;= <span class="keyword">task</span>-&gt;mRunAt) &#123;</span><br><span class="line">                <span class="keyword">previous</span> = <span class="keyword">next</span>;</span><br><span class="line">                <span class="keyword">next</span> = <span class="keyword">next</span>-&gt;mNext;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">previous</span>) &#123;</span><br><span class="line">                <span class="keyword">task</span>-&gt;mNext = mHead;</span><br><span class="line">                mHead = <span class="keyword">task</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">previous</span>-&gt;mNext = <span class="keyword">task</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">next</span>) &#123;</span><br><span class="line">                    <span class="keyword">task</span>-&gt;mNext = <span class="keyword">next</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mTail = <span class="keyword">task</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mTail = mHead = <span class="keyword">task</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着看 RenderThread 之前的 queue 方法，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::wake() &#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> nWrite;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        nWrite = write(mWakeWritePipeFd, <span class="string">"W"</span>, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (nWrite == -<span class="number">1</span> &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nWrite != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">            ALOGW(<span class="string">"Could not write wake signal, errno=%d"</span>, errno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>wake 函数则更为简单，仅仅向管道的写端写入一个字符“W”，这样管道的读端就会因为有数据可读而从等待状态中醒来。</p>
<h2 id="HWUI-RenderThread">HWUI-RenderThread</h2><p>接下来会到哪里去，我们首先要熟悉一下RenderThread，RenderThread是继承自Thread的，这个Thread是utils/Thread.h,RenderThread的初始化函数</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RenderThread::RenderThread() : Thread(<span class="keyword">true</span>), Singleton&lt;RenderThread&gt;()</span><br><span class="line">        , mNextWakeup(LLONG_MAX)</span><br><span class="line">        , mDisplayEventReceiver(0)</span><br><span class="line">        , mVsyncRequested(<span class="keyword">false</span>)</span><br><span class="line">        , mFrameCallbackTaskPending(<span class="keyword">false</span>)</span><br><span class="line">        , mFrameCallbackTask(0)</span><br><span class="line">        , mRenderState(NULL)</span><br><span class="line">        , mEglManager(NULL) &#123;</span><br><span class="line">    mFrameCallbackTask = <span class="keyword">new</span> DispatchFrameCallbacks(<span class="keyword">this</span>);</span><br><span class="line">    mLooper = <span class="keyword">new</span> Looper(<span class="keyword">false</span>);</span><br><span class="line">    run(<span class="string">"RenderThread"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其 run 方法在 Thread 中有说明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start the thread in threadLoop() which needs to be implemented.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> status_t    <span class="title">run</span><span class="params">(    <span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="number">0</span>,</span><br><span class="line">                            int32_t priority = PRIORITY_DEFAULT,</span><br><span class="line">                            size_t <span class="built_in">stack</span> = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>即启动 threadLoop 函数，我们来看 RenderThread 的 threadLoop 函数，这个函数比较重要：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> RenderThread::threadLoop() &#123;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> defined(HAVE_PTHREADS)</span></span><br><span class="line">    setpriority(PRIO_PROCESS, <span class="number">0</span>, PRIORITY_DISPLAY);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">    initThreadLocals();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> timeoutMillis = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> result = mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">        LOG_ALWAYS_FATAL_IF(result == Looper::POLL_ERROR,</span><br><span class="line">                <span class="string">"RenderThread Looper POLL_ERROR!"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">nsecs_t</span> nextWakeup;</span><br><span class="line">        <span class="comment">// Process our queue, if we have anything</span></span><br><span class="line">        <span class="keyword">while</span> (RenderTask* task = nextTask(&amp;nextWakeup)) &#123;</span><br><span class="line">            task-&gt;run();</span><br><span class="line">            <span class="comment">// task may have deleted itself, do not reference it again</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nextWakeup == LLONG_MAX) &#123;</span><br><span class="line">            timeoutMillis = -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">nsecs_t</span> timeoutNanos = nextWakeup - systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">            timeoutMillis = nanoseconds_to_milliseconds(timeoutNanos);</span><br><span class="line">            <span class="keyword">if</span> (timeoutMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                timeoutMillis = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mPendingRegistrationFrameCallbacks.size() &amp;&amp; !mFrameCallbackTaskPending) &#123;</span><br><span class="line">            drainDisplayEventQueue(<span class="literal">true</span>);</span><br><span class="line">            mFrameCallbacks.insert(</span><br><span class="line">                    mPendingRegistrationFrameCallbacks.begin(), mPendingRegistrationFrameCallbacks.end());</span><br><span class="line">            mPendingRegistrationFrameCallbacks.clear();</span><br><span class="line">            requestVsync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，一个 for 循环是一个无限循环，而其中 pollOnce 是一个阻塞函数，直到我们上面调用了 mLooper-&gt;wake() 之后，会继续往下走，走到 while 循环中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (RenderTask* task = nextTask(&amp;nextWakeup)) &#123;</span><br><span class="line">            task-&gt;run();</span><br><span class="line">            <span class="comment">// task may have deleted itself, do not reference it again</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>会将 RenderTask 取出来执行其 run 方法，经过前面的流程我们知道这个 RenderTask 是一个 DrawFrameTask ，其run方法如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void DrawFrameTask::run() &#123;</span><br><span class="line">    ATRACE_NAME("DrawFrame");</span><br><span class="line"></span><br><span class="line">    mContext-&gt;profiler().setDensity(mDensity);</span><br><span class="line">    mContext-&gt;profiler().startFrame(mRecordDurationNanos);</span><br><span class="line"></span><br><span class="line">    bool canUnblockUiThread;</span><br><span class="line">    bool canDrawThisFrame;</span><br><span class="line">    &#123;</span><br><span class="line">        TreeInfo info(TreeInfo::MODE_FULL, mRenderThread-&gt;renderState());</span><br><span class="line">        canUnblockUiThread = syncFrameState(info);</span><br><span class="line">        canDrawThisFrame = info.out.canDrawThisFrame;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Grab a copy of everything we need</span><br><span class="line">    CanvasContext* context = mContext;</span><br><span class="line"></span><br><span class="line">    // From this point on anything in "this" is *UNSAFE TO ACCESS*</span><br><span class="line">    if (canUnblockUiThread) &#123;</span><br><span class="line">        unblockUiThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (CC_LIKELY(canDrawThisFrame)) &#123;</span><br><span class="line">        context-&gt;draw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!canUnblockUiThread) &#123;</span><br><span class="line">        unblockUiThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RenderThread-DrawFrame">RenderThread.DrawFrame</h2><p>上面说到了 DrawFrameTask 的 run 方法，这里 run 方法中的执行的方法即我们在最前面那张图中所示的部分（即文章最前面那张图），下面的流程就是那张图中的函数调用，我们结合代码和图，一部分一部分来走整个 DrawFrame 的流程：</p>
<h3 id="1-_syncFrameState">1. syncFrameState</h3><p>第一个比较重要的函数是 syncFrameState ，从函数名就可以知道， syncFrameState 的作用就是同步 frame 信息，将 Java 层维护的 frame 信息同步到 RenderThread中。</p>
<blockquote>
<p>Main Thread 和Render Thread 都各自维护了一份应用程序窗口视图信息。各自维护了一份应用程序窗口视图信息的目的，就是为了可以互不干扰，进而实现最大程度的并行。其中，Render Thread维护的应用程序窗口视图信息是来自于 Main Thread 的。因此，当Main Thread 维护的应用程序窗口信息发生了变化时，就需要同步到 Render Thread 去。</p>
</blockquote>
<p>所以查看代码就可以知道有两个 RenderNode，一个在 hwui 中，一个在 View 中。简单来说，同步信息就是将 Java 层的 RenderNode 中的信息同步到 hwui 中的 RenderNode 中。 注意syncFrameState的返回值赋给了 canUnblockUiThread ，从名字可以看出这个 canUnblockUiThread 的作用是判断是否唤醒 Main Thread ，也就是说如果返回为 true 的话，会提前唤醒主线程来执行其他的事情，而不用等到 draw 完成后再去唤醒 Main Thread。 这也是 Android 5.0 和 Android 4.x 最大的区别了。</p>
<p><img src="/images/hwui/renderthread/3.png" alt="syncFrameState"></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> DrawFrameTask::syncFrameState(TreeInfo&amp; info) &#123;</span><br><span class="line">    mRenderThread-&gt;timeLord().vsyncReceived(mFrameTimeNanos);</span><br><span class="line">    mContext-&gt;makeCurrent();</span><br><span class="line">    Caches::getInstance().textureCache.resetMarkInUse();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; mLayers.size(); i++) &#123;</span><br><span class="line">        mContext-&gt;processLayerUpdate(mLayers[i].get());</span><br><span class="line">    &#125;</span><br><span class="line">    mLayers.clear();</span><br><span class="line">    mContext-&gt;prepareTree(info);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.out.hasAnimations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (info.out.requiresUiRedraw) &#123;</span><br><span class="line">            mSyncResult |= kSync_UIRedrawRequired;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If prepareTextures is false, we ran out of texture cache space</span></span><br><span class="line">    <span class="keyword">return</span> info.prepareTextures;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是makeCurrent，这里的mContext是一个CanvasContext对象，其makeCurrent实现如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CanvasContext::makeCurrent() &#123;</span><br><span class="line">    <span class="comment">// In the meantime this matches the behavior of GLRenderer, so it is not a regression</span></span><br><span class="line">    mHaveNewSurface |= mEglManager.makeCurrent(mEglSurface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mEglManager是一个EglManager对象，其实现为：</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bool EglManager::makeCurrent(EGLSurface <span class="keyword">surface</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isCurrent(<span class="keyword">surface</span>)) <span class="keyword">return</span> false;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">surface</span> == EGL_NO_SURFACE) &#123;</span><br><span class="line">        <span class="comment">// If we are setting EGL_NO_SURFACE we don't care about any of the potential</span></span><br><span class="line">        <span class="comment">// return errors, which would only happen if mEglDisplay had already been</span></span><br><span class="line">        <span class="comment">// destroyed in which case the current context is already NO_CONTEXT</span></span><br><span class="line">        TIME_LOG(<span class="string">"eglMakeCurrent"</span>, eglMakeCurrent(mEglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        EGLBoolean success;</span><br><span class="line">        TIME_LOG(<span class="string">"eglMakeCurrent"</span>, success = eglMakeCurrent(mEglDisplay, <span class="keyword">surface</span>, <span class="keyword">surface</span>, mEglContext));</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            LOG_ALWAYS_FATAL(<span class="string">"Failed to make current on surface %p, error=%s"</span>,</span><br><span class="line">                (void<span class="variable">*)</span><span class="keyword">surface</span>, egl_error_str());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mCurrentSurface = <span class="keyword">surface</span>;</span><br><span class="line">    <span class="keyword">return</span> true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会判断mCurrentSurface == surface，如果成立，则不用再初始化操作，如果是另外一个surface。，则会执行eglMakeCurrent，来重新创建上下文。</p>
<p>makeCurrent之后，会调用mContext-&gt;prepareTree(info)，其实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CanvasContext::prepareTree(TreeInfo&amp; info) &#123;</span><br><span class="line">    mRenderThread.removeFrameCallback(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    info.damageAccumulator = &amp;mDamageAccumulator;</span><br><span class="line">    info.renderer = mCanvas;</span><br><span class="line">    <span class="keyword">if</span> (mPrefetechedLayers.size() &amp;&amp; info.mode == TreeInfo::MODE_FULL) &#123;</span><br><span class="line">        info.canvasContext = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mAnimationContext-&gt;startFrame(info.mode);</span><br><span class="line">    mRootRenderNode-&gt;prepareTree(info);</span><br><span class="line">    mAnimationContext-&gt;runRemainingAnimations(info);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.canvasContext) &#123;</span><br><span class="line">        freePrefetechedLayers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> runningBehind = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> This query is moderately expensive, investigate adding some sort</span></span><br><span class="line">    <span class="comment">// of fast-path based off when we last called eglSwapBuffers() as well as</span></span><br><span class="line">    <span class="comment">// last vsync time. Or something.</span></span><br><span class="line">    TIME_LOG(<span class="string">"nativeWindowQuery"</span>, mNativeWindow-&gt;query(mNativeWindow.get(),</span><br><span class="line">            NATIVE_WINDOW_CONSUMER_RUNNING_BEHIND, &amp;runningBehind));</span><br><span class="line">    info.out.canDrawThisFrame = !runningBehind;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.out.hasAnimations || !info.out.canDrawThisFrame) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!info.out.requiresUiRedraw) &#123;</span><br><span class="line">            <span class="comment">// If animationsNeedsRedraw is set don't bother posting for an RT anim</span></span><br><span class="line">            <span class="comment">// as we will just end up fighting the UI thread.</span></span><br><span class="line">            mRenderThread.postFrameCallback(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 mRootRenderNode-&gt;prepareTree(info) 又是最重要的。回到Java层，我们知道 ThreadedRenderer 在初始化时，初始化了一个指针</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> rootNodePtr = nCreateRootRenderNode();</span><br></pre></td></tr></table></figure>
<p>这个RootRenderNode也就是一个根Node，</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mRootNode = RenderNode.adopt(rootNodePtr)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>然后会创建一个 mNativeProxy 指针，在 Native 层初始化一个 RenderProxy 对象，将 rootNodePtr 传给 RenderProxy 对象，这样在 RenderProxy 我们就可以得到这个对象的指针了。其中 CanvasContext 也是在 RenderProxy 对象初始化的时候被初始化的，初始化的时候将 rootNodePtr 传给了 CanvasContext 对象。</p>
<p>我们之前提到 ThreadedRenderer 的 draw 方法中首先会调用updateRootDisplayList，即我们熟悉的 getDisplayList 。这个方法中，其实也分为两个步骤，第一个步骤是 updateViewTreeDisplayList，第二个步骤是将根 Node 加入到 DrawOp 中：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">canvas</span><span class="class">.insertReorderBarrier</span>();</span><br><span class="line"><span class="tag">canvas</span><span class="class">.drawRenderNode</span>(<span class="tag">view</span><span class="class">.getDisplayList</span>());</span><br><span class="line"><span class="tag">canvas</span><span class="class">.insertInorderBarrier</span>();</span><br></pre></td></tr></table></figure></p>
<p>其最终实现在</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> DisplayListRenderer::drawRenderNode(RenderNode* renderNode, Rect&amp; dirty, <span class="keyword">int32_t</span> flags) &#123;</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(!renderNode, <span class="string">"missing rendernode"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dirty is an out parameter and should not be recorded,</span></span><br><span class="line">    <span class="comment">// it matters only when replaying the display list</span></span><br><span class="line">    DrawRenderNodeOp* op = <span class="keyword">new</span> (alloc()) DrawRenderNodeOp(renderNode, flags, *currentTransform());</span><br><span class="line">    addRenderNodeOp(op);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DrawGlInfo::kStatusDone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再回到我们之前的 CanvasContext.prepareTree 中提到的 mRootRenderNode-&gt;prepareTree(info)，这时候这里的 mRootRenderNode 就是 CanvasContext 初始化是传进来的。</p>
<p>其实现在 RenderNode.cpp 中：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void RenderNode::prepareTree(Tree<span class="number">Inf</span>o&amp; <span class="number">inf</span>o) &#123;</span><br><span class="line">    prepareTreeImpl(<span class="number">inf</span>o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void RenderNode::prepareTreeImpl(Tree<span class="number">Inf</span>o&amp; <span class="number">inf</span>o) &#123;</span><br><span class="line">    TT_START_MARK(getName());</span><br><span class="line">    <span class="number">inf</span>o.damageAccumulator-&gt;pushTransform(this);</span><br><span class="line"></span><br><span class="line">    if (<span class="number">inf</span>o.mode == Tree<span class="number">Inf</span>o::MODE_FULL) &#123;</span><br><span class="line">        pushStagingPropertiesChanges(<span class="number">inf</span>o); //同步当前正在处理的Render <span class="keyword">Node</span><span class="identifier"></span><span class="title">的Property</span></span><br><span class="line">    &#125;</span><br><span class="line">    uint32_t animatorDirtyMask = <span class="number">0</span>;</span><br><span class="line">    if (CC_LIKELY(<span class="number">inf</span>o.runAnimations)) &#123;</span><br><span class="line">        animatorDirtyMask = mAnimatorManager.animate(<span class="number">inf</span>o);//执行动画相关的操作</span><br><span class="line">    &#125;</span><br><span class="line">    prepareLayer(<span class="number">inf</span>o, animatorDirtyMask);</span><br><span class="line">    if (<span class="number">inf</span>o.mode == Tree<span class="number">Inf</span>o::MODE_FULL) &#123;</span><br><span class="line">        pushStagingDisplayListChanges(<span class="number">inf</span>o);  //同步当前正在处理的Render <span class="keyword">Node</span><span class="identifier"></span><span class="title">的Display</span> List</span><br><span class="line">    &#125;</span><br><span class="line">    prepareSubTree(<span class="number">inf</span>o, mDisplayListData); //同步当前正在处理的Render <span class="keyword">Node</span><span class="identifier"></span><span class="title">的Display</span> List引用的Bitmap，以及当前正在处理的Render <span class="keyword">Node</span><span class="identifier"></span><span class="title">的子Render</span> <span class="keyword">Node</span><span class="identifier"></span><span class="title">的Display</span> List等信息</span><br><span class="line">    pushLayerUpdate(<span class="number">inf</span>o); //检查当前正在处理的Render <span class="keyword">Node</span><span class="identifier"></span><span class="title">是否设置了Layer</span>。如果设置了的话，就对这些Layer进行处理</span><br><span class="line"></span><br><span class="line">    <span class="number">inf</span>o.damageAccumulator-&gt;popTransform();</span><br><span class="line">    TT_END_MARK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里所涉及到的进一步的具体操作大家可以自行去看代码。</p>
<h2 id="2-_draw">2. draw</h2><p><img src="/images/hwui/renderthread/4.png" alt="Draw"></p>
<p>执行完syncFrameState之后，接下来就是执行draw</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span> <span class="params">(<span class="variable">CC_LIKELY</span>(can<span class="variable">DrawThisFrame</span>)</span>) &#123;</span><br><span class="line">    <span class="title">context</span>-&gt;</span><span class="function_name">draw</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CanvasContext的draw函数是一个核心函数，其位置在 frameworks/base/libs/hwui/OpenGLRenderer.cpp ，其实现如下：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> CanvasContext<span class="tag">::draw</span>() &#123;</span><br><span class="line">    profiler()<span class="built_in">.</span>markPlaybackStart();</span><br><span class="line"></span><br><span class="line">    SkRect dirty;</span><br><span class="line">    mDamageAccumulat<span class="subst">or</span><span class="built_in">.</span>finish(<span class="subst">&amp;</span>dirty);</span><br><span class="line"></span><br><span class="line">    <span class="attribute">...</span><span class="attribute">...</span></span><br><span class="line"></span><br><span class="line">    status_t status;</span><br><span class="line">    <span class="keyword">if</span> (<span class="subst">!</span>dirty<span class="built_in">.</span>isEmpty()) &#123;</span><br><span class="line">        status = mCanvas<span class="subst">-&gt;</span>prepareDirty(dirty<span class="built_in">.</span>fLeft, dirty<span class="built_in">.</span>fTop,</span><br><span class="line">                dirty<span class="built_in">.</span>fRight, dirty<span class="built_in">.</span>fBottom, mOpaque);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        status = mCanvas<span class="subst">-&gt;</span>prepare(mOpaque);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Rect outBounds;</span><br><span class="line">    status |= mCanvas<span class="subst">-&gt;</span>drawRenderNode(mRootRenderNode<span class="built_in">.</span>get(), outBounds);</span><br><span class="line"></span><br><span class="line">    profiler()<span class="built_in">.</span>draw(mCanvas);</span><br><span class="line"></span><br><span class="line">    mCanvas<span class="subst">-&gt;</span>finish();</span><br><span class="line"></span><br><span class="line">    profiler()<span class="built_in">.</span>markPlaybackEnd();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status <span class="subst">&amp;</span> DrawGlInfo<span class="tag">::kStatusDrew</span>) &#123;</span><br><span class="line">        swapBuffers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    profiler()<span class="built_in">.</span>finishFrame();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// M: enable to get overdraw count</span></span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(g_HWUI_debug_overdraw)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="subst">!</span>mDebugOverdrawLayer) &#123;</span><br><span class="line">            mDebugOverdrawLayer = LayerRenderer<span class="tag">::createRenderLayer</span>(mRenderThread<span class="built_in">.</span>renderState(),</span><br><span class="line">                mCanvas<span class="subst">-&gt;</span>getWidth(), mCanvas<span class="subst">-&gt;</span>getHeight());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mDebugOverdrawLayer<span class="subst">-&gt;</span>layer<span class="built_in">.</span>getWidth() != mCanvas<span class="subst">-&gt;</span>getWidth() <span class="subst">||</span></span><br><span class="line">                   mDebugOverdrawLayer<span class="subst">-&gt;</span>layer<span class="built_in">.</span>getHeight() != mCanvas<span class="subst">-&gt;</span>getHeight()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="subst">!</span>LayerRenderer<span class="tag">::resizeLayer</span>(mDebugOverdrawLayer, mCanvas<span class="subst">-&gt;</span>getWidth(), mCanvas<span class="subst">-&gt;</span>getHeight())) &#123;</span><br><span class="line">                LayerRenderer<span class="tag">::destroyLayer</span>(mDebugOverdrawLayer);</span><br><span class="line">                mDebugOverdrawLayer = <span class="built_in">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">...</span><span class="attribute">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1_eglBeginFrame">2.1 eglBeginFrame</h4><p>首先来看eglBeginFrame的实现</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void EglManager<span class="value">::<span class="function">beginFrame</span>(EGLSurface surface, EGLint* width, EGLint* height) &#123;</span><br><span class="line">    <span class="function">makeCurrent</span>(surface);</span></span><br><span class="line">    if (<span class="attribute">width</span>) &#123;</span><br><span class="line">        <span class="function">eglQuerySurface</span>(mEglDisplay, surface, EGL_WIDTH, <span class="attribute">width</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    if (<span class="attribute">height</span>) &#123;</span><br><span class="line">        <span class="function">eglQuerySurface</span>(mEglDisplay, surface, EGL_HEIGHT, <span class="attribute">height</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">eglBeginFrame</span>(mEglDisplay, surface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>makeCurrent是用来管理上下文，eglBeginFrame主要是校验参数的合法性。</p>
<h4 id="2-2_prepareDirty">2.2 prepareDirty</h4><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">status_t <span class="keyword">status</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="comment">!dirty.isEmpty()) &#123;</span></span><br><span class="line">    <span class="keyword">status</span> = mCanvas-&gt;prepareDirty(dirty.fLeft, dirty.fTop,</span><br><span class="line">            dirty.fRight, dirty.fBottom, mOpaque);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">status</span> = mCanvas-&gt;prepare(mOpaque);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的mCanvas是一个OpenGLRenderer对象，其prepareDirty实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span>增加函数功能描述</span></span><br><span class="line"><span class="keyword">status_t</span> OpenGLRenderer::prepareDirty(<span class="keyword">float</span> left, <span class="keyword">float</span> top,</span><br><span class="line">        <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">bool</span> opaque) &#123;</span><br><span class="line">    setupFrameState(left, top, right, bottom, opaque);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Layer renderers will start the frame immediately</span></span><br><span class="line">    <span class="comment">// The framebuffer renderer will first defer the display list</span></span><br><span class="line">    <span class="comment">// for each layer and wait until the first drawing command</span></span><br><span class="line">    <span class="comment">// to start the frame</span></span><br><span class="line">    <span class="keyword">if</span> (currentSnapshot()-&gt;fbo == <span class="number">0</span>) &#123;</span><br><span class="line">        syncState();</span><br><span class="line">        updateLayers();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> startFrame();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DrawGlInfo::kStatusDone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3_drawRenderNode">2.3 drawRenderNode</h4><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rect outBounds<span class="comment">;</span></span><br><span class="line">status |= mCanvas-&gt;drawRenderNode(mRootRenderNode.get(), outBounds)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>接下来就是调用OpenGLRenderer的drawRenderNode方法进行绘制</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">status_t OpenGLRenderer::drawRenderNode(RenderNode* renderNode, Rect&amp; dirty, int32_t replayFlags) &#123;</span><br><span class="line">    status_t status;</span><br><span class="line">    <span class="comment">// All the usual checks and setup operations (quickReject, setupDraw, etc.)</span></span><br><span class="line">    <span class="comment">// will be performed by the display list itself</span></span><br><span class="line">    <span class="keyword">if</span> (renderNode &amp;&amp; renderNode-&gt;isRenderable()) &#123;</span><br><span class="line">        <span class="comment">// compute 3d ordering</span></span><br><span class="line">        renderNode-&gt;computeOrdering();</span><br><span class="line">        <span class="keyword">if</span> (CC_UNLIKELY(mCaches.drawDeferDisabled)) &#123; <span class="comment">//判断是否不重排序</span></span><br><span class="line">            status = startFrame();</span><br><span class="line">            <span class="function">ReplayStateStruct <span class="title">replayStruct</span><span class="params">(*<span class="keyword">this</span>, dirty, replayFlags)</span></span>;</span><br><span class="line">            renderNode-&gt;replay(replayStruct, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> status | replayStruct.mDrawGlStatus;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要重新排序</span></span><br><span class="line">        bool avoidOverdraw = !mCaches.debugOverdraw &amp;&amp; !mCountOverdraw; <span class="comment">// shh, don't tell devs!</span></span><br><span class="line">        DeferredDisplayList deferredList(*currentClipRect(), avoidOverdraw);</span><br><span class="line">        <span class="function">DeferStateStruct <span class="title">deferStruct</span><span class="params">(deferredList, *<span class="keyword">this</span>, replayFlags)</span></span>;</span><br><span class="line">        renderNode-&gt;defer(deferStruct, <span class="number">0</span>); <span class="comment">//递归进行重排操作</span></span><br><span class="line"></span><br><span class="line">        flushLayers(); <span class="comment">// 首先执行设置了 Layer 的子 Render Node 的绘制命令，以便得到一个对应的FBO</span></span><br><span class="line">        status = startFrame(); <span class="comment">//执行一些诸如清理颜色绘冲区等基本操作</span></span><br><span class="line">        status = deferredList.flush(*<span class="keyword">this</span>, dirty) | status;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Even if there is no drawing command(Ex: invisible),</span></span><br><span class="line">    <span class="comment">// it still needs startFrame to clear buffer and start tiling.</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">startFrame</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 renderNode 是一个 Root Render Node，</p>
<p>可以看到，到了这里虽然只是开始，但是其实已经结束了，这个函数里面最重要的几步:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">renderNode-&gt;defer(deferStruct, <span class="number">0</span>); <span class="comment">//进行重排序</span></span><br><span class="line"></span><br><span class="line">flushLayers(); 首先执行设置了 Layer 的子 Render Node 的绘制命令，以便得到一个对应的FBO</span><br><span class="line"></span><br><span class="line">status = deferredList.flush(*<span class="keyword">this</span>, dirty) | status;   <span class="comment">//对deferredList中的绘制命令进行真正的绘制操作</span></span><br></pre></td></tr></table></figure>
<p>这几个是渲染部分真正的核心部分，其中的代码细节需要自己去研究。老罗在这部分讲的很细，有空可以去看看他的文章<a href="http://blog.csdn.net/Luoshengyang/article/details/46281499" target="_blank" rel="external"><a href="http://blog.csdn.net/luoshengyang/article/details/46281499" target="_blank" rel="external">Android应用程序UI硬件加速渲染的Display List渲染过程分析</a></a>.</p>
<h4 id="2-4_swapBuffers">2.4 swapBuffers</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(status &amp; DrawGlInfo::kStatusDrew)</span> &#123;</span><br><span class="line">    swapBuffers<span class="comment">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其核心就是调用EGL的 eglSwapBuffers(mEglDisplay, surface), duration)函数。</p>
<h4 id="2-5_FinishFrame">2.5  FinishFrame</h4><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">profiler<span class="literal">()</span>.finishFrame<span class="literal">()</span>;</span><br></pre></td></tr></table></figure>
<p>主要是记录时间信息。</p>
<h2 id="总结">总结</h2><p>鉴于我比较懒，而且总结能力不如老罗，就直接把他的总结贴过来了。<br>RenderThread的总的流程如下：</p>
<blockquote>
<ol>
<li><p>将Main Thread维护的Display List同步到Render Thread维护的Display List去。这个同步过程由Render Thread执行，但是Main Thread会被阻塞住。</p>
</li>
<li><p>如果能够完全地将Main Thread维护的Display List同步到Render Thread维护的Display List去，那么Main Thread就会被唤醒，此后Main Thread和Render Thread就互不干扰，各自操作各自内部维护的Display List；否则的话，Main Thread就会继续阻塞，直到Render Thread完成应用程序窗口当前帧的渲染为止。</p>
</li>
<li><p>Render Thread在渲染应用程序窗口的Root Render Node的Display List之前，首先将那些设置了Layer的子Render Node的Display List渲染在各自的一个FBO上，接下来再一起将这些FBO以及那些没有设置Layer的子Render Node的Display List一起渲染在Frame Buffer之上，也就是渲染在从Surface Flinger请求回来的一个图形缓冲区上。这个图形缓冲区最终会被提交给Surface Flinger合并以及显示在屏幕上。</p>
</li>
</ol>
<p>第2步能够完全将Main Thread维护的Display List同步到Render Thread维护的Display List去很关键，它使得Main Thread和Render Thread可以并行执行，这意味着Render Thread在渲染应用程序窗口当前帧的Display List的同时，Main Thread可以去准备应用程序窗口下一帧的Display List，这样就使得应用程序窗口的UI更流畅。</p>
</blockquote>
<p>注意最后一段，在 Android 4.x 时代，没有RenderThread的时代，只有 Main Thread ，也就是说 必须要等到 Draw 完成后，才会去准备下一帧的数据，如下图：</p>
<p><img src="/images/hwui/renderthread/5.png" alt="Paste_Image.png"></p>
<p>Android5.0 之后，如老罗所说，有两种情况，</p>
<p><img src="/images/hwui/renderthread/6.png" alt="Main Thread 和 Render Thread"></p>
<p><img src="/images/hwui/renderthread/7.png" alt="Render Thread 提前唤醒了 Main Thread"></p>
<p>可以看到第二张图中，Render Thread 并没有绘制完成，但是由于其提前唤醒了 Main Thread ，所以 Main Thread 在下一个Vsync信号到来的时候，响应了Vsync事件，开始准备下一帧。<br>此时虽然由于第一帧绘制时间过长，导致掉了一帧，但是第二帧没有收到任何影响。</p>

      
      
    </div>
    
  </div>
  
    
<div class="copyright">
  <p><span>本文标题:</span><a href="/2015/08/12/AndroidL-hwui-RenderThread-workflow.html">Android5.0中 hwui 中 RenderThread 工作流程</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 Gracker 的个人博客">Gracker</a></p>
  <p><span>发布时间:</span>2015年08月12日 - 22时38分</p>
  <p><span>最后更新:</span>2015年08月12日 - 22时45分</p>
  <p>
    <span>原始链接:</span><a href="/2015/08/12/AndroidL-hwui-RenderThread-workflow.html" title="Android5.0中 hwui 中 RenderThread 工作流程">http://androidperformance.com/2015/08/12/AndroidL-hwui-RenderThread-workflow.html</a>
    <span class="btn" data-clipboard-text="原文: http://androidperformance.com/2015/08/12/AndroidL-hwui-RenderThread-workflow.html　　作者: Gracker" title="点击复制文章链接">
        <i class="fa fa-clipboard"></i>
    </span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。</p>
  <script src="/js/clipboard.min.js"></script>
  <script> var clipboard = new Clipboard('.btn'); </script>
</div>
<style type="text/css">
  .copyright p .btn {
    margin-left: 1em;
  }
  .copyright:hover p .btn::after {
    content: "复制"
  }
  .copyright p .btn:hover {
      color: gray;
      cursor: pointer;
    };
</style>



<nav id="article-nav">
  
    <div id="article-nav-newer" class="article-nav-title">
      <a href="/2015/11/09/Performance ListView.html">
        
      </a>
    </div>
  
  
    <div id="article-nav-older" class="article-nav-title">
      <a href="/2015/08/05/HashMap.html">
        HashMap源码分析
      </a>
    </div>
  
</nav>

  
</article>

<!-- 默认显示文章目录，在文章---前输入toc: false关闭目录 -->
<!-- Show TOC and tocButton in default, Hide TOC via putting "toc: false" before "---" at [post].md -->
<div id="toc" class="toc-article">
<strong class="toc-title">文章目录</strong>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从Java层说起"><span class="toc-number">2.</span> <span class="toc-text">从Java层说起</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Native层"><span class="toc-number">3.</span> <span class="toc-text">Native层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HWUI-RenderThread"><span class="toc-number">4.</span> <span class="toc-text">HWUI-RenderThread</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RenderThread-DrawFrame"><span class="toc-number">5.</span> <span class="toc-text">RenderThread.DrawFrame</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-_syncFrameState"><span class="toc-number">5.1.</span> <span class="toc-text">1. syncFrameState</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-_draw"><span class="toc-number">6.</span> <span class="toc-text">2. draw</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1_eglBeginFrame"><span class="toc-number">6.0.1.</span> <span class="toc-text">2.1 eglBeginFrame</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2_prepareDirty"><span class="toc-number">6.0.2.</span> <span class="toc-text">2.2 prepareDirty</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3_drawRenderNode"><span class="toc-number">6.0.3.</span> <span class="toc-text">2.3 drawRenderNode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4_swapBuffers"><span class="toc-number">6.0.4.</span> <span class="toc-text">2.4 swapBuffers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5_FinishFrame"><span class="toc-number">6.0.5.</span> <span class="toc-text">2.5  FinishFrame</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li></ol>
</div>
<style type="text/css">
  .left-col .switch-btn {
    display: none;
  }
  .left-col .switch-area {
    display: none;
  }
</style>

<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">
<script type="text/javascript">
  var toc_button= document.getElementById("tocButton");
  var toc_div= document.getElementById("toc");
  /* Show or hide toc when click on tocButton.
  通过点击设置的按钮显示或者隐藏文章目录.*/
  toc_button.onclick=function(){
  if(toc_div.style.display=="none"){
  toc_div.style.display="block";
  toc_button.value="隐藏目录";
  document.getElementById("switch-btn").style.display="none";
  document.getElementById("switch-area").style.display="none";
  }
  else{
  toc_div.style.display="none";
  toc_button.value="显示目录";
  document.getElementById("switch-btn").style.display="block";
  document.getElementById("switch-area").style.display="block";
  }
  }
</script>


<div class="share">
	<div class="bdsharebuttonbox">
	<a href="#" class="bds_more" data-cmd="more"></a>
	<a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
	<a href="#" class="bds_copy" data-cmd="copy" title="复制网址"></a>
	<a href="#" class="bds_mail" data-cmd="mail" title="通过邮件分享"></a>
	<a href="#" class="bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
	</div>
	<script>
	window._bd_share_config={
		"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
	</script>
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="2015/08/12/AndroidL-hwui-RenderThread-workflow.html" data-title="Android5.0中 hwui 中 RenderThread 工作流程" data-url="http://androidperformance.com/2015/08/12/AndroidL-hwui-RenderThread-workflow.html"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"grackertalk"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>






    <style type="text/css">
    #scroll {
      display: none;
    }
    </style>
    <div class="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#ds-thread" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
    </div>


  
  
    
    <div  class="post-nav-button">
    <a href="/2015/11/09/Performance ListView.html" title="上一篇: ">
    <i class="fa fa-angle-left"></i>
    </a>
    <a href="/2015/08/05/HashMap.html" title="下一篇: HashMap源码分析">
    <i class="fa fa-angle-right"></i>
    </a>
    </div>
  



    
        <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
        <script>
        var yiliaConfig = {
        fancybox: true,
        mathjax: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        open_in_new: false
        }
        </script>
        
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2015 Gracker
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的静态博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减双栏 Hexo 博客主题">Yelee</a> by MOxFIVE
        </div>
    </div>
    <div class="visit">
      <span id="busuanzi_container_site_pv" style='display:none'>
        <span id="site-visit" >本站到访数: 
        <span id="busuanzi_value_site_uv"></span>
        </span>
      </span>
      <span id="busuanzi_container_page_pv" style='display:none'>
        <span id="page-visit">, 本页阅读量: 
        <span id="busuanzi_value_page_pv"></span>
        </span>
      </span>
    </div>
  </div>
</footer>
    </div>
    

<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>

<script>
  var backgroundnum = 5;
  var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));

  $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
</script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-50993302-2', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
<a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
<a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>