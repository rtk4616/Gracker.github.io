<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="专注 Android 性能优化"><title>Android内存优化之一：MAT使用入门 | Android Performance</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.2"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-50993302-2','auto');
ga('require', 'GTM-5T9PB73');
ga('send','pageview');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android内存优化之一：MAT使用入门</h1><a id="logo" href="/.">Android Performance</a><p class="description">True mastery of any skill takes a lifetime</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android内存优化之一：MAT使用入门</h1><div class="post-meta">Apr 11, 2015<span> | </span><span class="category"><a href="/categories/Android/">Android</a><a href="/categories/Android/Memory/">Memory</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h2 id="MAT简介"><a href="#MAT简介" class="headerlink" title="MAT简介"></a>MAT简介</h2><h3 id="MAT介绍"><a href="#MAT介绍" class="headerlink" title="MAT介绍"></a>MAT介绍</h3><p>MAT(Memory Analyzer Tool)，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的JAVA heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗。使用内存分析工具从众多的对象中进行分析，快速的计算出在内存中对象的占用大小，看看是谁阻止了垃圾收集器的回收工作，并可以通过报表直观的查看到可能造成这种结果的对象。  </p>
<p><img src="/images/MAT/MAT_Intro.png" alt="image"></p>
<p>当然MAT也有独立的不依赖Eclipse的版本，只不过这个版本在调试Android内存的时候，需要将DDMS生成的文件进行转换，才可以在独立版本的MAT上打开。不过Android SDK中已经提供了这个Tools，所以使用起来也是很方便的。</p>
<a id="more"></a>
<h3 id="MAT工具的下载安装"><a href="#MAT工具的下载安装" class="headerlink" title="MAT工具的下载安装"></a>MAT工具的下载安装</h3><p>这里是MAT的下载地址：<a href="https://eclipse.org/mat/ downloads.php" target="_blank" rel="external">https://eclipse.org/mat/downloads.php</a>，下载时会提供三种选择的方式：</p>
<p><img src="/images/MAT/MAT_Download.png" alt="image"></p>
<ul>
<li>Update Site  这种方式后面会有一个网址：比如<a href="http://download.eclipse.org/mat/1.4/update-site/" target="_blank" rel="external">http://download.eclipse.org/mat/1.4/update-site/</a> ，安装过Eclipse插件的同学应该知道，只要把这段网址复制到对应的Eclipse的Install New Software那里，就可以进行在线下载了。</li>
</ul>
<p><img src="/images/MAT/MAT_Eclipse_Install.png" alt="image"></p>
<ul>
<li>Archived Update Site  这种方式安装的位置和上一种差不多，只不过第一种是在线下载，这一种是使用离线包进行更新，这种方式劣势是当这个插件更新后，需要重新下载离线包，而第一种方式则可以在线下载更新。</li>
<li>Stand-alone Eclipse RCP Applications 这种方式就是把MAT当成一个独立的工具使用，不再依附于Eclipse，适合不使用Eclipse而使用Android Studio的同学。这种方式有个麻烦的地方就是DDMS导出的文件，需要进行转换才可以在MAT中打开。</li>
</ul>
<p>下载安装好之后，就可以使用MAT进行实际的操作了。</p>
<h2 id="Android-Java-中常见的容易引起内存泄露的不良代码"><a href="#Android-Java-中常见的容易引起内存泄露的不良代码" class="headerlink" title="Android(Java)中常见的容易引起内存泄露的不良代码"></a>Android(Java)中常见的容易引起内存泄露的不良代码</h2><h3 id="Android内存"><a href="#Android内存" class="headerlink" title="Android内存"></a>Android内存</h3><p>使用MAT工具之前，要对Android的内存分配方式有基本的了解，对容易引起内存泄露的代码也要保持敏感，在代码级别对内存泄露的排查，有助于内存的使用。</p>
<p>Android主要应用在嵌入式设备当中，而嵌入式设备由于一些众所周知的条件限制，通常都不会有很高的配置，特别是内存是比较有限的。如果我们编写的代码当中有太多的对内存使用不当的地方，难免会使得我们的设备运行缓慢，甚至是死机。为了能够使得Android应用程序安全且快速的运行，Android的每个应用程序都会使用一个专有的Dalvik虚拟机实例来运行，它是由Zygote服务进程孵化出来的，也就是说每个应用程序都是在属于自己的进程中运行的。一方面，如果程序在运行过程中出现了内存泄漏的问题，仅仅会使得自己的进程被kill掉，而不会影响其他进程（如果是system_process等系统进程出问题的话，则会引起系统重启）。另一方面Android为不同类型的进程分配了不同的内存使用上限，如果应用进程使用的内存超过了这个上限，则会被系统视为内存泄漏，从而被kill掉。</p>
<h3 id="常见的内存使用不当的情况"><a href="#常见的内存使用不当的情况" class="headerlink" title="常见的内存使用不当的情况"></a>常见的内存使用不当的情况</h3><h4 id="查询数据库没有关闭游标"><a href="#查询数据库没有关闭游标" class="headerlink" title="查询数据库没有关闭游标"></a>查询数据库没有关闭游标</h4><p>描述：<br>程序中经常会进行查询数据库的操作，但是经常会有使用完毕Cursor后没有关闭的情况。如果我们的查询结果集比较小，对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会复现内存问题，这样就会给以后的测试和问题排查带来困难和风险。<br>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Cursor cursor = getContentResolver().query(uri ...);</div><div class="line">	<span class="keyword">if</span> (cursor.moveToNext()) &#123;</div><div class="line"> 	... ... </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>修正示例代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Cursor cursor = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  	cursor = getContentResolver().query(uri ...);</div><div class="line">	<span class="keyword">if</span> (cursor != <span class="keyword">null</span> &amp;&amp; cursor.moveToNext()) &#123;</div><div class="line">	... ... </div><div class="line">	&#125;</div><div class="line">	&#125; <span class="keyword">finally</span> &#123;</div><div class="line">		<span class="keyword">if</span> (cursor != <span class="keyword">null</span>) &#123;</div><div class="line">	<span class="keyword">try</span> &#123; </div><div class="line">		cursor.close();</div><div class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">		<span class="comment">//ignore this</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>`</p>
<h4 id="构造Adapter时，没有使用缓存的-convertView"><a href="#构造Adapter时，没有使用缓存的-convertView" class="headerlink" title="构造Adapter时，没有使用缓存的 convertView"></a>构造Adapter时，没有使用缓存的 convertView</h4><p>描述：以构造ListView的BaseAdapter为例，在BaseAdapter中提供了方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span></span></div></pre></td></tr></table></figure>
<p>来向ListView提供每一个item所需要的view对象。初始时ListView会从BaseAdapter中根据当前的屏幕布局实例化一定数量的view对象，同时ListView会将这些view对象缓存起来。当向上滚动ListView时，原先位于最上面的list item的view对象会被回收，然后被用来构造新出现的最下面的list item。这个构造过程就是由getView()方法完成的，getView()的第二个形参 View convertView就是被缓存起来的list item的view对象(初始化时缓存中没有view对象则convertView是null)。<br>由此可以看出，如果我们不去使用convertView，而是每次都在getView()中重新实例化一个View对象的话，即浪费资源也浪费时间，也会使得内存占用越来越大。ListView回收list item的view对象的过程可以查看:android.widget.AbsListView.java –> void addScrapView(View scrap) 方法。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</div><div class="line"> View view = <span class="keyword">new</span> Xxx(...);</div><div class="line"> ... ...</div><div class="line"> <span class="keyword">return</span> view;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>`<br>示例修正代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</div><div class="line"> View view = <span class="keyword">null</span>;</div><div class="line"> <span class="keyword">if</span> (convertView != <span class="keyword">null</span>) &#123;</div><div class="line"> view = convertView;</div><div class="line"> populate(view, getItem(position));</div><div class="line"> ...</div><div class="line"> &#125; <span class="keyword">else</span> &#123;</div><div class="line"> view = <span class="keyword">new</span> Xxx(...);</div><div class="line"> ...</div><div class="line"> &#125;</div><div class="line"> <span class="keyword">return</span> view;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于ListView的使用和优化，可以参考这两篇文章：</p>
<ul>
<li><a href="http://www.vogella.com/tutorials/AndroidListView/article.html" target="_blank" rel="external">Using lists in Android (ListView) - Tutorial<br>  ]()</a></li>
<li><a href="http://developer.android.com/training/improving-layouts/smooth-scrolling.html#ViewHolder" target="_blank" rel="external">Making ListView Scrolling Smooth</a></li>
</ul>
<h4 id="Bitmap对象不在使用时调用recycle-释放内存"><a href="#Bitmap对象不在使用时调用recycle-释放内存" class="headerlink" title="Bitmap对象不在使用时调用recycle()释放内存"></a>Bitmap对象不在使用时调用recycle()释放内存</h4><p>描述：有时我们会手工的操作Bitmap对象，如果一个Bitmap对象比较占内存，当它不在被使用的时候，可以调用Bitmap.recycle()方法回收此对象的像素所占用的内存。<br>另外在最新版本的Android开发时，使用下面的方法也可以释放此Bitmap所占用的内存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Bitmap bitmap ;</div><div class="line"> ...</div><div class="line"> bitmap初始化以及使用</div><div class="line"> ...</div><div class="line">bitmap = <span class="keyword">null</span>;</div></pre></td></tr></table></figure>
<h4 id="释放对象的引用"><a href="#释放对象的引用" class="headerlink" title="释放对象的引用"></a>释放对象的引用</h4><p>描述：这种情况描述起来比较麻烦，举两个例子进行说明。</p>
<p>示例A：<br>假设有如下操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">	... ...</div><div class="line">	<span class="keyword">private</span> Handler mHandler = ...</div><div class="line">	<span class="keyword">private</span> Object obj;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</div><div class="line">	 obj = initObj();</div><div class="line">	 ...</div><div class="line">	 [Mark]</div><div class="line">	 mHandler.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">	        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">	         useObj(obj);</div><div class="line">	        &#125;</div><div class="line">	 &#125;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们有一个成员变量 obj，在operation()中我们希望能够将处理obj实例的操作post到某个线程的MessageQueue中。在以上的代码中，即便是mHandler所在的线程使用完了obj所引用的对象，但这个对象仍然不会被垃圾回收掉，因为DemoActivity.obj还保有这个对象的引用。所以如果在DemoActivity中不再使用这个对象了，可以在[Mark]的位置释放对象的引用，而代码可以修改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</div><div class="line">	obj = initObj();</div><div class="line">	...</div><div class="line">	<span class="keyword">final</span> Object o = obj;</div><div class="line">	obj = <span class="keyword">null</span>;</div><div class="line">	mHandler.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">	        useObj(o);</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>示例B：<br>假设我们希望在锁屏界面(LockScreen)中，监听系统中的电话服务以获取一些信息(如信号强度等)，则可以在LockScreen中定义一个PhoneStateListener的对象，同时将它注册到TelephonyManager服务中。对于LockScreen对象，当需要显示锁屏界面的时候就会创建一个LockScreen对象，而当锁屏界面消失的时候LockScreen对象就会被释放掉。  </p>
<p>但是如果在释放LockScreen对象的时候忘记取消我们之前注册的PhoneStateListener对象，则会导致LockScreen无法被垃圾回收。如果不断的使锁屏界面显示和消失，则最终会由于大量的LockScreen对象没有办法被回收而引起OutOfMemory,使得system_process进程挂掉。</p>
<p>总之当一个生命周期较短的对象A，被一个生命周期较长的对象B保有其引用的情况下，在A的生命周期结束时，要在B中清除掉对A的引用。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>Android应用程序中最典型的需要注意释放资源的情况是在Activity的生命周期中，在onPause()、onStop()、onDestroy()方法中需要适当的释放资源的情况。由于此情况很基础，在此不详细说明，具体可以查看官方文档对Activity生命周期的介绍，以明确何时应该释放哪些资源。</p>
<p>另外一些其他的例子，将会在补充版本加入。</p>
<h2 id="使用MAT进行内存调试"><a href="#使用MAT进行内存调试" class="headerlink" title="使用MAT进行内存调试"></a>使用MAT进行内存调试</h2><h3 id="获取HPROF文件"><a href="#获取HPROF文件" class="headerlink" title="获取HPROF文件"></a>获取HPROF文件</h3><p>HPROF文件是MAT能识别的文件，HPROF文件存储的是特定时间点，java进程的内存快照。有不同的格式来存储这些数据，总的来说包含了快照被触发时java对象和类在heap中的情况。由于快照只是一瞬间的事情，所以heap dump中无法包含一个对象在何时、何地（哪个方法中）被分配这样的信息。<br>这个文件可以使用DDMS导出：</p>
<ol>
<li><p>DDMS中在Devices上面有一排按钮，选择一个进程后（即在Devices下面列出的列表中选择你要调试的应用程序的包名），点击Dump HPROF file 按钮：</p>
<p><img src="/images/MAT/MAT_DDMS_ExportFile.png" alt="image">  </p>
</li>
</ol>
<p>选择存储路径保存后就可以得到对应进程的HPROF文件。eclipse插件可以把上面的工作一键完成。只需要点击Dump HPROF file图标，然后MAT插件就会自动转换格式，并且在eclipse中打开分析结果。eclipse中还专门有个Memory Analysis视图  </p>
<ol>
<li>得到对应的文件后，如果安装了Eclipse插件，那么切换到Memory Analyzer视图。使用独立安装的，要使用Android SDK自带的的工具（hprof-conv 位置在sdk/platform-tools/hprof-conv）进行转换</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hprof-conv xxx.xxx.xxx.hprof xxx.xxx.xxx.hprof</div></pre></td></tr></table></figure>
<p>转换过后的.hprof文件即可使用MAT工具打开了。</p>
<h3 id="MAT主界面介绍"><a href="#MAT主界面介绍" class="headerlink" title="MAT主界面介绍"></a>MAT主界面介绍</h3><p>这里介绍的不是MAT这个工具的主界面，而是导入一个文件之后，显示OverView的界面。</p>
<ul>
<li>打开经过转换的hprof文件：<br>  <img src="/images/MAT/MAT_OpenFile.png" alt="image"></li>
</ul>
<p>如果选择了第一个，则会生成一个报告。这个无大碍。  </p>
<p><img src="/images/MAT/MAT_Report.png" alt="image"></p>
<ul>
<li><p>选择OverView界面：  </p>
<p><img src="/images/MAT/MAT_Overview.png" alt="Image"></p>
</li>
</ul>
<p>我们需要关注的是下面的Actions区域</p>
<ul>
<li><p>Histogram：列出内存中的对象，对象的个数以及大小  </p>
<p><img src="/images/MAT/MAT_Histogram.png" alt="image"></p>
</li>
<li><p>Dominator Tree：列出最大的对象以及其依赖存活的Object （大小是以Retained Heap为标准排序的）  </p>
<p><img src="/images/MAT/MAT_DominatorTree.png" alt="image"></p>
</li>
<li><p>Top Consumers ： 通过图形列出最大的object  </p>
<p><img src="/images/MAT/MAT_TopConsumers.png" alt="image"></p>
</li>
<li><p>Duplicate Class：通过MAT自动分析泄漏的原因</p>
</li>
</ul>
<p>一般Histogram和 Dominator Tree是最常用的。  </p>
<h3 id="MAT中一些概念介绍"><a href="#MAT中一些概念介绍" class="headerlink" title="MAT中一些概念介绍"></a>MAT中一些概念介绍</h3><p>要看懂MAT的列表信息，Shallow heap、Retained Heap、GC Root这几个概念一定要弄懂。</p>
<h4 id="3-3-1-Shallow-heap"><a href="#3-3-1-Shallow-heap" class="headerlink" title="3.3.1 Shallow heap"></a>3.3.1 Shallow heap</h4><p>Shallow size就是对象本身占用内存的大小，不包含其引用的对象。  </p>
<ul>
<li>常规对象（非数组）的Shallow size有其成员变量的数量和类型决定。</li>
<li>数组的shallow size有数组元素的类型（对象类型、基本类型）和数组长度决定</li>
</ul>
<p>因为不像c++的对象本身可以存放大量内存，java的对象成员都是些引用。真正的内存都在堆上，看起来是一堆原生的byte[], char[], int[]，所以我们如果只看对象本身的内存，那么数量都很小。所以我们看到Histogram图是以Shallow size进行排序的，排在第一位第二位的是byte，char 。</p>
<h4 id="3-3-2-Retained-Heap"><a href="#3-3-2-Retained-Heap" class="headerlink" title="3.3.2 Retained Heap"></a>3.3.2 Retained Heap</h4><p>Retained Heap的概念，它表示如果一个对象被释放掉，那会因为该对象的释放而减少引用进而被释放的所有的对象（包括被递归释放的）所占用的heap大小。于是，如果一个对象的某个成员new了一大块int数组，那这个int数组也可以计算到这个对象中。相对于shallow heap，Retained heap可以更精确的反映一个对象实际占用的大小（因为如果该对象释放，retained heap都可以被释放）。</p>
<p>这里要说一下的是，Retained Heap并不总是那么有效。例如我在A里new了一块内存，赋值给A的一个成员变量。此时我让B也指向这块内存。此时，因为A和B都引用到这块内存，所以A释放时，该内存不会被释放。所以这块内存不会被计算到A或者B的Retained Heap中。为了纠正这点，MAT中的Leading Object（例如A或者B）不一定只是一个对象，也可以是多个对象。此时，(A, B)这个组合的Retained Set就包含那块大内存了。对应到MAT的UI中，在Histogram中，可以选择Group By class, superclass or package来选择这个组。</p>
<p>为了计算Retained Memory，MAT引入了Dominator Tree。加入对象A引用B和C，B和C又都引用到D（一个菱形）。此时要计算Retained Memory，A的包括A本身和B，C，D。B和C因为共同引用D，所以他俩的Retained Memory都只是他们本身。D当然也只是自己。我觉得是为了加快计算的速度，MAT改变了对象引用图，而转换成一个对象引用树。在这里例子中，树根是A，而B，C，D是他的三个儿子。B，C，D不再有相互关系。把引用图变成引用树，计算Retained Heap就会非常方便，显示也非常方便。对应到MAT UI上，在dominator tree这个view中，显示了每个对象的shallow heap和retained heap。然后可以以该节点位树根，一步步的细化看看retained heap到底是用在什么地方了。要说一下的是，这种从图到树的转换确实方便了内存分析，但有时候会让人有些疑惑。本来对象B是对象A的一个成员，但因为B还被C引用，所以B在树中并不在A下面，而很可能是平级。</p>
<p>为了纠正这点，MAT中点击右键，可以List objects中选择with outgoing references和with incoming references。这是个真正的引用图的概念，</p>
<ul>
<li>outgoing references ：表示该对象的出节点（被该对象引用的对象）。</li>
<li>incoming references ：表示该对象的入节点（引用到该对象的对象）。</li>
</ul>
<p>为了更好地理解Retained Heap，下面引用一个例子来说明：  </p>
<p>把内存中的对象看成下图中的节点，并且对象和对象之间互相引用。这里有一个特殊的节点GC Roots，这就是reference chain(引用链)的起点:<br><img src="/images/MAT/MAT_Retained_objects.gif" alt="image"> <img src="../images/MAT/MAT_Retained_objects_2.gif" alt="image"></p>
<p>从obj1入手，上图中蓝色节点代表仅仅只有通过obj1才能直接或间接访问的对象。因为可以通过GC Roots访问，所以左图的obj3不是蓝色节点；而在右图却是蓝色，因为它已经被包含在retained集合内。<br>所以对于左图，obj1的retained size是obj1、obj2、obj4的shallow size总和；<br>右图的retained size是obj1、obj2、obj3、obj4的shallow size总和。<br>obj2的retained size可以通过相同的方式计算。</p>
<h4 id="GC-Root"><a href="#GC-Root" class="headerlink" title="GC Root"></a>GC Root</h4><p>GC发现通过任何reference chain(引用链)无法访问某个对象的时候，该对象即被回收。名词GC Roots正是分析这一过程的起点，例如JVM自己确保了对象的可到达性(那么JVM就是GC Roots)，所以GC Roots就是这样在内存中保持对象可到达性的，一旦不可到达，即被回收。通常GC Roots是一个在current thread(当前线程)的call stack(调用栈)上的对象（例如方法参数和局部变量），或者是线程自身或者是system class loader(系统类加载器)加载的类以及native code(本地代码)保留的活动对象。所以GC Roots是分析对象为何还存活于内存中的利器。</p>
<h3 id="MAT中的一些有用的视图"><a href="#MAT中的一些有用的视图" class="headerlink" title="MAT中的一些有用的视图"></a>MAT中的一些有用的视图</h3><h4 id="Thread-OvewView"><a href="#Thread-OvewView" class="headerlink" title="Thread OvewView"></a>Thread OvewView</h4><p>Thread OvewView可以查看这个应用的Thread信息：<br><img src="/images/MAT/MAT_ThreadOverView.png" alt="image"></p>
<h4 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h4><p>在Histogram和Domiantor Tree界面，可以选择将结果用另一种Group的方式显示（默认是Group by Object），切换到Group by package，可以更好地查看具体是哪个包里的类占用内存大，也很容易定位到自己的应用程序。<br><img src="/images/MAT/MAT_Group.png" alt="image"></p>
<h4 id="Path-to-GC-Root"><a href="#Path-to-GC-Root" class="headerlink" title="Path to GC Root"></a>Path to GC Root</h4><p>在Histogram或者Domiantor Tree的某一个条目上，右键可以查看其GC Root Path：<br><img src="/images/MAT/MAT_PathToGCRoot.png" alt="image"></p>
<p>这里也要说明一下Java的引用规则：<br>从最强到最弱，不同的引用（可到达性）级别反映了对象的生命周期。  </p>
<ul>
<li>Strong Ref(强引用)：通常我们编写的代码都是Strong Ref，于此对应的是强可达性，只有去掉强可达，对象才被回收。</li>
<li>Soft Ref(软引用)：对应软可达性，只要有足够的内存，就一直保持对象，直到发现内存吃紧且没有Strong Ref时才回收对象。一般可用来实现缓存，通过java.lang.ref.SoftReference类实现。</li>
<li>Weak Ref(弱引用)：比Soft Ref更弱，当发现不存在Strong Ref时，立刻回收对象而不必等到内存吃紧的时候。通过java.lang.ref.WeakReference和java.util.WeakHashMap类实现。</li>
<li>Phantom Ref(虚引用)：根本不会在内存中保持任何对象，你只能使用Phantom Ref本身。一般用于在进入finalize()方法后进行特殊的清理过程，通过 java.lang.ref.PhantomReference实现。</li>
</ul>
<p>点击Path To GC Roots –> with all references<br><img src="/images/MAT/MAT_PathToGCRoot_Detail.png" alt="image"></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="http://www.yourkit.com/docs/java/help/sizes.jsp" target="_blank" rel="external">Shallow and retained sizes</a></li>
<li>MAT的wiki：<a href="http://wiki.eclipse.org/index.php/MemoryAnalyzer" target="_blank" rel="external">http://wiki.eclipse.org/index.php/MemoryAnalyzer</a></li>
</ol>
</div><iframe src="/donate/?AliPayQR=/img/AliPayQR.png&amp;WeChatQR=/img/WeChatQR.png&amp;GitHub=undefined&amp;BTCQR=undefined&amp;BTCKEY=undefined&amp;PayPal=undefined" style="overflow-x:hidden;overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div class="tags"><a href="/tags/Android/">Android</a><a href="/tags/MAT/">MAT</a><a href="/tags/Performance/">Performance</a><a href="/tags/Memory/">Memory</a></div><div class="post-nav"><a href="/2015/04/11/AndroidMemory-Usage-Of-MAT-Pro.html" class="pre">Android内存优化之二：MAT使用进阶</a><a href="/2015/03/31/android-performance-case-study-follow-up.html" class="next">Android性能优化后续</a></div><div id="lv-container" data-id="city" data-uid="MTAyMC8zMjY3NC85MjM1"><script>(function(d, s) {
   var j, e = d.getElementsByTagName(s)[0];
   if (typeof LivereTower === 'function') { return; }
   j = d.createElement(s);
   j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
   j.async = true;
   e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">39</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Github/">Github</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Memory/">Memory</a><span class="category-list-count">13</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Memory/Performance/">Performance</a><span class="category-list-count">10</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Performance/">Performance</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/View/">View</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/性能优化/">性能优化</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/设计/">设计</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/设计/翻译/">翻译</a><span class="category-list-count">2</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">Life</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/2017/">2017</a><span class="category-list-count">1</span></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/hwui/" style="font-size: 15px;">hwui</a> <a href="/tags/推荐/" style="font-size: 15px;">推荐</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/MAT/" style="font-size: 15px;">MAT</a> <a href="/tags/Performance/" style="font-size: 15px;">Performance</a> <a href="/tags/Memory/" style="font-size: 15px;">Memory</a> <a href="/tags/启动优化/" style="font-size: 15px;">启动优化</a> <a href="/tags/DelayLoad/" style="font-size: 15px;">DelayLoad</a> <a href="/tags/随笔/" style="font-size: 15px;">随笔</a> <a href="/tags/RenderThread/" style="font-size: 15px;">RenderThread</a> <a href="/tags/Menory/" style="font-size: 15px;">Menory</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/HashMap/" style="font-size: 15px;">HashMap</a> <a href="/tags/Nexus/" style="font-size: 15px;">Nexus</a> <a href="/tags/Singleton/" style="font-size: 15px;">Singleton</a> <a href="/tags/设计规范/" style="font-size: 15px;">设计规范</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/01/06/2017年度最推荐.html">2017年度最推荐</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/19/Android-performance-optimization-skills-and-tools.html">Android 性能优化必知必会</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/23/About-work.html">关于 2017</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/05/android-bottom-bar-2.html">Android Bottom navigation 规范二：样式、行为与规格</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/05/android-bottom-bar-1.html">Android Bottom navigation 规范一：使用方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/31/How-to-calculation-android-app-lunch-time.html">Android 中如何计算 App 的启动时间？</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/29/Android应用启动优化-一种DelayLoad的实现和原理-下篇.html">Android应用启动优化:一种DelayLoad的实现和原理(下篇)</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/11/18/Android-app-lunch-optimize-delay-load.html">Android应用启动优化:一种DelayLoad的实现和原理(上篇)</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/12/AndroidL-hwui-RenderThread-workflow.html">Android5.0中 hwui 中 RenderThread 工作流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/05/HashMap.html">HashMap源码分析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://hexo.io" title="Hexo" target="_blank">Hexo</a><ul></ul><a href="https://pages.github.com/" title="GitHub" target="_blank">GitHub</a><ul></ul><a href="http://moxfive.xyz/" title="MOxFIVE" target="_blank">MOxFIVE</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Android Performance.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.2" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.2" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.2"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.2"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.2"></script></div></body></html>